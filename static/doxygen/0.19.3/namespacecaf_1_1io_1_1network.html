<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ Actor Framework: caf::io::network Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C++ Actor Framework<span id="projectnumber">&#160;0.19</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecaf.html">caf</a></li><li class="navelem"><a class="el" href="namespacecaf_1_1io.html">io</a></li><li class="navelem"><a class="el" href="namespacecaf_1_1io_1_1network.html">network</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">caf::io::network Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Contains classes and functions used for network abstraction.  
<a href="namespacecaf_1_1io_1_1network.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1acceptor.html">acceptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An acceptor is responsible for accepting incoming connections.  <a href="classcaf_1_1io_1_1network_1_1acceptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1acceptor__impl.html">acceptor_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete acceptor with a technology-dependent policy.  <a href="classcaf_1_1io_1_1network_1_1acceptor__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1acceptor__manager.html">acceptor_manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An acceptor manager configures an acceptor and provides callbacks for incoming connections as well as for error handling.  <a href="classcaf_1_1io_1_1network_1_1acceptor__manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1datagram__handler__impl.html">datagram_handler_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete datagram_handler with a technology-dependent policy.  <a href="classcaf_1_1io_1_1network_1_1datagram__handler__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1datagram__manager.html">datagram_manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A datagram manager provides callbacks for outgoing datagrams as well as for error handling.  <a href="classcaf_1_1io_1_1network_1_1datagram__manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1datagram__servant__impl.html">datagram_servant_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default datagram servant implementation.  <a href="classcaf_1_1io_1_1network_1_1datagram__servant__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1doorman__impl.html">doorman_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default doorman implementation.  <a href="classcaf_1_1io_1_1network_1_1doorman__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1event__handler.html">event_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A socket I/O event handler.  <a href="classcaf_1_1io_1_1network_1_1event__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1interfaces.html">interfaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class bundling access to network interface names and addresses.  <a href="classcaf_1_1io_1_1network_1_1interfaces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1io_1_1network_1_1ip__endpoint.html">ip_endpoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hashable wrapper for a sockaddr storage.  <a href="structcaf_1_1io_1_1network_1_1ip__endpoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1manager.html">manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A manager configures an I/O device and provides callbacks for various I/O operations.  <a href="classcaf_1_1io_1_1network_1_1manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1multiplexer.html">multiplexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level backend for IO multiplexing.  <a href="classcaf_1_1io_1_1network_1_1multiplexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1pipe__reader.html">pipe_reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event handler for the internal event pipe.  <a href="classcaf_1_1io_1_1network_1_1pipe__reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1io_1_1network_1_1protocol.html">protocol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles protocol information for network and transport layer communication.  <a href="structcaf_1_1io_1_1network_1_1protocol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1receive__buffer.html">receive_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that does not call constructors and destructors for its values.  <a href="classcaf_1_1io_1_1network_1_1receive__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1scribe__impl.html">scribe_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default scribe implementation.  <a href="classcaf_1_1io_1_1network_1_1scribe__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1stream.html">stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream capable of both reading and writing.  <a href="classcaf_1_1io_1_1network_1_1stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1stream__impl.html">stream_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete stream with a technology-dependent policy for sending and receiving data from a socket.  <a href="classcaf_1_1io_1_1network_1_1stream__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1io_1_1network_1_1stream__manager.html">stream_manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream manager configures an IO stream and provides callbacks for incoming data as well as for error handling.  <a href="classcaf_1_1io_1_1network_1_1stream__manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a71a33b5a338f8bb6a155cffc3ae23f45"><td class="memItemLeft" align="right" valign="top"><a id="a71a33b5a338f8bb6a155cffc3ae23f45" name="a71a33b5a338f8bb6a155cffc3ae23f45"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>address_listing</b> = std::map&lt; <a class="el" href="structcaf_1_1io_1_1network_1_1protocol.html#a00405c7e34886bce1b4354d1caa3b6f6">protocol::network</a>, std::vector&lt; std::string &gt; &gt;</td></tr>
<tr class="separator:a71a33b5a338f8bb6a155cffc3ae23f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089511219d8194856f9b2893670119e2"><td class="memItemLeft" align="right" valign="top"><a id="a089511219d8194856f9b2893670119e2" name="a089511219d8194856f9b2893670119e2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>event_mask_type</b> = short</td></tr>
<tr class="separator:a089511219d8194856f9b2893670119e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b02d58675e1aaa2748db6b08ba079ba"><td class="memItemLeft" align="right" valign="top"><a id="a6b02d58675e1aaa2748db6b08ba079ba" name="a6b02d58675e1aaa2748db6b08ba079ba"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>multiplexer_data</b> = pollfd</td></tr>
<tr class="separator:a6b02d58675e1aaa2748db6b08ba079ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a8edbf7df06189c046ed45168ed1ea"><td class="memItemLeft" align="right" valign="top"><a id="a11a8edbf7df06189c046ed45168ed1ea" name="a11a8edbf7df06189c046ed45168ed1ea"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>multiplexer_poll_shadow_data</b> = std::vector&lt; <a class="el" href="classcaf_1_1io_1_1network_1_1event__handler.html">event_handler</a> * &gt;</td></tr>
<tr class="separator:a11a8edbf7df06189c046ed45168ed1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba39e59ea5512495e171ab57606e20d"><td class="memItemLeft" align="right" valign="top"><a id="a1ba39e59ea5512495e171ab57606e20d" name="a1ba39e59ea5512495e171ab57606e20d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>interfaces_map</b> = std::map&lt; std::string, std::map&lt; <a class="el" href="structcaf_1_1io_1_1network_1_1protocol.html#a00405c7e34886bce1b4354d1caa3b6f6">protocol::network</a>, std::vector&lt; std::string &gt; &gt; &gt;</td></tr>
<tr class="separator:a1ba39e59ea5512495e171ab57606e20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882a4f6b16f38ff968d888801c246867"><td class="memItemLeft" align="right" valign="top"><a id="a882a4f6b16f38ff968d888801c246867" name="a882a4f6b16f38ff968d888801c246867"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>multiplexer_ptr</b> = std::unique_ptr&lt; <a class="el" href="classcaf_1_1io_1_1network_1_1multiplexer.html">multiplexer</a> &gt;</td></tr>
<tr class="separator:a882a4f6b16f38ff968d888801c246867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d29bd5baa7c76daf797dffa9e7b7f2"><td class="memItemLeft" align="right" valign="top"><a id="a29d29bd5baa7c76daf797dffa9e7b7f2" name="a29d29bd5baa7c76daf797dffa9e7b7f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>setsockopt_ptr</b> = const void *</td></tr>
<tr class="separator:a29d29bd5baa7c76daf797dffa9e7b7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbe06ceb8cd9cc89e54ddd056562ec7"><td class="memItemLeft" align="right" valign="top"><a id="a7dbe06ceb8cd9cc89e54ddd056562ec7" name="a7dbe06ceb8cd9cc89e54ddd056562ec7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>getsockopt_ptr</b> = void *</td></tr>
<tr class="separator:a7dbe06ceb8cd9cc89e54ddd056562ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee9be1e9e9c3c8d6b4acc2c48f1ad6c"><td class="memItemLeft" align="right" valign="top"><a id="a7ee9be1e9e9c3c8d6b4acc2c48f1ad6c" name="a7ee9be1e9e9c3c8d6b4acc2c48f1ad6c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>socket_send_ptr</b> = const void *</td></tr>
<tr class="separator:a7ee9be1e9e9c3c8d6b4acc2c48f1ad6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7e9bac078fdad534765db2ec4b75ce"><td class="memItemLeft" align="right" valign="top"><a id="adb7e9bac078fdad534765db2ec4b75ce" name="adb7e9bac078fdad534765db2ec4b75ce"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>socket_recv_ptr</b> = void *</td></tr>
<tr class="separator:adb7e9bac078fdad534765db2ec4b75ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401096239c94620c8c1d3a50c2a4433d"><td class="memItemLeft" align="right" valign="top"><a id="a401096239c94620c8c1d3a50c2a4433d" name="a401096239c94620c8c1d3a50c2a4433d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>socket_size_type</b> = unsigned</td></tr>
<tr class="separator:a401096239c94620c8c1d3a50c2a4433d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1732e72d6ed064757ba3b9972f4321"><td class="memItemLeft" align="right" valign="top"><a id="a2a1732e72d6ed064757ba3b9972f4321" name="a2a1732e72d6ed064757ba3b9972f4321"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>signed_size_type</b> = std::make_signed_t&lt; size_t &gt;</td></tr>
<tr class="separator:a2a1732e72d6ed064757ba3b9972f4321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48438c582065f7ed2a0737fa36f1c613"><td class="memItemLeft" align="right" valign="top"><a id="a48438c582065f7ed2a0737fa36f1c613" name="a48438c582065f7ed2a0737fa36f1c613"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>native_socket</b> = int</td></tr>
<tr class="separator:a48438c582065f7ed2a0737fa36f1c613"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a88e180a8a20a501a2b971ff0f8bd578b"><td class="memItemLeft" align="right" valign="top"><a id="a88e180a8a20a501a2b971ff0f8bd578b" name="a88e180a8a20a501a2b971ff0f8bd578b"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf_1_1io_1_1network.html#a88e180a8a20a501a2b971ff0f8bd578b">operation</a> { <br />
&#160;&#160;<b>read</b>
, <br />
&#160;&#160;<b>write</b>
, <br />
&#160;&#160;<b>propagate_error</b>
<br />
 }</td></tr>
<tr class="memdesc:a88e180a8a20a501a2b971ff0f8bd578b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies network IO operations, i.e., read or write. <br /></td></tr>
<tr class="separator:a88e180a8a20a501a2b971ff0f8bd578b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb11678f0cd9b855baab1fd86aeeac15"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf_1_1io_1_1network.html#abb11678f0cd9b855baab1fd86aeeac15">rw_state</a> { <br />
&#160;&#160;<a class="el" href="namespacecaf_1_1io_1_1network.html#abb11678f0cd9b855baab1fd86aeeac15a260ca9dd8a4577fc00b7bd5810298076">success</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf_1_1io_1_1network.html#abb11678f0cd9b855baab1fd86aeeac15a3ee28fe1a60c95b89d29317f122c7021">failure</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf_1_1io_1_1network.html#abb11678f0cd9b855baab1fd86aeeac15a44560d82707cce3b8111a770924cf0e2">indeterminate</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf_1_1io_1_1network.html#abb11678f0cd9b855baab1fd86aeeac15aab2ab2a262e872718991cabbdee9ef8e">want_read</a>
<br />
 }</td></tr>
<tr class="memdesc:abb11678f0cd9b855baab1fd86aeeac15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes the returned state of read and write operations on sockets.  <a href="namespacecaf_1_1io_1_1network.html#abb11678f0cd9b855baab1fd86aeeac15">More...</a><br /></td></tr>
<tr class="separator:abb11678f0cd9b855baab1fd86aeeac15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0817361a72b2f07f6515c740fb73ca56"><td class="memItemLeft" align="right" valign="top"><a id="a0817361a72b2f07f6515c740fb73ca56" name="a0817361a72b2f07f6515c740fb73ca56"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>add_flag</b> (<a class="el" href="namespacecaf_1_1io_1_1network.html#a88e180a8a20a501a2b971ff0f8bd578b">operation</a> op, int bf)</td></tr>
<tr class="separator:a0817361a72b2f07f6515c740fb73ca56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c9300d3c3a40e4294573f3f299eb04"><td class="memItemLeft" align="right" valign="top"><a id="a96c9300d3c3a40e4294573f3f299eb04" name="a96c9300d3c3a40e4294573f3f299eb04"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>del_flag</b> (<a class="el" href="namespacecaf_1_1io_1_1network.html#a88e180a8a20a501a2b971ff0f8bd578b">operation</a> op, int bf)</td></tr>
<tr class="separator:a96c9300d3c3a40e4294573f3f299eb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee5391b0d2942f0082c50da0474b27f"><td class="memTemplParams" colspan="2"><a id="a0ee5391b0d2942f0082c50da0474b27f" name="a0ee5391b0d2942f0082c50da0474b27f"></a>
template&lt;int Family&gt; </td></tr>
<tr class="memitem:a0ee5391b0d2942f0082c50da0474b27f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ip_connect</b> (native_socket fd, const std::string &amp;host, uint16_t port)</td></tr>
<tr class="separator:a0ee5391b0d2942f0082c50da0474b27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abf3d8fceaff1e4988f7de14da5e2e0"><td class="memItemLeft" align="right" valign="top"><a id="a4abf3d8fceaff1e4988f7de14da5e2e0" name="a4abf3d8fceaff1e4988f7de14da5e2e0"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; native_socket &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>new_tcp_connection</b> (const std::string &amp;host, uint16_t port, std::optional&lt; <a class="el" href="structcaf_1_1io_1_1network_1_1protocol.html#a00405c7e34886bce1b4354d1caa3b6f6">protocol::network</a> &gt; preferred)</td></tr>
<tr class="separator:a4abf3d8fceaff1e4988f7de14da5e2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc6686fbc7739bac4d520fb3f238760"><td class="memTemplParams" colspan="2"><a id="afdc6686fbc7739bac4d520fb3f238760" name="afdc6686fbc7739bac4d520fb3f238760"></a>
template&lt;class SockAddrType &gt; </td></tr>
<tr class="memitem:afdc6686fbc7739bac4d520fb3f238760"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1expected.html">expected</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_port</b> (native_socket fd, SockAddrType &amp;sa)</td></tr>
<tr class="separator:afdc6686fbc7739bac4d520fb3f238760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdb1d2f1190222c02aa47dcf30042b3"><td class="memItemLeft" align="right" valign="top"><a id="a1bdb1d2f1190222c02aa47dcf30042b3" name="a1bdb1d2f1190222c02aa47dcf30042b3"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>set_inaddr_any</b> (native_socket, sockaddr_in &amp;sa)</td></tr>
<tr class="separator:a1bdb1d2f1190222c02aa47dcf30042b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bb63bb93775288eb2ca56506074769"><td class="memItemLeft" align="right" valign="top"><a id="a64bb63bb93775288eb2ca56506074769" name="a64bb63bb93775288eb2ca56506074769"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>set_inaddr_any</b> (native_socket fd, sockaddr_in6 &amp;sa)</td></tr>
<tr class="separator:a64bb63bb93775288eb2ca56506074769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b5c944d21ab4c3f95306d331303315"><td class="memTemplParams" colspan="2"><a id="a85b5c944d21ab4c3f95306d331303315" name="a85b5c944d21ab4c3f95306d331303315"></a>
template&lt;int Family, int SockType = SOCK_STREAM&gt; </td></tr>
<tr class="memitem:a85b5c944d21ab4c3f95306d331303315"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1expected.html">expected</a>&lt; native_socket &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>new_ip_acceptor_impl</b> (uint16_t port, const char *addr, bool reuse_addr, bool any)</td></tr>
<tr class="separator:a85b5c944d21ab4c3f95306d331303315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22552928cf8383601df2137947e336f9"><td class="memItemLeft" align="right" valign="top"><a id="a22552928cf8383601df2137947e336f9" name="a22552928cf8383601df2137947e336f9"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; native_socket &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>new_tcp_acceptor_impl</b> (uint16_t port, const char *addr, bool reuse_addr)</td></tr>
<tr class="separator:a22552928cf8383601df2137947e336f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e7091ae63427fa6dc058af4a575d50"><td class="memItemLeft" align="right" valign="top"><a id="ad4e7091ae63427fa6dc058af4a575d50" name="ad4e7091ae63427fa6dc058af4a575d50"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; std::pair&lt; native_socket, <a class="el" href="structcaf_1_1io_1_1network_1_1ip__endpoint.html">ip_endpoint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>new_remote_udp_endpoint_impl</b> (const std::string &amp;host, uint16_t port, std::optional&lt; <a class="el" href="structcaf_1_1io_1_1network_1_1protocol.html#a00405c7e34886bce1b4354d1caa3b6f6">protocol::network</a> &gt; preferred)</td></tr>
<tr class="separator:ad4e7091ae63427fa6dc058af4a575d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c242caa61eafb0bd9e7298671350a6"><td class="memItemLeft" align="right" valign="top"><a id="a62c242caa61eafb0bd9e7298671350a6" name="a62c242caa61eafb0bd9e7298671350a6"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; std::pair&lt; native_socket, <a class="el" href="structcaf_1_1io_1_1network_1_1protocol.html#a00405c7e34886bce1b4354d1caa3b6f6">protocol::network</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>new_local_udp_endpoint_impl</b> (uint16_t port, const char *addr, bool reuse, std::optional&lt; <a class="el" href="structcaf_1_1io_1_1network_1_1protocol.html#a00405c7e34886bce1b4354d1caa3b6f6">protocol::network</a> &gt; preferred)</td></tr>
<tr class="separator:a62c242caa61eafb0bd9e7298671350a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d4e0106f97219cce8b2a488e8d04c9"><td class="memItemLeft" align="right" valign="top"><a id="ab7d4e0106f97219cce8b2a488e8d04c9" name="ab7d4e0106f97219cce8b2a488e8d04c9"></a>
<a class="el" href="classcaf_1_1io_1_1connection__handle.html">connection_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>conn_hdl_from_socket</b> (native_socket fd)</td></tr>
<tr class="separator:ab7d4e0106f97219cce8b2a488e8d04c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd2d308fe982610337e1c467efa4c3b"><td class="memItemLeft" align="right" valign="top"><a id="afdd2d308fe982610337e1c467efa4c3b" name="afdd2d308fe982610337e1c467efa4c3b"></a>
<a class="el" href="classcaf_1_1io_1_1accept__handle.html">accept_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>accept_hdl_from_socket</b> (native_socket fd)</td></tr>
<tr class="separator:afdd2d308fe982610337e1c467efa4c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9afc2b3f4bd7d4fb572f99eb6f588c"><td class="memTemplParams" colspan="2"><a id="a5a9afc2b3f4bd7d4fb572f99eb6f588c" name="a5a9afc2b3f4bd7d4fb572f99eb6f588c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5a9afc2b3f4bd7d4fb572f99eb6f588c"><td class="memTemplItemLeft" align="right" valign="top">void *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vptr</b> (T *ptr)</td></tr>
<tr class="separator:a5a9afc2b3f4bd7d4fb572f99eb6f588c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918d74652109259edc029d9600df29b8"><td class="memItemLeft" align="right" valign="top"><a id="a918d74652109259edc029d9600df29b8" name="a918d74652109259edc029d9600df29b8"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>fetch_in_addr</b> (int family, sockaddr *addr)</td></tr>
<tr class="separator:a918d74652109259edc029d9600df29b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fff603dcb13f8f72ad116862b79fb7c"><td class="memItemLeft" align="right" valign="top"><a id="a3fff603dcb13f8f72ad116862b79fb7c" name="a3fff603dcb13f8f72ad116862b79fb7c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fetch_addr_str</b> (bool get_ipv4, bool get_ipv6, char(&amp;buf)[INET6_ADDRSTRLEN], sockaddr *addr)</td></tr>
<tr class="separator:a3fff603dcb13f8f72ad116862b79fb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6e5d6b543204b1791c5767c9c1bd99"><td class="memTemplParams" colspan="2"><a id="abf6e5d6b543204b1791c5767c9c1bd99" name="abf6e5d6b543204b1791c5767c9c1bd99"></a>
template&lt;class F &gt; </td></tr>
<tr class="memitem:abf6e5d6b543204b1791c5767c9c1bd99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_address</b> (bool get_ipv4, bool get_ipv6, F fun)</td></tr>
<tr class="separator:abf6e5d6b543204b1791c5767c9c1bd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea83602862054bb2b8e5ddde77b9fbe7"><td class="memItemLeft" align="right" valign="top"><a id="aea83602862054bb2b8e5ddde77b9fbe7" name="aea83602862054bb2b8e5ddde77b9fbe7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structcaf_1_1io_1_1network_1_1ip__endpoint.html">ip_endpoint</a> &amp;lhs, const <a class="el" href="structcaf_1_1io_1_1network_1_1ip__endpoint.html">ip_endpoint</a> &amp;rhs)</td></tr>
<tr class="separator:aea83602862054bb2b8e5ddde77b9fbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a69cde668c676fe64ac1d48b7c30bf5"><td class="memItemLeft" align="right" valign="top"><a id="a6a69cde668c676fe64ac1d48b7c30bf5" name="a6a69cde668c676fe64ac1d48b7c30bf5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="structcaf_1_1io_1_1network_1_1ip__endpoint.html">ip_endpoint</a> &amp;ep)</td></tr>
<tr class="separator:a6a69cde668c676fe64ac1d48b7c30bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9a3e415564d5f9c3b2d3daf1794390"><td class="memItemLeft" align="right" valign="top"><a id="aaa9a3e415564d5f9c3b2d3daf1794390" name="aaa9a3e415564d5f9c3b2d3daf1794390"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>host</b> (const <a class="el" href="structcaf_1_1io_1_1network_1_1ip__endpoint.html">ip_endpoint</a> &amp;ep)</td></tr>
<tr class="separator:aaa9a3e415564d5f9c3b2d3daf1794390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b9fef90cbaeaab9b098b3cdd8ae756"><td class="memItemLeft" align="right" valign="top"><a id="aa9b9fef90cbaeaab9b098b3cdd8ae756" name="aa9b9fef90cbaeaab9b098b3cdd8ae756"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>port</b> (const <a class="el" href="structcaf_1_1io_1_1network_1_1ip__endpoint.html">ip_endpoint</a> &amp;ep)</td></tr>
<tr class="separator:aa9b9fef90cbaeaab9b098b3cdd8ae756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de435bb0473ed1cf2bf8d3dfa691214"><td class="memItemLeft" align="right" valign="top"><a id="a3de435bb0473ed1cf2bf8d3dfa691214" name="a3de435bb0473ed1cf2bf8d3dfa691214"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>family</b> (const <a class="el" href="structcaf_1_1io_1_1network_1_1ip__endpoint.html">ip_endpoint</a> &amp;ep)</td></tr>
<tr class="separator:a3de435bb0473ed1cf2bf8d3dfa691214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f8c8518c2fe6205c5b77f0eb4e3a1e"><td class="memItemLeft" align="right" valign="top"><a id="a09f8c8518c2fe6205c5b77f0eb4e3a1e" name="a09f8c8518c2fe6205c5b77f0eb4e3a1e"></a>
<a class="el" href="classcaf_1_1error__code.html">error_code</a>&lt; <a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78">sec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>load_endpoint</b> (<a class="el" href="structcaf_1_1io_1_1network_1_1ip__endpoint.html">ip_endpoint</a> &amp;ep, uint32_t &amp;f, std::string &amp;h, uint16_t &amp;p, size_t &amp;l)</td></tr>
<tr class="separator:a09f8c8518c2fe6205c5b77f0eb4e3a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed005ef2a2bf4a942f3aa8233738b7c"><td class="memItemLeft" align="right" valign="top"><a id="a0ed005ef2a2bf4a942f3aa8233738b7c" name="a0ed005ef2a2bf4a942f3aa8233738b7c"></a>
<a class="el" href="classcaf_1_1error__code.html">error_code</a>&lt; <a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78">sec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>save_endpoint</b> (<a class="el" href="structcaf_1_1io_1_1network_1_1ip__endpoint.html">ip_endpoint</a> &amp;ep, uint32_t &amp;f, std::string &amp;h, uint16_t &amp;p, size_t &amp;l)</td></tr>
<tr class="separator:a0ed005ef2a2bf4a942f3aa8233738b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7c1e70c30bd69a5aaa8c3ee550fa87"><td class="memTemplParams" colspan="2"><a id="a5c7c1e70c30bd69a5aaa8c3ee550fa87" name="a5c7c1e70c30bd69a5aaa8c3ee550fa87"></a>
template&lt;class Inspector &gt; </td></tr>
<tr class="memitem:a5c7c1e70c30bd69a5aaa8c3ee550fa87"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inspect</b> (Inspector &amp;f, <a class="el" href="structcaf_1_1io_1_1network_1_1ip__endpoint.html">ip_endpoint</a> &amp;x)</td></tr>
<tr class="separator:a5c7c1e70c30bd69a5aaa8c3ee550fa87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ddc36fd7d2d7ef58707f7567758478"><td class="memItemLeft" align="right" valign="top"><a id="ad2ddc36fd7d2d7ef58707f7567758478" name="ad2ddc36fd7d2d7ef58707f7567758478"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>last_socket_error</b> ()</td></tr>
<tr class="memdesc:ad2ddc36fd7d2d7ef58707f7567758478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last socket error as an integer. <br /></td></tr>
<tr class="separator:ad2ddc36fd7d2d7ef58707f7567758478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f26cfec28efa6de436940504b958d6"><td class="memItemLeft" align="right" valign="top"><a id="a65f26cfec28efa6de436940504b958d6" name="a65f26cfec28efa6de436940504b958d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>close_socket</b> (native_socket fd)</td></tr>
<tr class="memdesc:a65f26cfec28efa6de436940504b958d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close socket <code>fd</code>. <br /></td></tr>
<tr class="separator:a65f26cfec28efa6de436940504b958d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7e0e7f911dc4c553ef14f299a9e874"><td class="memItemLeft" align="right" valign="top"><a id="aed7e0e7f911dc4c553ef14f299a9e874" name="aed7e0e7f911dc4c553ef14f299a9e874"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>would_block_or_temporarily_unavailable</b> (int errcode)</td></tr>
<tr class="memdesc:aed7e0e7f911dc4c553ef14f299a9e874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>errcode</code> indicates that an operation would block or return nothing at the moment and can be tried again at a later point. <br /></td></tr>
<tr class="separator:aed7e0e7f911dc4c553ef14f299a9e874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495db97d2a871af984f4a998a9878f83"><td class="memItemLeft" align="right" valign="top"><a id="a495db97d2a871af984f4a998a9878f83" name="a495db97d2a871af984f4a998a9878f83"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>last_socket_error_as_string</b> ()</td></tr>
<tr class="memdesc:a495db97d2a871af984f4a998a9878f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last socket error as human-readable string. <br /></td></tr>
<tr class="separator:a495db97d2a871af984f4a998a9878f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c5a475509527a3d725fbb7e08b40a3"><td class="memItemLeft" align="right" valign="top"><a id="ac9c5a475509527a3d725fbb7e08b40a3" name="ac9c5a475509527a3d725fbb7e08b40a3"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>socket_error_as_string</b> (int errcode)</td></tr>
<tr class="memdesc:ac9c5a475509527a3d725fbb7e08b40a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a human-readable string for a given socket error. <br /></td></tr>
<tr class="separator:ac9c5a475509527a3d725fbb7e08b40a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d823951e51ebfbb5deeb71afd34313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1expected.html">expected</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf_1_1io_1_1network.html#ac9d823951e51ebfbb5deeb71afd34313">child_process_inherit</a> (native_socket fd, bool new_value)</td></tr>
<tr class="memdesc:ac9d823951e51ebfbb5deeb71afd34313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets fd to be inherited by child processes if <code>new_value == true</code> or not if <code>new_value == false</code>.  <br /></td></tr>
<tr class="separator:ac9d823951e51ebfbb5deeb71afd34313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44c8853024fa83b56d622ed913aad4e"><td class="memItemLeft" align="right" valign="top"><a id="ab44c8853024fa83b56d622ed913aad4e" name="ab44c8853024fa83b56d622ed913aad4e"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keepalive</b> (native_socket fd, bool new_value)</td></tr>
<tr class="memdesc:ab44c8853024fa83b56d622ed913aad4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables keepalive on <code>fd</code>. Throws <code>network_error</code> on error. <br /></td></tr>
<tr class="separator:ab44c8853024fa83b56d622ed913aad4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8de48d596da88cc4c855dbc2f8491d"><td class="memItemLeft" align="right" valign="top"><a id="aad8de48d596da88cc4c855dbc2f8491d" name="aad8de48d596da88cc4c855dbc2f8491d"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nonblocking</b> (native_socket fd, bool new_value)</td></tr>
<tr class="memdesc:aad8de48d596da88cc4c855dbc2f8491d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets fd to nonblocking if <code>set_nonblocking == true</code> or to blocking if <code>set_nonblocking == false</code> throws <code>network_error</code> on error. <br /></td></tr>
<tr class="separator:aad8de48d596da88cc4c855dbc2f8491d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bb92c22122f1bdc32471e3487f288c"><td class="memItemLeft" align="right" valign="top"><a id="af2bb92c22122f1bdc32471e3487f288c" name="af2bb92c22122f1bdc32471e3487f288c"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>allow_sigpipe</b> (native_socket fd, bool new_value)</td></tr>
<tr class="memdesc:af2bb92c22122f1bdc32471e3487f288c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables <code>SIGPIPE</code> events from <code>fd</code>. <br /></td></tr>
<tr class="separator:af2bb92c22122f1bdc32471e3487f288c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cec0816e0538bda787ac10ccfdf5bc"><td class="memItemLeft" align="right" valign="top"><a id="a76cec0816e0538bda787ac10ccfdf5bc" name="a76cec0816e0538bda787ac10ccfdf5bc"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>allow_udp_connreset</b> (native_socket fd, bool new_value)</td></tr>
<tr class="memdesc:a76cec0816e0538bda787ac10ccfdf5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables <code>SIO_UDP_CONNRESET</code>error on <code>fd</code>. <br /></td></tr>
<tr class="separator:a76cec0816e0538bda787ac10ccfdf5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae565d839fde3304508a37eb9c3f49a35"><td class="memItemLeft" align="right" valign="top">std::pair&lt; native_socket, native_socket &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf_1_1io_1_1network.html#ae565d839fde3304508a37eb9c3f49a35">create_pipe</a> ()</td></tr>
<tr class="memdesc:ae565d839fde3304508a37eb9c3f49a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates two connected sockets.  <br /></td></tr>
<tr class="separator:ae565d839fde3304508a37eb9c3f49a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2398d112b87ef0780435b810dc8d01ba"><td class="memItemLeft" align="right" valign="top"><a id="a2398d112b87ef0780435b810dc8d01ba" name="a2398d112b87ef0780435b810dc8d01ba"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>send_buffer_size</b> (native_socket fd)</td></tr>
<tr class="memdesc:a2398d112b87ef0780435b810dc8d01ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the socket buffer size for <code>fd</code>. <br /></td></tr>
<tr class="separator:a2398d112b87ef0780435b810dc8d01ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2c93aab9d092e290e8549e3a8a2d19"><td class="memItemLeft" align="right" valign="top"><a id="a4a2c93aab9d092e290e8549e3a8a2d19" name="a4a2c93aab9d092e290e8549e3a8a2d19"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>send_buffer_size</b> (native_socket fd, int new_value)</td></tr>
<tr class="memdesc:a4a2c93aab9d092e290e8549e3a8a2d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the socket buffer size for <code>fd</code>. <br /></td></tr>
<tr class="separator:a4a2c93aab9d092e290e8549e3a8a2d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3c6a7d45c5d3b9d7f4c16629f74aac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1expected.html">expected</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf_1_1io_1_1network.html#a7a3c6a7d45c5d3b9d7f4c16629f74aac">tcp_nodelay</a> (native_socket fd, bool new_value)</td></tr>
<tr class="memdesc:a7a3c6a7d45c5d3b9d7f4c16629f74aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables Nagle's algorithm on <code>fd</code>.  <br /></td></tr>
<tr class="separator:a7a3c6a7d45c5d3b9d7f4c16629f74aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ca56779d800820cceb188c9f5d7b08"><td class="memItemLeft" align="right" valign="top"><a id="a77ca56779d800820cceb188c9f5d7b08" name="a77ca56779d800820cceb188c9f5d7b08"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_error</b> (signed_size_type res, bool is_nonblock)</td></tr>
<tr class="memdesc:a77ca56779d800820cceb188c9f5d7b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience functions for checking the result of <code>recv</code> or <code>send</code>. <br /></td></tr>
<tr class="separator:a77ca56779d800820cceb188c9f5d7b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fe48405e936b51c0fe26b49f9ad666"><td class="memItemLeft" align="right" valign="top"><a id="a85fe48405e936b51c0fe26b49f9ad666" name="a85fe48405e936b51c0fe26b49f9ad666"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>local_addr_of_fd</b> (native_socket fd)</td></tr>
<tr class="memdesc:a85fe48405e936b51c0fe26b49f9ad666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the locally assigned address of <code>fd</code>. <br /></td></tr>
<tr class="separator:a85fe48405e936b51c0fe26b49f9ad666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0826e01481604ed4fcf4f3f208dd5c"><td class="memItemLeft" align="right" valign="top"><a id="a6a0826e01481604ed4fcf4f3f208dd5c" name="a6a0826e01481604ed4fcf4f3f208dd5c"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; uint16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>local_port_of_fd</b> (native_socket fd)</td></tr>
<tr class="memdesc:a6a0826e01481604ed4fcf4f3f208dd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the locally assigned port of <code>fd</code>. <br /></td></tr>
<tr class="separator:a6a0826e01481604ed4fcf4f3f208dd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3c79bc78ee2fd8c1be1fbd051ed596"><td class="memItemLeft" align="right" valign="top"><a id="a0e3c79bc78ee2fd8c1be1fbd051ed596" name="a0e3c79bc78ee2fd8c1be1fbd051ed596"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>remote_addr_of_fd</b> (native_socket fd)</td></tr>
<tr class="memdesc:a0e3c79bc78ee2fd8c1be1fbd051ed596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the remote host address of <code>fd</code>. <br /></td></tr>
<tr class="separator:a0e3c79bc78ee2fd8c1be1fbd051ed596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1500cc34361fb6264c9d89fd3460a6a1"><td class="memItemLeft" align="right" valign="top"><a id="a1500cc34361fb6264c9d89fd3460a6a1" name="a1500cc34361fb6264c9d89fd3460a6a1"></a>
<a class="el" href="classcaf_1_1expected.html">expected</a>&lt; uint16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>remote_port_of_fd</b> (native_socket fd)</td></tr>
<tr class="memdesc:a1500cc34361fb6264c9d89fd3460a6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the port used by the remote host of <code>fd</code>. <br /></td></tr>
<tr class="separator:a1500cc34361fb6264c9d89fd3460a6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499dc4e57959a2a17de6a0b466b70525"><td class="memItemLeft" align="right" valign="top"><a id="a499dc4e57959a2a17de6a0b466b70525" name="a499dc4e57959a2a17de6a0b466b70525"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shutdown_read</b> (native_socket fd)</td></tr>
<tr class="memdesc:a499dc4e57959a2a17de6a0b466b70525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the read channel for a socket. <br /></td></tr>
<tr class="separator:a499dc4e57959a2a17de6a0b466b70525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3ec68a0f71210cb83eb3442a12b1f9"><td class="memItemLeft" align="right" valign="top"><a id="adf3ec68a0f71210cb83eb3442a12b1f9" name="adf3ec68a0f71210cb83eb3442a12b1f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shutdown_write</b> (native_socket fd)</td></tr>
<tr class="memdesc:adf3ec68a0f71210cb83eb3442a12b1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the write channel for a socket. <br /></td></tr>
<tr class="separator:adf3ec68a0f71210cb83eb3442a12b1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c269f1a869b2f17180612c224bd0a6c"><td class="memItemLeft" align="right" valign="top"><a id="a6c269f1a869b2f17180612c224bd0a6c" name="a6c269f1a869b2f17180612c224bd0a6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>shutdown_both</b> (native_socket fd)</td></tr>
<tr class="memdesc:a6c269f1a869b2f17180612c224bd0a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the both read and write channel for a socket. <br /></td></tr>
<tr class="separator:a6c269f1a869b2f17180612c224bd0a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8bde1116485254c5500d96e9b32bbb"><td class="memItemLeft" align="right" valign="top"><a id="a4a8bde1116485254c5500d96e9b32bbb" name="a4a8bde1116485254c5500d96e9b32bbb"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>int64_from_native_socket</b> (native_socket sock)</td></tr>
<tr class="separator:a4a8bde1116485254c5500d96e9b32bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043a08ed8a3418537d8d9a77f4e5e242"><td class="memItemLeft" align="right" valign="top"><a id="a043a08ed8a3418537d8d9a77f4e5e242" name="a043a08ed8a3418537d8d9a77f4e5e242"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="structcaf_1_1io_1_1network_1_1protocol.html">protocol</a> &amp;x)</td></tr>
<tr class="memdesc:a043a08ed8a3418537d8d9a77f4e5e242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a protocol into a transport/network string representation, e.g., "TCP/IPv4". <br /></td></tr>
<tr class="separator:a043a08ed8a3418537d8d9a77f4e5e242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f81610e047655a58c39e5f49bbbf601"><td class="memItemLeft" align="right" valign="top"><a id="a2f81610e047655a58c39e5f49bbbf601" name="a2f81610e047655a58c39e5f49bbbf601"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (<a class="el" href="structcaf_1_1io_1_1network_1_1protocol.html#a845406d46b0f9342e834a77587a5cc73">protocol::transport</a> x)</td></tr>
<tr class="separator:a2f81610e047655a58c39e5f49bbbf601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413d8609aa0dc97c83b611b00e36cf5a"><td class="memTemplParams" colspan="2"><a id="a413d8609aa0dc97c83b611b00e36cf5a" name="a413d8609aa0dc97c83b611b00e36cf5a"></a>
template&lt;class Inspector &gt; </td></tr>
<tr class="memitem:a413d8609aa0dc97c83b611b00e36cf5a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inspect</b> (Inspector &amp;f, <a class="el" href="structcaf_1_1io_1_1network_1_1protocol.html#a845406d46b0f9342e834a77587a5cc73">protocol::transport</a> &amp;x)</td></tr>
<tr class="separator:a413d8609aa0dc97c83b611b00e36cf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a5a3ae71c25b867472c314de240efe"><td class="memItemLeft" align="right" valign="top"><a id="a18a5a3ae71c25b867472c314de240efe" name="a18a5a3ae71c25b867472c314de240efe"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (<a class="el" href="structcaf_1_1io_1_1network_1_1protocol.html#a00405c7e34886bce1b4354d1caa3b6f6">protocol::network</a> x)</td></tr>
<tr class="separator:a18a5a3ae71c25b867472c314de240efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8835555e83f8626a371d545f1e378837"><td class="memTemplParams" colspan="2"><a id="a8835555e83f8626a371d545f1e378837" name="a8835555e83f8626a371d545f1e378837"></a>
template&lt;class Inspector &gt; </td></tr>
<tr class="memitem:a8835555e83f8626a371d545f1e378837"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inspect</b> (Inspector &amp;f, <a class="el" href="structcaf_1_1io_1_1network_1_1protocol.html#a00405c7e34886bce1b4354d1caa3b6f6">protocol::network</a> &amp;x)</td></tr>
<tr class="separator:a8835555e83f8626a371d545f1e378837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0d853ec7d70b1f4d1320fc1cbb2e22"><td class="memTemplParams" colspan="2"><a id="a6b0d853ec7d70b1f4d1320fc1cbb2e22" name="a6b0d853ec7d70b1f4d1320fc1cbb2e22"></a>
template&lt;class Inspector &gt; </td></tr>
<tr class="memitem:a6b0d853ec7d70b1f4d1320fc1cbb2e22"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inspect</b> (Inspector &amp;f, <a class="el" href="structcaf_1_1io_1_1network_1_1protocol.html">protocol</a> &amp;x)</td></tr>
<tr class="separator:a6b0d853ec7d70b1f4d1320fc1cbb2e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8684c85ce7cc93dd6120d0fc03f9bb7d"><td class="memItemLeft" align="right" valign="top"><a id="a8684c85ce7cc93dd6120d0fc03f9bb7d" name="a8684c85ce7cc93dd6120d0fc03f9bb7d"></a>
const event_mask_type&#160;</td><td class="memItemRight" valign="bottom"><b>input_mask</b> = EPOLLIN</td></tr>
<tr class="memdesc:a8684c85ce7cc93dd6120d0fc03f9bb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the bitmask for input (read) socket events. <br /></td></tr>
<tr class="separator:a8684c85ce7cc93dd6120d0fc03f9bb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ebfef262869bfadf0414a969e06472"><td class="memItemLeft" align="right" valign="top"><a id="a02ebfef262869bfadf0414a969e06472" name="a02ebfef262869bfadf0414a969e06472"></a>
const event_mask_type&#160;</td><td class="memItemRight" valign="bottom"><b>error_mask</b> = EPOLLRDHUP | EPOLLERR | EPOLLHUP</td></tr>
<tr class="memdesc:a02ebfef262869bfadf0414a969e06472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the bitmask for error socket events. <br /></td></tr>
<tr class="separator:a02ebfef262869bfadf0414a969e06472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe064ddda051787a88d2fa625aeaa9b"><td class="memItemLeft" align="right" valign="top"><a id="aafe064ddda051787a88d2fa625aeaa9b" name="aafe064ddda051787a88d2fa625aeaa9b"></a>
const event_mask_type&#160;</td><td class="memItemRight" valign="bottom"><b>output_mask</b> = EPOLLOUT</td></tr>
<tr class="memdesc:aafe064ddda051787a88d2fa625aeaa9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the bitmask for output (write) socket events. <br /></td></tr>
<tr class="separator:aafe064ddda051787a88d2fa625aeaa9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ddcba03e62200707bcbcf1c5718c9f1"><td class="memItemLeft" align="right" valign="top"><a id="a3ddcba03e62200707bcbcf1c5718c9f1" name="a3ddcba03e62200707bcbcf1c5718c9f1"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>ec_out_of_memory</b> = ENOMEM</td></tr>
<tr class="separator:a3ddcba03e62200707bcbcf1c5718c9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf658e1a21e1f970c8c534ce21fa3e0"><td class="memItemLeft" align="right" valign="top"><a id="a1cf658e1a21e1f970c8c534ce21fa3e0" name="a1cf658e1a21e1f970c8c534ce21fa3e0"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>ec_interrupted_syscall</b> = EINTR</td></tr>
<tr class="separator:a1cf658e1a21e1f970c8c534ce21fa3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9704d85734f0304862a2d2709f340a33"><td class="memItemLeft" align="right" valign="top"><a id="a9704d85734f0304862a2d2709f340a33" name="a9704d85734f0304862a2d2709f340a33"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>no_sigpipe_socket_flag</b> = 0</td></tr>
<tr class="separator:a9704d85734f0304862a2d2709f340a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2ee820543c41bc5e5193238039dbb3"><td class="memItemLeft" align="right" valign="top"><a id="aaf2ee820543c41bc5e5193238039dbb3" name="aaf2ee820543c41bc5e5193238039dbb3"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>no_sigpipe_io_flag</b> = MSG_NOSIGNAL</td></tr>
<tr class="separator:aaf2ee820543c41bc5e5193238039dbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab488cec29a59915c96e2c544962bfdac"><td class="memItemLeft" align="right" valign="top"><a id="ab488cec29a59915c96e2c544962bfdac" name="ab488cec29a59915c96e2c544962bfdac"></a>
constexpr native_socket&#160;</td><td class="memItemRight" valign="bottom"><b>invalid_native_socket</b> = -1</td></tr>
<tr class="separator:ab488cec29a59915c96e2c544962bfdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains classes and functions used for network abstraction. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="abb11678f0cd9b855baab1fd86aeeac15" name="abb11678f0cd9b855baab1fd86aeeac15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb11678f0cd9b855baab1fd86aeeac15">&#9670;&#160;</a></span>rw_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacecaf_1_1io_1_1network.html#abb11678f0cd9b855baab1fd86aeeac15">caf::io::network::rw_state</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Denotes the returned state of read and write operations on sockets. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abb11678f0cd9b855baab1fd86aeeac15a260ca9dd8a4577fc00b7bd5810298076" name="abb11678f0cd9b855baab1fd86aeeac15a260ca9dd8a4577fc00b7bd5810298076"></a>success&#160;</td><td class="fielddoc"><p>Reports that bytes could be read or written. </p>
</td></tr>
<tr><td class="fieldname"><a id="abb11678f0cd9b855baab1fd86aeeac15a3ee28fe1a60c95b89d29317f122c7021" name="abb11678f0cd9b855baab1fd86aeeac15a3ee28fe1a60c95b89d29317f122c7021"></a>failure&#160;</td><td class="fielddoc"><p>Reports that the socket is closed or faulty. </p>
</td></tr>
<tr><td class="fieldname"><a id="abb11678f0cd9b855baab1fd86aeeac15a44560d82707cce3b8111a770924cf0e2" name="abb11678f0cd9b855baab1fd86aeeac15a44560d82707cce3b8111a770924cf0e2"></a>indeterminate&#160;</td><td class="fielddoc"><p>Reports that an empty buffer is in use and no operation was performed. </p>
</td></tr>
<tr><td class="fieldname"><a id="abb11678f0cd9b855baab1fd86aeeac15aab2ab2a262e872718991cabbdee9ef8e" name="abb11678f0cd9b855baab1fd86aeeac15aab2ab2a262e872718991cabbdee9ef8e"></a>want_read&#160;</td><td class="fielddoc"><p>Reports that the transport wants to read data before it can write again. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac9d823951e51ebfbb5deeb71afd34313" name="ac9d823951e51ebfbb5deeb71afd34313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d823951e51ebfbb5deeb71afd34313">&#9670;&#160;</a></span>child_process_inherit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CAF_IO_EXPORT <a class="el" href="classcaf_1_1expected.html">expected</a>&lt; void &gt; caf::io::network::child_process_inherit </td>
          <td>(</td>
          <td class="paramtype">native_socket&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets fd to be inherited by child processes if <code>new_value == true</code> or not if <code>new_value == false</code>. </p>
<p>Not implemented on Windows. throws <code>network_error</code> on error </p>

</div>
</div>
<a id="ae565d839fde3304508a37eb9c3f49a35" name="ae565d839fde3304508a37eb9c3f49a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae565d839fde3304508a37eb9c3f49a35">&#9670;&#160;</a></span>create_pipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CAF_IO_EXPORT std::pair&lt; native_socket, native_socket &gt; caf::io::network::create_pipe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates two connected sockets. </p>
<p>The former is the read handle and the latter is the write handle. </p>

</div>
</div>
<a id="a7a3c6a7d45c5d3b9d7f4c16629f74aac" name="a7a3c6a7d45c5d3b9d7f4c16629f74aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3c6a7d45c5d3b9d7f4c16629f74aac">&#9670;&#160;</a></span>tcp_nodelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CAF_IO_EXPORT <a class="el" href="classcaf_1_1expected.html">expected</a>&lt; void &gt; caf::io::network::tcp_nodelay </td>
          <td>(</td>
          <td class="paramtype">native_socket&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables Nagle's algorithm on <code>fd</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">network_error</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
