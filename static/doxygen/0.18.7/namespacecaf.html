<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ Actor Framework: caf Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C++ Actor Framework<span id="projectnumber">&#160;0.18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">caf Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Root namespace of libcaf.  
<a href="namespacecaf.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecaf_1_1exit__reason"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf_1_1exit__reason.html">exit_reason</a></td></tr>
<tr class="memdesc:namespacecaf_1_1exit__reason"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all predefined exit reasons. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecaf_1_1io"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf_1_1io.html">io</a></td></tr>
<tr class="memdesc:namespacecaf_1_1io"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all IO-related classes and functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecaf_1_1mixin"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf_1_1mixin.html">mixin</a></td></tr>
<tr class="memdesc:namespacecaf_1_1mixin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains mixin classes implementing several actor traits. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecaf_1_1policy"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf_1_1policy.html">policy</a></td></tr>
<tr class="memdesc:namespacecaf_1_1policy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains policies encapsulating characteristics or algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1abstract__actor.html">abstract_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all actor implementations.  <a href="classcaf_1_1abstract__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1abstract__channel.html">abstract_channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for all message receivers.  <a href="classcaf_1_1abstract__channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1abstract__group.html">abstract_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multicast group.  <a href="classcaf_1_1abstract__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1action.html">action</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functional interface similar to <code>std::function&lt;void()&gt;</code> with dispose semantics.  <a href="classcaf_1_1action.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor.html">actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies an untyped actor.  <a href="classcaf_1_1actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__addr.html">actor_addr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the address of typed as well as untyped actors.  <a href="classcaf_1_1actor__addr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__clock.html">actor_clock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A monotonic clock for scheduling timeouts and delayed messages.  <a href="classcaf_1_1actor__clock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__companion.html">actor_companion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An co-existing actor forwarding all messages through a user-defined callback to another object, thus serving as gateway to allow any object to interact with other actors.  <a href="classcaf_1_1actor__companion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__config.html">actor_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores spawn-time flags and groups.  <a href="classcaf_1_1actor__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__control__block.html">actor_control_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actors are always allocated with a control block that stores its identity as well as strong and weak reference counts to it.  <a href="classcaf_1_1actor__control__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__ostream.html">actor_ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides support for thread-safe output operations on character streams.  <a href="classcaf_1_1actor__ostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__pool.html">actor_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An actor poool is a lightweight abstraction for a set of workers.  <a href="classcaf_1_1actor__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__profiler.html">actor_profiler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A profiler which provides a set of callbacks for several actor operations in order to collect fine-grained profiling state about the system.  <a href="classcaf_1_1actor__profiler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__proxy.html">actor_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an actor running on a remote machine, or different hardware, or in a separate process.  <a href="classcaf_1_1actor__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__registry.html">actor_registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A registry is used to associate actors to IDs or names.  <a href="classcaf_1_1actor__registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__system.html">actor_system</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actor environment including scheduler, registry, and optional components such as a middleman.  <a href="classcaf_1_1actor__system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1actor__system__config.html">actor_system_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures an <code><a class="el" href="classcaf_1_1actor__system.html" title="Actor environment including scheduler, registry, and optional components such as a middleman.">actor_system</a></code> on startup.  <a href="classcaf_1_1actor__system__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1actor__traits.html">actor_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides uniform access to properties of actor types.  <a href="structcaf_1_1actor__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1allowed__unsafe__message__type.html">allowed_unsafe_message_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specializations can whitelist individual types for unsafe message passing operations.  <a href="structcaf_1_1allowed__unsafe__message__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1attachable.html">attachable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback utility class.  <a href="classcaf_1_1attachable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1behavior.html">behavior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the behavior of an actor, i.e., provides a message handler and an optional timeout.  <a href="classcaf_1_1behavior.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1binary__deserializer.html">binary_deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes C++ objects from sequence of bytes.  <a href="classcaf_1_1binary__deserializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1binary__serializer.html">binary_serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes C++ objects into a sequence of bytes.  <a href="classcaf_1_1binary__serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1blocking__actor.html">blocking_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread-mapped or context-switching actor using a blocking receive rather than a behavior-stack based message processing.  <a href="classcaf_1_1blocking__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1blocking__actor__base.html">blocking_actor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker type for blocking actors.  <a href="structcaf_1_1blocking__actor__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1buffered__downstream__manager.html">buffered_downstream_manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin for streams with any number of downstreams.  <a href="classcaf_1_1buffered__downstream__manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1byte__address.html">byte_address</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for addresses based on a byte representation such as IP or Ethernet addresses.  <a href="classcaf_1_1byte__address.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1callback.html">callback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a simple callback, usually implemented via lambda expression.  <a href="classcaf_1_1callback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1callback__impl.html">callback_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for wrapping a function object of type <code>F</code>.  <a href="classcaf_1_1callback__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1composed__type.html">composed_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the type for f*g (actor composition).  <a href="structcaf_1_1composed__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1config__option.html">config_option</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a configuration option for the application.  <a href="classcaf_1_1config__option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1config__option__adder.html">config_option_adder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds config options of the same category to a <code><a class="el" href="classcaf_1_1config__option__set.html" title="A set of config_option objects that parses CLI arguments into a settings object.">config_option_set</a></code>.  <a href="classcaf_1_1config__option__adder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1config__option__set.html">config_option_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of <code><a class="el" href="classcaf_1_1config__option.html" title="Defines a configuration option for the application.">config_option</a></code> objects that parses CLI arguments into a <code>settings</code> object.  <a href="classcaf_1_1config__option__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1config__value.html">config_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for config parameters with similar interface to a <code>variant</code>.  <a href="classcaf_1_1config__value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1config__value__reader.html">config_value_reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts objects from a <a class="el" href="classcaf_1_1config__value.html">config_value</a>.  <a href="classcaf_1_1config__value__reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1config__value__writer.html">config_value_writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an objects into a <a class="el" href="classcaf_1_1config__value.html">config_value</a>.  <a href="classcaf_1_1config__value__writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1cow__tuple.html">cow_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A copy-on-write tuple implementation.  <a href="classcaf_1_1cow__tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1credit__controller.html">credit_controller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes credit for an attached source.  <a href="classcaf_1_1credit__controller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1deep__to__string__t.html">deep_to_string_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps <code>deep_to_string</code> into a function object.  <a href="structcaf_1_1deep__to__string__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1default__actor__traits.html">default_actor_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of <code><a class="el" href="structcaf_1_1actor__traits.html" title="Provides uniform access to properties of actor types.">actor_traits</a></code> for non-actors (SFINAE-friendly).  <a href="structcaf_1_1default__actor__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1default__actor__traits_3_01_t_00_01true_01_4.html">default_actor_traits&lt; T, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of <code><a class="el" href="structcaf_1_1actor__traits.html" title="Provides uniform access to properties of actor types.">actor_traits</a></code> for regular actors.  <a href="structcaf_1_1default__actor__traits_3_01_t_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1default__downstream__manager.html">default_downstream_manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects a downstream manager implementation based on the signature of various handlers.  <a href="structcaf_1_1default__downstream__manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1default__sum__type__access.html">default_sum_type_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows specializing the <code><a class="el" href="structcaf_1_1sum__type__access.html" title="Specializing this trait allows users to enable holds_alternative, get, get_if, and visit for any user...">sum_type_access</a></code> trait for any type that simply wraps a <code>variant</code> and exposes it with a <code>get_data()</code> member function.  <a href="structcaf_1_1default__sum__type__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1delegated.html">delegated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to indicate that a request has been forwarded.  <a href="classcaf_1_1delegated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1deserializer.html">deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Technology-independent deserialization interface.  <a href="classcaf_1_1deserializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1dictionary.html">dictionary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps strings to values of type <code>V</code>, but unlike <code>std::map&lt;std::string, V&gt;</code> accepts <code><a class="el" href="classcaf_1_1string__view.html" title="Drop-in replacement for C++17 std::string_view.">string_view</a></code> for looking up keys efficiently.  <a href="classcaf_1_1dictionary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1disposable.html">disposable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a disposable resource.  <a href="classcaf_1_1disposable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1down__msg.html">down_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sent to all actors monitoring an actor when it is terminated.  <a href="structcaf_1_1down__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1downstream.html">downstream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grants access to an output stream buffer.  <a href="classcaf_1_1downstream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1downstream__manager.html">downstream_manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages downstream communication for a <code><a class="el" href="classcaf_1_1stream__manager.html" title="Manages a single stream with any number of in- and outbound paths.">stream_manager</a></code>.  <a href="classcaf_1_1downstream__manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1downstream__manager__base.html">downstream_manager_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default downstream manager base stores outbound paths in an unordered map.  <a href="classcaf_1_1downstream__manager__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1downstream__msg.html">downstream_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream messages that travel downstream, i.e., batches and close messages.  <a href="structcaf_1_1downstream__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1downstream__msg__batch.html">downstream_msg_batch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits stream data.  <a href="structcaf_1_1downstream__msg__batch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1downstream__msg__close.html">downstream_msg_close</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orderly shuts down a stream after receiving an ACK for the last batch.  <a href="structcaf_1_1downstream__msg__close.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1downstream__msg__forced__close.html">downstream_msg_forced_close</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates a fatal error from sources to sinks.  <a href="structcaf_1_1downstream__msg__forced__close.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1dynamically__typed__actor__base.html">dynamically_typed_actor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker type for dynamically typed actors.  <a href="structcaf_1_1dynamically__typed__actor__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1error.html">error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A serializable type for storing error codes with category and optional, human-readable context information.  <a href="classcaf_1_1error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1error__code.html">error_code</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight wrapper around an error code enum.  <a href="classcaf_1_1error__code.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1event__based__actor.html">event_based_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cooperatively scheduled, event-based actor implementation.  <a href="classcaf_1_1event__based__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1event__based__mtl.html">event_based_mtl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables event-based actors to generate messages from a user-defined data exchange format such as JSON and to send the generated messages to another (typed) actor.  <a href="classcaf_1_1event__based__mtl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1execution__unit.html">execution_unit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies an execution unit, e.g., a worker thread of the scheduler.  <a href="classcaf_1_1execution__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1exit__msg.html">exit_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sent to all links when an actor is terminated.  <a href="structcaf_1_1exit__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1expected.html">expected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the result of a computation which can either complete successfully with an instance of type <code>T</code> or fail with an <code>error</code>.  <a href="classcaf_1_1expected.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1expected_3_01void_01_4.html">expected&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pattern <code>expected&lt;void&gt;</code> shall be used for functions that may generate an error but would otherwise return <code>bool</code>.  <a href="classcaf_1_1expected_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1extend.html">extend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows convenient definition of types using mixins.  <a href="structcaf_1_1extend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1forwarding__actor__proxy.html">forwarding_actor_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a simple proxy forwarding all operations to a manager.  <a href="classcaf_1_1forwarding__actor__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1function__view.html">function_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function view for an actor hides any messaging from the caller.  <a href="classcaf_1_1function__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1fused__downstream__manager.html">fused_downstream_manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A downstream manager that delegates to any number of sub-managers.  <a href="classcaf_1_1fused__downstream__manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1get__or__auto__deduce.html">get_or_auto_deduce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures get_or to uses the <a class="el" href="structcaf_1_1get__or__deduction__guide.html">get_or_deduction_guide</a>.  <a href="structcaf_1_1get__or__auto__deduce.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1get__or__deduction__guide.html">get_or_deduction_guide</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customization point for configuring automatic mappings from default value types to deduced types.  <a href="structcaf_1_1get__or__deduction__guide.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1group__down__msg.html">group_down_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sent to all members of a group when it goes offline.  <a href="structcaf_1_1group__down__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1group__module.html">group_module</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for user-defined multicast implementations.  <a href="classcaf_1_1group__module.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1handle.html">handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for IO handles such as <code>accept_handle</code> or <code>connection_handle</code>.  <a href="classcaf_1_1handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1has__sum__type__access.html">has_sum_type_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates to <code>true</code> if <code>T</code> specializes <code><a class="el" href="structcaf_1_1sum__type__access.html" title="Specializing this trait allows users to enable holds_alternative, get, get_if, and visit for any user...">sum_type_access</a></code>.  <a href="structcaf_1_1has__sum__type__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1illegal__message__element.html">illegal_message_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker class identifying classes in CAF that are not allowed to be used as message element.  <a href="structcaf_1_1illegal__message__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1inbound__path.html">inbound_path</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for a path to an upstream actor (source).  <a href="classcaf_1_1inbound__path.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1inbound__stream__slot.html">inbound_stream_slot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a stream slot ID for inbound paths with the full type information of the path creation.  <a href="classcaf_1_1inbound__stream__slot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1infer__handle__from__class.html">infer_handle_from_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces <code>actor</code> for dynamically typed actors, otherwise <code><a class="el" href="classcaf_1_1typed__actor.html" title="Identifies a statically typed actor.">typed_actor</a>&lt;...&gt;</code> is deduced.  <a href="structcaf_1_1infer__handle__from__class.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1infer__handle__from__fun.html">infer_handle_from_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces an actor handle type from a function or function object.  <a href="structcaf_1_1infer__handle__from__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1inspector__access.html">inspector_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customization point for adding support for a custom type.  <a href="structcaf_1_1inspector__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1inspector__access__base.html">inspector_access_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides default implementations for <code>save_field</code> and <code>load_field</code>.  <a href="structcaf_1_1inspector__access__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1inspector__access__type.html">inspector_access_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps tag types for static dispatching.  <a href="structcaf_1_1inspector__access__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1intrusive__cow__ptr.html">intrusive_cow_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An intrusive, reference counting smart pointer implementation with copy-on-write optimization.  <a href="classcaf_1_1intrusive__cow__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An intrusive, reference counting smart pointer implementation.  <a href="classcaf_1_1intrusive__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1ipv4__endpoint.html">ipv4_endpoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An IP endpoint that contains an ::ipv4_address and a port.  <a href="classcaf_1_1ipv4__endpoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1ipv6__endpoint.html">ipv6_endpoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An IP endpoint that contains an ::ipv6_address and a port.  <a href="classcaf_1_1ipv6__endpoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1is__actor__handle.html">is_actor_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>T</code> is an <code>actor</code> or a <code><a class="el" href="classcaf_1_1typed__actor.html" title="Identifies a statically typed actor.">typed_actor</a>&lt;...&gt;</code>.  <a href="structcaf_1_1is__actor__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1is__error__code__enum.html">is_error_code_enum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customization point for enabling conversion from an enum type to an <a class="el" href="classcaf_1_1error.html">error</a> or <a class="el" href="classcaf_1_1error__code.html">error_code</a>.  <a href="structcaf_1_1is__error__code__enum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1is__typed__actor.html">is_typed_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates to true if <code>T</code> is a <code><a class="el" href="classcaf_1_1typed__actor.html" title="Identifies a statically typed actor.">typed_actor</a>&lt;...&gt;</code>.  <a href="structcaf_1_1is__typed__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1json__reader.html">json_reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes an inspectable object from a JSON-formatted string.  <a href="classcaf_1_1json__reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1json__writer.html">json_writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an inspectable object to a JSON-formatted string.  <a href="classcaf_1_1json__writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1load__inspector.html">load_inspector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for inspectors that load objects from some input source.  <a href="classcaf_1_1load__inspector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1local__actor.html">local_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for actors running on this node, either living in an own thread or cooperatively scheduled.  <a href="classcaf_1_1local__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1logger.html">logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centrally logs events from all actors in an actor system.  <a href="classcaf_1_1logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1make__sink__result.html">make_sink_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stream sink with the slot ID of its first inbound path.  <a href="classcaf_1_1make__sink__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1make__source__result.html">make_source_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stream source with the slot ID of its first outbound path.  <a href="classcaf_1_1make__source__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1make__stage__result.html">make_stage_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stream stage with the slot IDs of its first in- and outbound paths.  <a href="classcaf_1_1make__stage__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1message.html">message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a fixed-length, copy-on-write, type-erased tuple with elements of any type.  <a href="classcaf_1_1message.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1message__builder.html">message_builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a convenient interface for creating <code>message</code> objects from a series of values using the member function <code>append</code>.  <a href="classcaf_1_1message__builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1message__handler.html">message_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial function implementation used to process a <code>message</code>.  <a href="classcaf_1_1message__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1message__id.html">message_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles various flags along with an optional request ID.  <a href="classcaf_1_1message__id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1monitorable__actor.html">monitorable_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all actor implementations.  <a href="classcaf_1_1monitorable__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1no__stages__t.html">no_stages_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience tag type for producing empty forwarding stacks.  <a href="structcaf_1_1no__stages__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1node__down__msg.html">node_down_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sent to all actors monitoring a node when CAF loses connection to it.  <a href="structcaf_1_1node__down__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1node__id.html">node_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node ID is an opaque value for representing CAF instances in the network.  <a href="classcaf_1_1node__id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1non__blocking__actor__base.html">non_blocking_actor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker type for non-blocking actors.  <a href="structcaf_1_1non__blocking__actor__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1none__t.html">none_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents "nothing", e.g., for clearing an <code>optional</code> by assigning <code>none</code>.  <a href="structcaf_1_1none__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1open__stream__msg.html">open_stream_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Demands the receiver to open a new stream from the sender to the receiver.  <a href="structcaf_1_1open__stream__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++17 compatible <code>optional</code> implementation.  <a href="classcaf_1_1optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1optional_3_01_t_01_6_01_4.html">optional&lt; T &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization to allow <code>optional</code> to hold a reference rather than an actual value with minimal overhead.  <a href="classcaf_1_1optional_3_01_t_01_6_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1optional__inspector__access.html">optional_inspector_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides inspector access for types that represent optional values.  <a href="structcaf_1_1optional__inspector__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1outbound__path.html">outbound_path</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for a single path to a sink of a <code><a class="el" href="classcaf_1_1downstream__manager.html" title="Manages downstream communication for a stream_manager.">downstream_manager</a></code>.  <a href="classcaf_1_1outbound__path.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1outbound__stream__slot.html">outbound_stream_slot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a stream slot ID for outbound paths with the full type information of the path creation.  <a href="classcaf_1_1outbound__stream__slot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1parser__state.html">parser_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores all information necessary for implementing an FSM-based parser.  <a href="structcaf_1_1parser__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1partial__behavior__init__t.html">partial_behavior_init_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type for constructing a <code>typed_behavior</code> with an incomplete list of message handlers, delegating to the default handler for all unmatched inputs.  <a href="structcaf_1_1partial__behavior__init__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1proxy__registry.html">proxy_registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups a (distributed) set of actors and allows actors in the same namespace to exchange messages.  <a href="classcaf_1_1proxy__registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1ref__counted.html">ref_counted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for reference counted objects with an atomic reference count.  <a href="classcaf_1_1ref__counted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1response__handle.html">response_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper class identifies an expected response message and enables <code>request(...).then(...)</code>.  <a href="classcaf_1_1response__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1response__promise.html">response_promise</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables actors to delay a response message by capturing the context of a request message.  <a href="classcaf_1_1response__promise.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1response__type.html">response_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines:  <a href="structcaf_1_1response__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1response__type__unbox.html">response_type_unbox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unboxes <code>Xs</code> and calls <code><a class="el" href="structcaf_1_1response__type.html" title="Defines:">response_type</a></code>.  <a href="structcaf_1_1response__type__unbox.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1result.html">result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the result of a message handler to represent either a value (wrapped into a <code>message</code>), a <code>delegated&lt;Ts...&gt;</code> (indicates that another actor is going to respond), or an <code>error</code>.  <a href="classcaf_1_1result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1result__base.html">result_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for all specializations of <code>result</code>.  <a href="classcaf_1_1result__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1resumable.html">resumable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cooperatively executed task managed by one or more instances of <code><a class="el" href="classcaf_1_1execution__unit.html" title="Identifies an execution unit, e.g., a worker thread of the scheduler.">execution_unit</a></code>.  <a href="classcaf_1_1resumable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1save__inspector.html">save_inspector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for inspectors that save objects to some output sink.  <a href="classcaf_1_1save__inspector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1scoped__actor.html">scoped_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scoped handle to a blocking actor.  <a href="classcaf_1_1scoped__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1scoped__execution__unit.html">scoped_execution_unit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies an execution unit, e.g., a worker thread of the scheduler.  <a href="classcaf_1_1scoped__execution__unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1serializer.html">serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Technology-independent serialization interface.  <a href="classcaf_1_1serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1skip__t.html">skip_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler function that leaves messages in the mailbox.  <a href="classcaf_1_1skip__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++11/14 drop-in replacement for C++20's <code>std::span</code> without support for static extents.  <a href="classcaf_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1stateful__actor.html">stateful_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event-based actor with managed state.  <a href="classcaf_1_1stateful__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1statically__typed__actor__base.html">statically_typed_actor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker type for statically typed actors.  <a href="structcaf_1_1statically__typed__actor__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1stream.html">stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty marker type for streaming handshakes.  <a href="classcaf_1_1stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1stream__finalize__trait.html">stream_finalize_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches a finalize call to a function taking either one or two arguments.  <a href="structcaf_1_1stream__finalize__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1stream__finalize__trait_3_01_fun_00_01_state_00_01false_01_4.html">stream_finalize_trait&lt; Fun, State, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the trait for callbacks that only take the state.  <a href="structcaf_1_1stream__finalize__trait_3_01_fun_00_01_state_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1stream__finalize__trait_3_01_fun_00_01_state_00_01true_01_4.html">stream_finalize_trait&lt; Fun, State, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the trait for callbacks that take state and error.  <a href="structcaf_1_1stream__finalize__trait_3_01_fun_00_01_state_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1stream__manager.html">stream_manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages a single stream with any number of in- and outbound paths.  <a href="classcaf_1_1stream__manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1stream__sink__driver.html">stream_sink_driver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies an unbound sequence of messages.  <a href="classcaf_1_1stream__sink__driver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1stream__sink__trait.html">stream_sink_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines required type aliases for stream sinks.  <a href="structcaf_1_1stream__sink__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1stream__sink__trait_3_01void_07_state_01_6_00_01const_01std_1_1vector_3_01_in_01_4_01_6_08_4.html">stream_sink_trait&lt; void(State &amp;, const std::vector&lt; In &gt; &amp;)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the trait for batch-wise processing with const references.  <a href="structcaf_1_1stream__sink__trait_3_01void_07_state_01_6_00_01const_01std_1_1vector_3_01_in_01_4_01_6_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1stream__sink__trait_3_01void_07_state_01_6_00_01_in_08_4.html">stream_sink_trait&lt; void(State &amp;, In)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the trait for element-wise processing.  <a href="structcaf_1_1stream__sink__trait_3_01void_07_state_01_6_00_01_in_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1stream__sink__trait_3_01void_07_state_01_6_00_01std_1_1vector_3_01_in_01_4_01_6_08_4.html">stream_sink_trait&lt; void(State &amp;, std::vector&lt; In &gt; &amp;)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the trait for batch-wise processing.  <a href="structcaf_1_1stream__sink__trait_3_01void_07_state_01_6_00_01std_1_1vector_3_01_in_01_4_01_6_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1stream__sink__trait__base.html">stream_sink_trait_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for all sink traits.  <a href="structcaf_1_1stream__sink__trait__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1stream__slots.html">stream_slots</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps two <code>stream_slot</code> values into a pair for storing sender and receiver slot information.  <a href="structcaf_1_1stream__slots.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1stream__source__driver.html">stream_source_driver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies an unbound sequence of messages.  <a href="classcaf_1_1stream__source__driver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1stream__source__trait.html">stream_source_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the output type and the state type for a stream source from its <code>pull</code> implementation.  <a href="structcaf_1_1stream__source__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1stream__stage__driver.html">stream_stage_driver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates user-provided functionality for generating a stream stage.  <a href="classcaf_1_1stream__stage__driver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1stream__stage__trait_3_01void_07_state_01_6_00_01downstream_3_01_out_01_4_01_6_00_01_in_08_4.html">stream_stage_trait&lt; void(State &amp;, downstream&lt; Out &gt; &amp;, In)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the input type, output type and the state type for a stream stage from its <code>process</code> implementation.  <a href="structcaf_1_1stream__stage__trait_3_01void_07_state_01_6_00_01downstream_3_01_out_01_4_01_6_00_01_in_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1string__view.html">string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop-in replacement for C++17 std::string_view.  <a href="classcaf_1_1string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1sum__type__access.html">sum_type_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializing this trait allows users to enable <code>holds_alternative</code>, <code>get</code>, <code>get_if</code>, and <code>visit</code> for any user-defined sum type.  <a href="structcaf_1_1sum__type__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1sum__type__access_3_01variant_3_01_ts_8_8_8_01_4_01_4.html">sum_type_access&lt; variant&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable <code>holds_alternative</code>, <code>get</code>, <code>get_if</code>, and <code>visit</code> for <code>variant</code>.  <a href="structcaf_1_1sum__type__access_3_01variant_3_01_ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1thread__hook.html">thread_hook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to define thread hooks.  <a href="classcaf_1_1thread__hook.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1tracing__data.html">tracing_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker interface for application-specific tracing data.  <a href="classcaf_1_1tracing__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1tracing__data__factory.html">tracing_data_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates instances of <a class="el" href="classcaf_1_1tracing__data.html">tracing_data</a>.  <a href="classcaf_1_1tracing__data__factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1type__by__id.html">type_by_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the globally unique ID <code>V</code> to a type (inverse to ::type_id).  <a href="structcaf_1_1type__by__id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1type__erased__value.html">type_erased_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single type-erased value.  <a href="classcaf_1_1type__erased__value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1type__id.html">type_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the type <code>T</code> to a globally unique ID.  <a href="structcaf_1_1type__id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1type__id__list.html">type_id_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of type IDs, stored in a size-prefix, contiguous memory block.  <a href="classcaf_1_1type__id__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1type__name.html">type_name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type that resolves to <code><a class="el" href="structcaf_1_1type__name__by__id.html" title="Maps the globally unique ID V to a type name.">type_name_by_id</a>&lt;type_id_v&lt;T&gt;&gt;</code>.  <a href="structcaf_1_1type__name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1type__name_3_01void_01_4.html">type_name&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience specialization that enables generic code to not treat <code>void</code> manually.  <a href="structcaf_1_1type__name_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1type__name__by__id.html">type_name_by_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the globally unique ID <code>V</code> to a type name.  <a href="structcaf_1_1type__name__by__id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1typed__actor.html">typed_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a statically typed actor.  <a href="classcaf_1_1typed__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1typed__actor__view.html">typed_actor_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorates a pointer to a scheduled_actor with a statically typed actor interface.  <a href="classcaf_1_1typed__actor__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1typed__actor__view__base.html">typed_actor_view_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type for <a class="el" href="classcaf_1_1typed__actor__view.html">typed_actor_view</a>.  <a href="structcaf_1_1typed__actor__view__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1typed__event__based__actor.html">typed_event_based_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cooperatively scheduled, event-based actor implementation with static type-checking.  <a href="classcaf_1_1typed__event__based__actor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1typed__response__promise.html">typed_response_promise</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables statically typed actors to delay a response message by capturing the context of a request message.  <a href="classcaf_1_1typed__response__promise.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1unit__t.html">unit_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit is analogous to <code>void</code>, but can be safely returned, stored, etc.  <a href="structcaf_1_1unit__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1unsafe__behavior__init__t.html">unsafe_behavior_init_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty struct tag for constructing a typed behavior from an untyped behavior.  <a href="structcaf_1_1unsafe__behavior__init__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1upstream__msg.html">upstream_msg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream messages that flow upstream, i.e., acks and drop messages.  <a href="structcaf_1_1upstream__msg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1upstream__msg__ack__batch.html">upstream_msg_ack_batch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulatively acknowledges received batches and signalizes new demand from a sink to its source.  <a href="structcaf_1_1upstream__msg__ack__batch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1upstream__msg__ack__open.html">upstream_msg_ack_open</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledges a previous <code>open</code> message and finalizes a stream handshake.  <a href="structcaf_1_1upstream__msg__ack__open.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1upstream__msg__drop.html">upstream_msg_drop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asks the source to discard any remaining credit and close this path after receiving an ACK for the last batch.  <a href="structcaf_1_1upstream__msg__drop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1upstream__msg__forced__drop.html">upstream_msg_forced_drop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates a fatal error from sinks to sources.  <a href="structcaf_1_1upstream__msg__forced__drop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1uri.html">uri</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A URI according to RFC 3986.  <a href="classcaf_1_1uri.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1uuid.html">uuid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A universally unique identifier according to <a href="https://tools.ietf.org/html/rfc4122">RFC 4122</a>.  <a href="classcaf_1_1uuid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1variant.html">variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant represents always a valid value of one of the types <code>Ts...</code>.  <a href="classcaf_1_1variant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An intrusive, reference counting smart pointer implementation.  <a href="classcaf_1_1weak__intrusive__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9add2953366cb2a234c979d41379c6e1"><td class="memItemLeft" align="right" valign="top"><a id="a9add2953366cb2a234c979d41379c6e1" name="a9add2953366cb2a234c979d41379c6e1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>actor_factory_result</b> = std::pair&lt; <a class="el" href="classcaf_1_1intrusive__ptr.html">strong_actor_ptr</a>, std::set&lt; std::string &gt; &gt;</td></tr>
<tr class="separator:a9add2953366cb2a234c979d41379c6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0700510e48adc1ce1953a29744c707"><td class="memItemLeft" align="right" valign="top"><a id="a1c0700510e48adc1ce1953a29744c707" name="a1c0700510e48adc1ce1953a29744c707"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>actor_factory</b> = std::function&lt; actor_factory_result(<a class="el" href="classcaf_1_1actor__config.html">actor_config</a> &amp;, <a class="el" href="classcaf_1_1message.html">message</a> &amp;)&gt;</td></tr>
<tr class="separator:a1c0700510e48adc1ce1953a29744c707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880e6eb5ec13b73573377a9ffafc4a2d"><td class="memItemLeft" align="right" valign="top"><a id="a880e6eb5ec13b73573377a9ffafc4a2d" name="a880e6eb5ec13b73573377a9ffafc4a2d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>selfptr_mode_token</b> = spawn_mode_token&lt; spawn_mode::function_with_selfptr &gt;</td></tr>
<tr class="separator:a880e6eb5ec13b73573377a9ffafc4a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335ae8ff31b1a85012e512f65b330703"><td class="memItemLeft" align="right" valign="top"><a id="a335ae8ff31b1a85012e512f65b330703" name="a335ae8ff31b1a85012e512f65b330703"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>void_mode_token</b> = spawn_mode_token&lt; spawn_mode::function &gt;</td></tr>
<tr class="separator:a335ae8ff31b1a85012e512f65b330703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dc25a9c6e1d5860fb5c07fb594dc93"><td class="memItemLeft" align="right" valign="top"><a id="af0dc25a9c6e1d5860fb5c07fb594dc93" name="af0dc25a9c6e1d5860fb5c07fb594dc93"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>byte_buffer</b> = std::vector&lt; <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> &gt;</td></tr>
<tr class="memdesc:af0dc25a9c6e1d5860fb5c07fb594dc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer for storing binary data. <br /></td></tr>
<tr class="separator:af0dc25a9c6e1d5860fb5c07fb594dc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9369f3584b7717d50e0eceeb6d2e454d"><td class="memItemLeft" align="right" valign="top"><a id="a9369f3584b7717d50e0eceeb6d2e454d" name="a9369f3584b7717d50e0eceeb6d2e454d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>byte_span</b> = <a class="el" href="classcaf_1_1span.html">span</a>&lt; <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> &gt;</td></tr>
<tr class="memdesc:a9369f3584b7717d50e0eceeb6d2e454d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for referring to a writable sequence of bytes. <br /></td></tr>
<tr class="separator:a9369f3584b7717d50e0eceeb6d2e454d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4003c4e72d51057d0daa9cb04b56a0"><td class="memItemLeft" align="right" valign="top"><a id="a6a4003c4e72d51057d0daa9cb04b56a0" name="a6a4003c4e72d51057d0daa9cb04b56a0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_byte_span</b> = <a class="el" href="classcaf_1_1span.html">span</a>&lt; const <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> &gt;</td></tr>
<tr class="memdesc:a6a4003c4e72d51057d0daa9cb04b56a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for referring to a read-only sequence of bytes. <br /></td></tr>
<tr class="separator:a6a4003c4e72d51057d0daa9cb04b56a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e72689fa673a7bd77f5936f281e6ec"><td class="memTemplParams" colspan="2"><a id="aa0e72689fa673a7bd77f5936f281e6ec" name="aa0e72689fa673a7bd77f5936f281e6ec"></a>
template&lt;class Signature &gt; </td></tr>
<tr class="memitem:aa0e72689fa673a7bd77f5936f281e6ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unique_callback_ptr</b> = std::unique_ptr&lt; <a class="el" href="classcaf_1_1callback.html">callback</a>&lt; Signature &gt; &gt;</td></tr>
<tr class="memdesc:aa0e72689fa673a7bd77f5936f281e6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer type for heap-allocated callbacks with unique ownership. <br /></td></tr>
<tr class="separator:aa0e72689fa673a7bd77f5936f281e6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0b8d208f947bc6834ee6ee723312b2"><td class="memTemplParams" colspan="2"><a id="a0d0b8d208f947bc6834ee6ee723312b2" name="a0d0b8d208f947bc6834ee6ee723312b2"></a>
template&lt;class Signature &gt; </td></tr>
<tr class="memitem:a0d0b8d208f947bc6834ee6ee723312b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shared_callback_ptr</b> = std::shared_ptr&lt; <a class="el" href="classcaf_1_1callback.html">callback</a>&lt; Signature &gt; &gt;</td></tr>
<tr class="memdesc:a0d0b8d208f947bc6834ee6ee723312b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer type for heap-allocated callbacks with shared ownership. <br /></td></tr>
<tr class="separator:a0d0b8d208f947bc6834ee6ee723312b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33db7897492cbad8fb07095f15bf3fdb"><td class="memTemplParams" colspan="2"><a id="a33db7897492cbad8fb07095f15bf3fdb" name="a33db7897492cbad8fb07095f15bf3fdb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a33db7897492cbad8fb07095f15bf3fdb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>signatures_of_t</b> = typename signatures_of&lt; T &gt;::type</td></tr>
<tr class="separator:a33db7897492cbad8fb07095f15bf3fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9c4fbee59d5d10b359bd7d827d3017"><td class="memTemplParams" colspan="2"><a id="a5e9c4fbee59d5d10b359bd7d827d3017" name="a5e9c4fbee59d5d10b359bd7d827d3017"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5e9c4fbee59d5d10b359bd7d827d3017"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deduce_mpi_t</b> = typename detail::dmfou&lt; std::decay_t&lt; T &gt; &gt;::type</td></tr>
<tr class="memdesc:a5e9c4fbee59d5d10b359bd7d827d3017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the message passing interface from a function object. <br /></td></tr>
<tr class="separator:a5e9c4fbee59d5d10b359bd7d827d3017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312d520b770789a32e82ce9f40581b1b"><td class="memTemplParams" colspan="2"><a id="a312d520b770789a32e82ce9f40581b1b" name="a312d520b770789a32e82ce9f40581b1b"></a>
template&lt;class F &gt; </td></tr>
<tr class="memitem:a312d520b770789a32e82ce9f40581b1b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>default_downstream_manager_t</b> = typename <a class="el" href="structcaf_1_1default__downstream__manager.html">default_downstream_manager</a>&lt; F &gt;::type</td></tr>
<tr class="separator:a312d520b770789a32e82ce9f40581b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2c833c0b5b896f8cd01e6e4dba43d3"><td class="memTemplParams" colspan="2"><a id="a9c2c833c0b5b896f8cd01e6e4dba43d3" name="a9c2c833c0b5b896f8cd01e6e4dba43d3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9c2c833c0b5b896f8cd01e6e4dba43d3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>function_view_flattened_result_t</b> = typename function_view_flattened_result&lt; T &gt;::type</td></tr>
<tr class="separator:a9c2c833c0b5b896f8cd01e6e4dba43d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfc0646244405efe1e00b692b1bf1fb"><td class="memItemLeft" align="right" valign="top"><a id="aecfc0646244405efe1e00b692b1bf1fb" name="aecfc0646244405efe1e00b692b1bf1fb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>actor_id</b> = uint64_t</td></tr>
<tr class="separator:aecfc0646244405efe1e00b692b1bf1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac434099e3afa8964f7e708b548454fa4"><td class="memItemLeft" align="right" valign="top"><a id="ac434099e3afa8964f7e708b548454fa4" name="ac434099e3afa8964f7e708b548454fa4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ip_address</b> = ipv6_address</td></tr>
<tr class="memdesc:ac434099e3afa8964f7e708b548454fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An IP address. The address family is IPv6 unless <code>embeds_v4</code> returns true. <br /></td></tr>
<tr class="separator:ac434099e3afa8964f7e708b548454fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d30e821ec069a062921d59db2d30802"><td class="memItemLeft" align="right" valign="top"><a id="a1d30e821ec069a062921d59db2d30802" name="a1d30e821ec069a062921d59db2d30802"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ip_endpoint</b> = <a class="el" href="classcaf_1_1ipv6__endpoint.html">ipv6_endpoint</a></td></tr>
<tr class="memdesc:a1d30e821ec069a062921d59db2d30802"><td class="mdescLeft">&#160;</td><td class="mdescRight">An IP endpoint that contains an ::ipv6_address and a port. <br /></td></tr>
<tr class="separator:a1d30e821ec069a062921d59db2d30802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867900a9604021e6344cc21c9a55537a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a867900a9604021e6344cc21c9a55537a">ip_subnet</a> = ipv6_subnet</td></tr>
<tr class="memdesc:a867900a9604021e6344cc21c9a55537a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An IP subnetwork.  <br /></td></tr>
<tr class="separator:a867900a9604021e6344cc21c9a55537a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebf9c3830808512488037e4086a8478"><td class="memItemLeft" align="right" valign="top"><a id="a7ebf9c3830808512488037e4086a8478" name="a7ebf9c3830808512488037e4086a8478"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>settings</b> = <a class="el" href="classcaf_1_1dictionary.html">dictionary</a>&lt; <a class="el" href="classcaf_1_1config__value.html">config_value</a> &gt;</td></tr>
<tr class="separator:a7ebf9c3830808512488037e4086a8478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e0cced47d5897105d78fcfe47ff5f4"><td class="memItemLeft" align="right" valign="top"><a id="af5e0cced47d5897105d78fcfe47ff5f4" name="af5e0cced47d5897105d78fcfe47ff5f4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>skippable_result</b> = <a class="el" href="classcaf_1_1variant.html">variant</a>&lt; <a class="el" href="classcaf_1_1delegated.html">delegated</a>&lt; <a class="el" href="classcaf_1_1message.html">message</a> &gt;, <a class="el" href="classcaf_1_1message.html">message</a>, <a class="el" href="classcaf_1_1error.html">error</a>, <a class="el" href="classcaf_1_1skip__t.html">skip_t</a> &gt;</td></tr>
<tr class="memdesc:af5e0cced47d5897105d78fcfe47ff5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>result&lt;message&gt;</code>, but also allows to <em>skip</em> a message. <br /></td></tr>
<tr class="separator:af5e0cced47d5897105d78fcfe47ff5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4e3f547c07339f44ef90acdd11a1fe"><td class="memItemLeft" align="right" valign="top"><a id="a5e4e3f547c07339f44ef90acdd11a1fe" name="a5e4e3f547c07339f44ef90acdd11a1fe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>stream_slot</b> = uint16_t</td></tr>
<tr class="memdesc:a5e4e3f547c07339f44ef90acdd11a1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a single stream path in the same way a TCP port identifies a connection over IP. <br /></td></tr>
<tr class="separator:a5e4e3f547c07339f44ef90acdd11a1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44855080188b6693187137bd666c7eb4"><td class="memItemLeft" align="right" valign="top"><a id="a44855080188b6693187137bd666c7eb4" name="a44855080188b6693187137bd666c7eb4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>type_id_t</b> = uint16_t</td></tr>
<tr class="memdesc:a44855080188b6693187137bd666c7eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal representation of a type ID. <br /></td></tr>
<tr class="separator:a44855080188b6693187137bd666c7eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4bce5fcdd7e9dc27c088ab3412a56d"><td class="memItemLeft" align="right" valign="top"><a id="a5e4bce5fcdd7e9dc27c088ab3412a56d" name="a5e4bce5fcdd7e9dc27c088ab3412a56d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>weak_actor_ptr</b> = <a class="el" href="classcaf_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a>&lt; <a class="el" href="classcaf_1_1actor__control__block.html">actor_control_block</a> &gt;</td></tr>
<tr class="separator:a5e4bce5fcdd7e9dc27c088ab3412a56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fccf23d1166fda380435ebb0ee73ce"><td class="memItemLeft" align="right" valign="top"><a id="a90fccf23d1166fda380435ebb0ee73ce" name="a90fccf23d1166fda380435ebb0ee73ce"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>group_module_ptr</b> = <a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcaf_1_1group__module.html">group_module</a> &gt;</td></tr>
<tr class="separator:a90fccf23d1166fda380435ebb0ee73ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdf96c3e929629a00e085fcf7a889a3"><td class="memItemLeft" align="right" valign="top"><a id="a6fdf96c3e929629a00e085fcf7a889a3" name="a6fdf96c3e929629a00e085fcf7a889a3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>stream_manager_ptr</b> = <a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcaf_1_1stream__manager.html">stream_manager</a> &gt;</td></tr>
<tr class="separator:a6fdf96c3e929629a00e085fcf7a889a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef28904ba302b6463bd06c258d02ee91"><td class="memItemLeft" align="right" valign="top"><a id="aef28904ba302b6463bd06c258d02ee91" name="aef28904ba302b6463bd06c258d02ee91"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>strong_actor_ptr</b> = <a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcaf_1_1actor__control__block.html">actor_control_block</a> &gt;</td></tr>
<tr class="separator:aef28904ba302b6463bd06c258d02ee91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b78adc9cd5bb549552fabc9734eefec"><td class="memItemLeft" align="right" valign="top"><a id="a0b78adc9cd5bb549552fabc9734eefec" name="a0b78adc9cd5bb549552fabc9734eefec"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mailbox_element_ptr</b> = std::unique_ptr&lt; mailbox_element &gt;</td></tr>
<tr class="separator:a0b78adc9cd5bb549552fabc9734eefec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b1a7c0a029312984f1ce50d7582fb8"><td class="memItemLeft" align="right" valign="top"><a id="a85b1a7c0a029312984f1ce50d7582fb8" name="a85b1a7c0a029312984f1ce50d7582fb8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>tracing_data_ptr</b> = std::unique_ptr&lt; <a class="el" href="classcaf_1_1tracing__data.html">tracing_data</a> &gt;</td></tr>
<tr class="separator:a85b1a7c0a029312984f1ce50d7582fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005a5eb479c17d4e20787b3b6d05a6b2"><td class="memTemplParams" colspan="2"><a id="a005a5eb479c17d4e20787b3b6d05a6b2" name="a005a5eb479c17d4e20787b3b6d05a6b2"></a>
template&lt;spawn_mode X&gt; </td></tr>
<tr class="memitem:a005a5eb479c17d4e20787b3b6d05a6b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spawn_mode_token</b> = std::integral_constant&lt; spawn_mode, X &gt;</td></tr>
<tr class="separator:a005a5eb479c17d4e20787b3b6d05a6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da1769b99ebcb3e6774c0640f20e1ad"><td class="memTemplParams" colspan="2">template&lt;class Found , class Expected &gt; </td></tr>
<tr class="memitem:a8da1769b99ebcb3e6774c0640f20e1ad"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a8da1769b99ebcb3e6774c0640f20e1ad">interface_mismatch_t</a> = detail::imi&lt; 0, Found, Expected, <a class="el" href="structcaf_1_1detail_1_1type__list.html">detail::type_list</a>&lt;&gt; &gt;</td></tr>
<tr class="memdesc:a8da1769b99ebcb3e6774c0640f20e1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans two typed MPI lists for compatibility, returning the index of the first mismatch.  <br /></td></tr>
<tr class="separator:a8da1769b99ebcb3e6774c0640f20e1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4b2c9c7f5ed5081d423fc5b1d51a51"><td class="memTemplParams" colspan="2"><a id="aec4b2c9c7f5ed5081d423fc5b1d51a51" name="aec4b2c9c7f5ed5081d423fc5b1d51a51"></a>
template&lt;class Lockable &gt; </td></tr>
<tr class="memitem:aec4b2c9c7f5ed5081d423fc5b1d51a51"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unique_lock</b> = std::unique_lock&lt; Lockable &gt;</td></tr>
<tr class="separator:aec4b2c9c7f5ed5081d423fc5b1d51a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfffd87163ddb43a655a337922d3882b"><td class="memTemplParams" colspan="2"><a id="abfffd87163ddb43a655a337922d3882b" name="abfffd87163ddb43a655a337922d3882b"></a>
template&lt;class SharedLockable &gt; </td></tr>
<tr class="memitem:abfffd87163ddb43a655a337922d3882b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upgrade_lock</b> = shared_lock&lt; SharedLockable &gt;</td></tr>
<tr class="separator:abfffd87163ddb43a655a337922d3882b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f35acd9e6d9f1214f1fee72993632b"><td class="memTemplParams" colspan="2">template&lt;class In , class DownstreamManager , class... Ts&gt; </td></tr>
<tr class="memitem:ac4f35acd9e6d9f1214f1fee72993632b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#ac4f35acd9e6d9f1214f1fee72993632b">make_stage_result_t</a> = <a class="el" href="classcaf_1_1make__stage__result.html">make_stage_result</a>&lt; In, DownstreamManager, detail::strip_and_convert_t&lt; Ts &gt;... &gt;</td></tr>
<tr class="memdesc:ac4f35acd9e6d9f1214f1fee72993632b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type for defining a <code><a class="el" href="classcaf_1_1make__stage__result.html" title="Returns a stream stage with the slot IDs of its first in- and outbound paths.">make_stage_result</a></code> from a downstream manager plus additional handshake types.  <br /></td></tr>
<tr class="separator:ac4f35acd9e6d9f1214f1fee72993632b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9939986f14ed7cd72bc085280df6f804"><td class="memItemLeft" align="right" valign="top"><a id="a9939986f14ed7cd72bc085280df6f804" name="a9939986f14ed7cd72bc085280df6f804"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>high_message_priority_constant</b> = std::integral_constant&lt; message_priority, message_priority::high &gt;</td></tr>
<tr class="separator:a9939986f14ed7cd72bc085280df6f804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1530fea19f0a6fc726a1553f411ce6b"><td class="memItemLeft" align="right" valign="top"><a id="ab1530fea19f0a6fc726a1553f411ce6b" name="ab1530fea19f0a6fc726a1553f411ce6b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>normal_message_priority_constant</b> = std::integral_constant&lt; message_priority, message_priority::normal &gt;</td></tr>
<tr class="separator:ab1530fea19f0a6fc726a1553f411ce6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4d5782a75cb8dfc23feccd0b7fbee5"><td class="memItemLeft" align="right" valign="top"><a id="a3a4d5782a75cb8dfc23feccd0b7fbee5" name="a3a4d5782a75cb8dfc23feccd0b7fbee5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>string_parser_state</b> = <a class="el" href="structcaf_1_1parser__state.html">parser_state</a>&lt; string_view::iterator &gt;</td></tr>
<tr class="memdesc:a3a4d5782a75cb8dfc23feccd0b7fbee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for parsers operating on string views. <br /></td></tr>
<tr class="separator:a3a4d5782a75cb8dfc23feccd0b7fbee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55eca9282e774d270bd95b5ea6cf127"><td class="memTemplParams" colspan="2"><a id="ac55eca9282e774d270bd95b5ea6cf127" name="ac55eca9282e774d270bd95b5ea6cf127"></a>
template&lt;class... Is&gt; </td></tr>
<tr class="memitem:ac55eca9282e774d270bd95b5ea6cf127"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reacts_to</b> = <a class="el" href="classcaf_1_1result.html">result</a>&lt; void &gt;(Is...)</td></tr>
<tr class="separator:ac55eca9282e774d270bd95b5ea6cf127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4939a4a81c84dd62f09f6016a522b897"><td class="memTemplParams" colspan="2"><a id="a4939a4a81c84dd62f09f6016a522b897" name="a4939a4a81c84dd62f09f6016a522b897"></a>
template&lt;class Fs , class... In&gt; </td></tr>
<tr class="memitem:a4939a4a81c84dd62f09f6016a522b897"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>response_type_t</b> = typename <a class="el" href="structcaf_1_1response__type.html">response_type</a>&lt; Fs, In... &gt;::type</td></tr>
<tr class="memdesc:a4939a4a81c84dd62f09f6016a522b897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the response message type for input <code>In...</code> from the list of message passing interfaces <code>Fs</code>. <br /></td></tr>
<tr class="separator:a4939a4a81c84dd62f09f6016a522b897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab914a397e191efb63bdd377f0d785f"><td class="memTemplParams" colspan="2"><a id="adab914a397e191efb63bdd377f0d785f" name="adab914a397e191efb63bdd377f0d785f"></a>
template&lt;class Fs , class... In&gt; </td></tr>
<tr class="memitem:adab914a397e191efb63bdd377f0d785f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>delegated_response_type_t</b> = typename <a class="el" href="structcaf_1_1response__type.html">response_type</a>&lt; Fs, In... &gt;::delegated_type</td></tr>
<tr class="memdesc:adab914a397e191efb63bdd377f0d785f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the response message type for input <code>In...</code> from the list of message passing interfaces <code>Fs</code> and returns the corresponding <code>delegated&lt;T&gt;</code>. <br /></td></tr>
<tr class="separator:adab914a397e191efb63bdd377f0d785f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea2b34a95e4708d8ad4d5e7180b3bd7"><td class="memTemplParams" colspan="2"><a id="afea2b34a95e4708d8ad4d5e7180b3bd7" name="afea2b34a95e4708d8ad4d5e7180b3bd7"></a>
template&lt;class Ts , class Xs &gt; </td></tr>
<tr class="memitem:afea2b34a95e4708d8ad4d5e7180b3bd7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>response_type_unbox_t</b> = typename <a class="el" href="structcaf_1_1response__type__unbox.html">response_type_unbox</a>&lt; Ts, Xs &gt;::type</td></tr>
<tr class="memdesc:afea2b34a95e4708d8ad4d5e7180b3bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the response message for input <code>Xs</code> from the list of message passing interfaces <code>Ts</code>. <br /></td></tr>
<tr class="separator:afea2b34a95e4708d8ad4d5e7180b3bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e98b4467c061246c5cd8a6a201e20a"><td class="memTemplParams" colspan="2"><a id="a90e98b4467c061246c5cd8a6a201e20a" name="a90e98b4467c061246c5cd8a6a201e20a"></a>
template&lt;class In &gt; </td></tr>
<tr class="memitem:a90e98b4467c061246c5cd8a6a201e20a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stream_sink_ptr</b> = <a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; stream_sink&lt; In &gt; &gt;</td></tr>
<tr class="separator:a90e98b4467c061246c5cd8a6a201e20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6301e1aa028fd8db2e064662858c05b8"><td class="memTemplParams" colspan="2"><a id="a6301e1aa028fd8db2e064662858c05b8" name="a6301e1aa028fd8db2e064662858c05b8"></a>
template&lt;class Fun &gt; </td></tr>
<tr class="memitem:a6301e1aa028fd8db2e064662858c05b8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stream_sink_trait_t</b> = <a class="el" href="structcaf_1_1stream__sink__trait.html">stream_sink_trait</a>&lt; typename <a class="el" href="structcaf_1_1detail_1_1get__callable__trait.html">detail::get_callable_trait</a>&lt; Fun &gt;::fun_sig &gt;</td></tr>
<tr class="memdesc:a6301e1aa028fd8db2e064662858c05b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derives a sink trait from the signatures of Fun and Fin. <br /></td></tr>
<tr class="separator:a6301e1aa028fd8db2e064662858c05b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f420749e83685f34ca2d1b5f45dd43"><td class="memTemplParams" colspan="2"><a id="a61f420749e83685f34ca2d1b5f45dd43" name="a61f420749e83685f34ca2d1b5f45dd43"></a>
template&lt;class DownstreamManager &gt; </td></tr>
<tr class="memitem:a61f420749e83685f34ca2d1b5f45dd43"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stream_source_ptr</b> = <a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; stream_source&lt; DownstreamManager &gt; &gt;</td></tr>
<tr class="separator:a61f420749e83685f34ca2d1b5f45dd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f53be6b1cd2f445da91d3c7150560ff"><td class="memTemplParams" colspan="2"><a id="a0f53be6b1cd2f445da91d3c7150560ff" name="a0f53be6b1cd2f445da91d3c7150560ff"></a>
template&lt;class Pull &gt; </td></tr>
<tr class="memitem:a0f53be6b1cd2f445da91d3c7150560ff"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stream_source_trait_t</b> = <a class="el" href="structcaf_1_1stream__source__trait.html">stream_source_trait</a>&lt; typename <a class="el" href="structcaf_1_1detail_1_1get__callable__trait.html">detail::get_callable_trait</a>&lt; Pull &gt;::fun_sig &gt;</td></tr>
<tr class="memdesc:a0f53be6b1cd2f445da91d3c7150560ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for extracting the function signature from <code>Pull</code> and passing it to <code><a class="el" href="structcaf_1_1stream__source__trait.html" title="Deduces the output type and the state type for a stream source from its pull implementation.">stream_source_trait</a></code>. <br /></td></tr>
<tr class="separator:a0f53be6b1cd2f445da91d3c7150560ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e70887507b15ec2695843dd3f926826"><td class="memTemplParams" colspan="2"><a id="a3e70887507b15ec2695843dd3f926826" name="a3e70887507b15ec2695843dd3f926826"></a>
template&lt;class In , class DownstreamManager &gt; </td></tr>
<tr class="memitem:a3e70887507b15ec2695843dd3f926826"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stream_stage_ptr</b> = <a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; stream_stage&lt; In, DownstreamManager &gt; &gt;</td></tr>
<tr class="separator:a3e70887507b15ec2695843dd3f926826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030c5751fea749679bce362e95feda5d"><td class="memTemplParams" colspan="2"><a id="a030c5751fea749679bce362e95feda5d" name="a030c5751fea749679bce362e95feda5d"></a>
template&lt;class Process &gt; </td></tr>
<tr class="memitem:a030c5751fea749679bce362e95feda5d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stream_stage_trait_t</b> = stream_stage_trait&lt; typename <a class="el" href="structcaf_1_1detail_1_1get__callable__trait.html">detail::get_callable_trait</a>&lt; Process &gt;::fun_sig &gt;</td></tr>
<tr class="memdesc:a030c5751fea749679bce362e95feda5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for extracting the function signature from <code>Process</code> and passing it to <code>stream_stage_trait</code>. <br /></td></tr>
<tr class="separator:a030c5751fea749679bce362e95feda5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7222141e7a9ee8c0622b1fdb4fa3d9f"><td class="memTemplParams" colspan="2">
template&lt;class F , class... Ts&gt; </td></tr>
<tr class="memitem:gaa7222141e7a9ee8c0622b1fdb4fa3d9f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sum_type_visit_result_t</b> = typename sum_type_visit_result&lt; detail::decay_t&lt; F &gt;, detail::decay_t&lt; Ts &gt;... &gt;::type</td></tr>
<tr class="separator:gaa7222141e7a9ee8c0622b1fdb4fa3d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82de112c4e3da12a222baf34e507ff3e"><td class="memItemLeft" align="right" valign="top"><a id="a82de112c4e3da12a222baf34e507ff3e" name="a82de112c4e3da12a222baf34e507ff3e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>generic_timeout_definition</b> = timeout_definition&lt; std::function&lt; void()&gt; &gt;</td></tr>
<tr class="separator:a82de112c4e3da12a222baf34e507ff3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3db7177cb06bf8d5bfd2df387729d4"><td class="memItemLeft" align="right" valign="top"><a id="adc3db7177cb06bf8d5bfd2df387729d4" name="adc3db7177cb06bf8d5bfd2df387729d4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>timespan</b> = std::chrono::duration&lt; int64_t, std::nano &gt;</td></tr>
<tr class="memdesc:adc3db7177cb06bf8d5bfd2df387729d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A portable timespan type with nanosecond resolution. <br /></td></tr>
<tr class="separator:adc3db7177cb06bf8d5bfd2df387729d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04add1a401710dc6f24029aab294b9b7"><td class="memItemLeft" align="right" valign="top"><a id="a04add1a401710dc6f24029aab294b9b7" name="a04add1a401710dc6f24029aab294b9b7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>timestamp</b> = std::chrono::time_point&lt; std::chrono::system_clock, <a class="el" href="namespacecaf.html#adc3db7177cb06bf8d5bfd2df387729d4">timespan</a> &gt;</td></tr>
<tr class="memdesc:a04add1a401710dc6f24029aab294b9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A portable timestamp with nanosecond resolution anchored at the UNIX epoch. <br /></td></tr>
<tr class="separator:a04add1a401710dc6f24029aab294b9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add97ed574b02b71ae16ceba630d52d36"><td class="memTemplParams" colspan="2"><a id="add97ed574b02b71ae16ceba630d52d36" name="add97ed574b02b71ae16ceba630d52d36"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:add97ed574b02b71ae16ceba630d52d36"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_variant_t</b> = typename is_variant&lt; Ts... &gt;::type</td></tr>
<tr class="separator:add97ed574b02b71ae16ceba630d52d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e8c417f59140c8a3939fe66cc859bc"><td class="memTemplParams" colspan="2"><a id="a90e8c417f59140c8a3939fe66cc859bc" name="a90e8c417f59140c8a3939fe66cc859bc"></a>
template&lt;class F , class... Ts&gt; </td></tr>
<tr class="memitem:a90e8c417f59140c8a3939fe66cc859bc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>variant_visit_result_t</b> = typename variant_visit_result&lt; detail::decay_t&lt; F &gt;, detail::decay_t&lt; Ts &gt;... &gt;::type</td></tr>
<tr class="separator:a90e8c417f59140c8a3939fe66cc859bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6dba2c3f22c13a600261c9122becd7dd"><td class="memItemLeft" align="right" valign="top"><a id="a6dba2c3f22c13a600261c9122becd7dd" name="a6dba2c3f22c13a600261c9122becd7dd"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> : uint8_t </td></tr>
<tr class="memdesc:a6dba2c3f22c13a600261c9122becd7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++11/14 drop-in replacement for C++17's <code>std::byte</code>. <br /></td></tr>
<tr class="separator:a6dba2c3f22c13a600261c9122becd7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ed789d5a799ff8eab4697604ae5784"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a72ed789d5a799ff8eab4697604ae5784">exit_reason</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a72ed789d5a799ff8eab4697604ae5784afea087517c26fadd409bd4b9dc642555">normal</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a72ed789d5a799ff8eab4697604ae5784aad921d60486366258809553a3db49a4a">unknown</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a72ed789d5a799ff8eab4697604ae5784a30b691fbbd96cde0f7637f48823509af">out_of_workers</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a72ed789d5a799ff8eab4697604ae5784aa0ea9b704b284e4ea1d35df90b587e2b">user_shutdown</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a72ed789d5a799ff8eab4697604ae5784a534735884d341071762ede7af01c53e8">kill</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a72ed789d5a799ff8eab4697604ae5784a43a121b7034424d4b02495c1a9e2ba34">remote_link_unreachable</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a72ed789d5a799ff8eab4697604ae5784ab748f56cf76526f8606d7463b9df9f2e">unreachable</a>
<br />
 }</td></tr>
<tr class="memdesc:a72ed789d5a799ff8eab4697604ae5784"><td class="mdescLeft">&#160;</td><td class="mdescRight">This error category represents fail conditions for actors.  <a href="namespacecaf.html#a72ed789d5a799ff8eab4697604ae5784">More...</a><br /></td></tr>
<tr class="separator:a72ed789d5a799ff8eab4697604ae5784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332c7e471996af6ae3f3507361e780fe"><td class="memItemLeft" align="right" valign="top"><a id="a332c7e471996af6ae3f3507361e780fe" name="a332c7e471996af6ae3f3507361e780fe"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>spawn_mode</b> { <br />
&#160;&#160;<b>function</b>
, <br />
&#160;&#160;<b>function_with_selfptr</b>
, <br />
&#160;&#160;<b>clazz</b>
<br />
 }</td></tr>
<tr class="separator:a332c7e471996af6ae3f3507361e780fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d701f7629091f4f89f273ab9bb44a20"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a2d701f7629091f4f89f273ab9bb44a20">invoke_message_result</a> { <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a2d701f7629091f4f89f273ab9bb44a20a48fe8558ce14c4c865198444c538ecc5">consumed</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a2d701f7629091f4f89f273ab9bb44a20ae52e279299e912838f689d4380c81f4a">skipped</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a2d701f7629091f4f89f273ab9bb44a20a41d368a58ee26891a6a586ddaaa604f8">dropped</a>
<br />
 }</td></tr>
<tr class="memdesc:a2d701f7629091f4f89f273ab9bb44a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the result of a message invocation.  <a href="namespacecaf.html#a2d701f7629091f4f89f273ab9bb44a20">More...</a><br /></td></tr>
<tr class="separator:a2d701f7629091f4f89f273ab9bb44a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f4bcd29bc1dbb3f3980b20c2ad05b6"><td class="memItemLeft" align="right" valign="top"><a id="a55f4bcd29bc1dbb3f3980b20c2ad05b6" name="a55f4bcd29bc1dbb3f3980b20c2ad05b6"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>message_priority</b> { <br />
&#160;&#160;<b>high</b> = 0
, <br />
&#160;&#160;<b>normal</b> = 1
<br />
 }</td></tr>
<tr class="separator:a55f4bcd29bc1dbb3f3980b20c2ad05b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b93288f573f015630a689bd03607ca"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607ca">pec</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caa260ca9dd8a4577fc00b7bd5810298076">success</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caa6c7d599b08d42472b1bad3d33b9bed3a">trailing_character</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caa1a5b101afc11147048312dd33b62e008">unexpected_eof</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caadf367fb990f1a76035e3c1884443d8ee">unexpected_character</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caae9c695325dd91c8074c3445c2edecebe">timespan_overflow</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caa30b10fb73b7640a186b1b369b702fc4b">fractional_timespan</a> = 5
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caa6beb6e2a9cef45cf6f85766c71931c22">too_many_characters</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caa089031f44942f5039bf1c4eae7bedd44">invalid_escape_sequence</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caa6fe7694a5d04b5e82a2deb21f2a5c004">unexpected_newline</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caae9a83ecfce47bad5a02cf347e7cd5796">integer_overflow</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caaff3b21a97947ac46215370aee7af776b">integer_underflow</a> = 10
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caafe59dbfda3078f50d0f5a39dcae23571">exponent_underflow</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caad77666a4c1efd86d546cbd54f71e5bdf">exponent_overflow</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caa570a4fa126d94bc89332b5f610420adf">type_mismatch</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caa7cd12b6998314dc0ad565a7ea5d2de4e">not_an_option</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caae55d43eabeefe5a8271b4a3c898bd18f">invalid_argument</a> = 15
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caab2d7cd4bd5ec469e66ccfe2d27c7e415">missing_argument</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caa0416e200d7acdab3eb1d301e458ebd21">invalid_category</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caa9b38077cbfb9d7b3ebb1a586cf3a1b54">invalid_field_name</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caa44b773b5b5d63d98552267dfd07c053f">repeated_field_name</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caa5ac1975aa5d9e092d334e9a64ddc9d37">missing_field</a> = 20
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caa6bdbd4c80b3712ffd66335d14f16ba61">invalid_range_expression</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caa1528b2e7d0051d6d859b53639dd6f49c">invalid_state</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607caaee55faef8c86d3222e023c98a9246331">nested_too_deeply</a>
<br />
 }</td></tr>
<tr class="memdesc:a82b93288f573f015630a689bd03607ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">PEC stands for "Parser Error Code".  <a href="namespacecaf.html#a82b93288f573f015630a689bd03607ca">More...</a><br /></td></tr>
<tr class="separator:a82b93288f573f015630a689bd03607ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad31759ecbee7d4d2133a5618a053a78"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78">sec</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a334c4a4c42fdb79d7ebc3e73b517e6f8">none</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a597cfdb46675641f694b1f918760d432">unexpected_message</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78ad4a1781764e87a2801983ce8181c27cf">unexpected_response</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a7f4365e77fb6f589c84c20e81197c79d">request_receiver_down</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78ad3e570068c1caf02414be8c33ed0870f">request_timeout</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a182e28a53823e6df87a1ed00aa5ed058">no_such_group_module</a> = 5
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a72401a7ff0db08ed2aa28a34733e8d40">no_actor_published_at_port</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a7f84bdf352032576d3d804762a214a9a">unexpected_actor_messaging_interface</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78ac439cf91e7ec59d69162275db58d478e">state_not_serializable</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a8daeacea51521a5662fa6abed16df722">unsupported_sys_key</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a3af43f852e2ac3a3c37136c787dd5976">unsupported_sys_message</a> = 10
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a83e7246ebfde490dddd886250bab9f4f">disconnect_during_handshake</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a2e6d121b6903ac137b1d99661f2e5b7f">cannot_forward_to_invalid_actor</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a57be9b695350dca990b35a9152085b54">no_route_to_receiving_node</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a8a52ad217cfb8e32d90340a4c2c25806">failed_to_assign_scribe_from_handle</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a141b4e2bb3270cefa57c93e914ef6f3a">failed_to_assign_doorman_from_handle</a> = 15
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a90b4b331c03edf609637a75a282597eb">cannot_close_invalid_port</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78ac6da4afffebf441d165db9e552649f6a">cannot_connect_to_node</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78aa791028a7c1dc4ee2617c72fd999906d">cannot_open_port</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a2dfd755a3f71048412701b4a22bc1614">network_syscall_failed</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78ae55d43eabeefe5a8271b4a3c898bd18f">invalid_argument</a> = 20
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78adff503db0417804f50d2ef49a5280366">invalid_protocol_family</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78afe9f9410355ad948b97dbf13a296758b">cannot_publish_invalid_actor</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a2bee4050533a327c092b95adbc3e0839">cannot_spawn_actor_from_arguments</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a09f3645c755dc42466f97cbbc7896000">end_of_stream</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a43e1a8d7d8c3dd37b9358e3f9dcb9473">no_context</a> = 25
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78ad09109cd4d5da45ade59d2563b00936a">unknown_type</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78aa4557d86914df2ee9493a8c7e559b7c3">no_proxy_registry</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a5b32065884bcc1f2ed126c47e6410808">runtime_error</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a1023fb495955973a444b9d285a9129c1">remote_linking_failed</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a374b2d9beed3dabe37612ee5851afa78">cannot_add_upstream</a> = 30
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a686e18b530d3b66e314a78041bfab873">upstream_already_exists</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a49bbf68a3bb43f766f0d936c7498b3f6">invalid_upstream</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78af7d600ebee28dc40f6dedecbbea1457b">cannot_add_downstream</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a79db1b95b8a19ac96be1326e1c37e1ea">downstream_already_exists</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a6e1024bb2c206a3787fbc66bf815d71f">invalid_downstream</a> = 35
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a37bbe6b3372a9b92da8a90f189b7fc19">no_downstream_stages_defined</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a7aff60e790581bfaf2bd29203d3af224">stream_init_failed</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78aa59d243db5f771529aac4080f5c11814">invalid_stream_state</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a3a5b02a7e1fc4444f0b8b0ee7fca2ec3">unhandled_stream_error</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78aeeed16271ec14658fb1a840778a1fea2">bad_function_call</a> = 40
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a094da9add5824bd75d5a77345ceae3e1">feature_disabled</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78aac1f4cf357f10c246b3baf4249a5bf54">cannot_open_file</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78aaa37af5140de69d45d25429ebb117c64">socket_invalid</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a12dc50fa4c160bf4c296cc76f62e1c08">socket_disconnected</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a63f7dcf058c93eadecbf31a04b91364e">socket_operation_failed</a> = 45
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a8f26bd94d3f683889fa8afe778415bc7">unavailable_or_would_block</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a3c5b83ab628258751100cdcabaf5971d">incompatible_versions</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a6642893019029eb5392c48c23df33a7c">incompatible_application_ids</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a14d077ff432a34ef7c3eb283d537048a">malformed_basp_message</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78ae700afffc67d712f83909d1dccfe0a45">serializing_basp_payload_failed</a> = 50
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a1defcc2f092a086729836d8c2d7ba6ef">redundant_connection</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a059ab9f40c68954d6638cd16b0de78ac">remote_lookup_failed</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a28f5f35f759489092936a167d1d1e532">no_tracing_context</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a11b3b23cfd05ebb04793fde6ec02aa30">all_requests_failed</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78af1aa7cc385e9bf213707f9cc8c1e3dab">field_invariant_check_failed</a> = 55
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a73309fa931e6d5e0c9bad76669f41c32">field_value_synchronization_failed</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a975d2ebf2eeb2499c359b46331a9d5b8">invalid_field_type</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78aa50e2449803ba25e376c3eef5ccdfafd">unsafe_type</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a263046755e1736d41d45ba04e05786de">save_callback_failed</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78ac04928ba66bb6a2f4e1898402a00f8c7">load_callback_failed</a> = 60
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a30cd543aac9d9d6e01b647c70848cabd">conversion_failed</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a5a4d02758bc275845aca53ff718b3c57">connection_closed</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a8e9620a3e2665fcf7b8a4b1b69945931">type_clash</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78acc640652ae07f015b97e295c1d10a537">unsupported_operation</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a90001cae602348443ea1dc98bbdd4bf7">no_such_key</a> = 65
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a2c6bc6062e72db1c0915032943cb6452">broken_promise</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a3536bed60dc32e8c16f87261b9a17a99">connection_timeout</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78a9063edf6d57bc0142267406a56c17f3b">action_reschedule_failed</a>
<br />
 }</td></tr>
<tr class="memdesc:aad31759ecbee7d4d2133a5618a053a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">SEC stands for "System Error Code".  <a href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78">More...</a><br /></td></tr>
<tr class="separator:aad31759ecbee7d4d2133a5618a053a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga291d9d4fcae86cf8d3de7d28c500a308"><td class="memItemLeft" align="right" valign="top"><a id="ga291d9d4fcae86cf8d3de7d28c500a308" name="ga291d9d4fcae86cf8d3de7d28c500a308"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a> : int { <br />
&#160;&#160;<b>no_flags</b> = 0x00
, <br />
&#160;&#160;<b>link_flag</b> = 0x01
, <br />
&#160;&#160;<b>monitor_flag</b> = 0x02
, <br />
&#160;&#160;<b>detach_flag</b> = 0x04
, <br />
&#160;&#160;<b>hide_flag</b> = 0x08
, <br />
&#160;&#160;<b>priority_aware_flag</b> = 0x20
, <br />
&#160;&#160;<b>lazy_init_flag</b> = 0x40
<br />
 }</td></tr>
<tr class="memdesc:ga291d9d4fcae86cf8d3de7d28c500a308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores options passed to the <code>spawn</code> function family. <br /></td></tr>
<tr class="separator:ga291d9d4fcae86cf8d3de7d28c500a308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3512d365fcd27e9b37110c7fcdd6b4"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#acb3512d365fcd27e9b37110c7fcdd6b4">stream_priority</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacecaf.html#acb3512d365fcd27e9b37110c7fcdd6b4aaa4cea18ae7516f9a3c28d597055082f">very_high</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#acb3512d365fcd27e9b37110c7fcdd6b4a8d966b2253a917086c8604959e152243">high</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#acb3512d365fcd27e9b37110c7fcdd6b4afea087517c26fadd409bd4b9dc642555">normal</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#acb3512d365fcd27e9b37110c7fcdd6b4a53cced8d281a1a0ace3cb6594daaa4f7">low</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#acb3512d365fcd27e9b37110c7fcdd6b4ab7619bc8e14fe34d78820f979605ee8b">very_low</a>
<br />
 }</td></tr>
<tr class="memdesc:acb3512d365fcd27e9b37110c7fcdd6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Categorizes individual streams.  <a href="namespacecaf.html#acb3512d365fcd27e9b37110c7fcdd6b4">More...</a><br /></td></tr>
<tr class="separator:acb3512d365fcd27e9b37110c7fcdd6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa601da0abafbe531a0068d454c7e8ccc"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccc">term</a> { <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccca86266ee937d97f812a8e57d22b62ee29">reset</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccca3cf983ff848c5f880c537d8cef3e76c3">reset_endl</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccca1ffd9e753c8054cc61456ac7fac1ac89">black</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8cccabda9643ac6601722a28f238714274da4">red</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccca9f27410725ab8cc8854a2769c7a516b8">green</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8cccad487dd0b55dfcacdd920ccbdaeafa351">yellow</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccca48d6215903dff56238e52e8891380c8f">blue</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccca4c2a4a7078da0ac6733464eacfd00f86">magenta</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccca6411532ba4971f378391776a9db629d3">cyan</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8cccad508fe45cecaf653904a0e774084bb5c">white</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccca5f9b622730053f7063ada5e969325e64">bold_black</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8cccabb3d08e30223136bcfd186360e97e4f7">bold_red</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccca797c3638f6188754f08441b1ecc5613c">bold_green</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccca6366363dc00bb036c6027c8919dabb64">bold_yellow</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccca1f23307b7fb5697014697d14a225ba18">bold_blue</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccca83bf3e2728755397fe9ce2ba7f583add">bold_magenta</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8cccab50236763fd3f98a2414e91c208ac5e0">bold_cyan</a>
, <br />
&#160;&#160;<a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8cccaeb5e1e280820375730b379c984c34697">bold_white</a>
<br />
 }</td></tr>
<tr class="memdesc:aa601da0abafbe531a0068d454c7e8ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminal color and font face options.  <a href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccc">More...</a><br /></td></tr>
<tr class="separator:aa601da0abafbe531a0068d454c7e8ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2e94a756127f21081dee74a570ac25a2"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a2e94a756127f21081dee74a570ac25a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1action.html">action</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a2e94a756127f21081dee74a570ac25a2">make_action</a> (F f, <a class="el" href="classcaf_1_1action.html#a8c8ca1629afa927e277da0d8133ad981">action::state</a> init_state=<a class="el" href="classcaf_1_1action.html#a8c8ca1629afa927e277da0d8133ad981a638a6d925c422c868b28b9562498ea1d">action::state::scheduled</a>)</td></tr>
<tr class="memdesc:a2e94a756127f21081dee74a570ac25a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for creating <a class="el" href="classcaf_1_1action.html">action</a> objects from a function object.  <br /></td></tr>
<tr class="separator:a2e94a756127f21081dee74a570ac25a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff5d7c4b2177c3189dd2a4130b3a93d"><td class="memItemLeft" align="right" valign="top"><a id="a1ff5d7c4b2177c3189dd2a4130b3a93d" name="a1ff5d7c4b2177c3189dd2a4130b3a93d"></a>
CAF_CORE_EXPORT <a class="el" href="classcaf_1_1actor.html">actor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="classcaf_1_1actor.html">actor</a> f, <a class="el" href="classcaf_1_1actor.html">actor</a> g)</td></tr>
<tr class="memdesc:a1ff5d7c4b2177c3189dd2a4130b3a93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine <code>f</code> and <code>g</code> so that <code>(f*g)(x) = f(g(x))</code>. <br /></td></tr>
<tr class="separator:a1ff5d7c4b2177c3189dd2a4130b3a93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7d40e9e06ef438a3d2419996930256"><td class="memItemLeft" align="right" valign="top"><a id="a5c7d40e9e06ef438a3d2419996930256" name="a5c7d40e9e06ef438a3d2419996930256"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcaf_1_1actor__addr.html">actor_addr</a> &amp;x, std::nullptr_t)</td></tr>
<tr class="separator:a5c7d40e9e06ef438a3d2419996930256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa287987457d0dcf7007d170942705bc6"><td class="memItemLeft" align="right" valign="top"><a id="aa287987457d0dcf7007d170942705bc6" name="aa287987457d0dcf7007d170942705bc6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (std::nullptr_t, const <a class="el" href="classcaf_1_1actor__addr.html">actor_addr</a> &amp;x)</td></tr>
<tr class="separator:aa287987457d0dcf7007d170942705bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c71c76bf724b299ca86492bc34055b"><td class="memItemLeft" align="right" valign="top"><a id="a70c71c76bf724b299ca86492bc34055b" name="a70c71c76bf724b299ca86492bc34055b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcaf_1_1actor__addr.html">actor_addr</a> &amp;x, std::nullptr_t)</td></tr>
<tr class="separator:a70c71c76bf724b299ca86492bc34055b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46fbf8e424e6a764ffd2906c3ff044d"><td class="memItemLeft" align="right" valign="top"><a id="ac46fbf8e424e6a764ffd2906c3ff044d" name="ac46fbf8e424e6a764ffd2906c3ff044d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (std::nullptr_t, const <a class="el" href="classcaf_1_1actor__addr.html">actor_addr</a> &amp;x)</td></tr>
<tr class="separator:ac46fbf8e424e6a764ffd2906c3ff044d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fa79a7a2c849c7438cb5eda9bd588a"><td class="memTemplParams" colspan="2"><a id="a48fa79a7a2c849c7438cb5eda9bd588a" name="a48fa79a7a2c849c7438cb5eda9bd588a"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a48fa79a7a2c849c7438cb5eda9bd588a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>actor_cast</b> (U &amp;&amp;what)</td></tr>
<tr class="memdesc:a48fa79a7a2c849c7438cb5eda9bd588a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts actor handle <code>what</code> to a different actor handle or raw pointer of type <code>T</code>. <br /></td></tr>
<tr class="separator:a48fa79a7a2c849c7438cb5eda9bd588a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d633f44095c8c1f57b32ccefd4475e"><td class="memItemLeft" align="right" valign="top"><a id="ae0d633f44095c8c1f57b32ccefd4475e" name="ae0d633f44095c8c1f57b32ccefd4475e"></a>
CAF_CORE_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcaf_1_1intrusive__ptr.html">strong_actor_ptr</a> &amp;, const <a class="el" href="classcaf_1_1abstract__actor.html">abstract_actor</a> *)</td></tr>
<tr class="separator:ae0d633f44095c8c1f57b32ccefd4475e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f75c107ccb735aa06ec1aa77e4be867"><td class="memItemLeft" align="right" valign="top"><a id="a6f75c107ccb735aa06ec1aa77e4be867" name="a6f75c107ccb735aa06ec1aa77e4be867"></a>
CAF_CORE_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcaf_1_1abstract__actor.html">abstract_actor</a> *, const <a class="el" href="classcaf_1_1intrusive__ptr.html">strong_actor_ptr</a> &amp;)</td></tr>
<tr class="separator:a6f75c107ccb735aa06ec1aa77e4be867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac745e102849cf687ece31be62f3c4dcb"><td class="memItemLeft" align="right" valign="top"><a id="ac745e102849cf687ece31be62f3c4dcb" name="ac745e102849cf687ece31be62f3c4dcb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcaf_1_1intrusive__ptr.html">strong_actor_ptr</a> &amp;x, const <a class="el" href="classcaf_1_1abstract__actor.html">abstract_actor</a> *y)</td></tr>
<tr class="separator:ac745e102849cf687ece31be62f3c4dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8b576a34cce0833d7db1d25a161e18"><td class="memItemLeft" align="right" valign="top"><a id="a0b8b576a34cce0833d7db1d25a161e18" name="a0b8b576a34cce0833d7db1d25a161e18"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcaf_1_1abstract__actor.html">abstract_actor</a> *x, const <a class="el" href="classcaf_1_1intrusive__ptr.html">strong_actor_ptr</a> &amp;y)</td></tr>
<tr class="separator:a0b8b576a34cce0833d7db1d25a161e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834af079ed006ba06654f6f970c8a0e2"><td class="memItemLeft" align="right" valign="top"><a id="a834af079ed006ba06654f6f970c8a0e2" name="a834af079ed006ba06654f6f970c8a0e2"></a>
CAF_CORE_EXPORT <a class="el" href="classcaf_1_1error__code.html">error_code</a>&lt; <a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78">sec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>load_actor</b> (<a class="el" href="classcaf_1_1intrusive__ptr.html">strong_actor_ptr</a> &amp;storage, <a class="el" href="classcaf_1_1execution__unit.html">execution_unit</a> *, actor_id aid, const <a class="el" href="classcaf_1_1node__id.html">node_id</a> &amp;nid)</td></tr>
<tr class="separator:a834af079ed006ba06654f6f970c8a0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b89f8339a2a8a1e87d319f346622a74"><td class="memItemLeft" align="right" valign="top"><a id="a6b89f8339a2a8a1e87d319f346622a74" name="a6b89f8339a2a8a1e87d319f346622a74"></a>
CAF_CORE_EXPORT <a class="el" href="classcaf_1_1error__code.html">error_code</a>&lt; <a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78">sec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>save_actor</b> (<a class="el" href="classcaf_1_1intrusive__ptr.html">strong_actor_ptr</a> &amp;storage, <a class="el" href="classcaf_1_1execution__unit.html">execution_unit</a> *, actor_id aid, const <a class="el" href="classcaf_1_1node__id.html">node_id</a> &amp;nid)</td></tr>
<tr class="separator:a6b89f8339a2a8a1e87d319f346622a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b9a9b49a97e4bd23b0d08c4d186515"><td class="memTemplParams" colspan="2"><a id="a88b9a9b49a97e4bd23b0d08c4d186515" name="a88b9a9b49a97e4bd23b0d08c4d186515"></a>
template&lt;class Inspector &gt; </td></tr>
<tr class="memitem:a88b9a9b49a97e4bd23b0d08c4d186515"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>context_of</b> (Inspector *f) -&gt; decltype(f-&gt;context())</td></tr>
<tr class="separator:a88b9a9b49a97e4bd23b0d08c4d186515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9f61a7fedcdce607701beb0d46b1dc"><td class="memItemLeft" align="right" valign="top"><a id="a2b9f61a7fedcdce607701beb0d46b1dc" name="a2b9f61a7fedcdce607701beb0d46b1dc"></a>
<a class="el" href="classcaf_1_1execution__unit.html">execution_unit</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>context_of</b> (void *)</td></tr>
<tr class="separator:a2b9f61a7fedcdce607701beb0d46b1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad725700c8e7b4cc4f690c67430cd4b1a"><td class="memItemLeft" align="right" valign="top"><a id="ad725700c8e7b4cc4f690c67430cd4b1a" name="ad725700c8e7b4cc4f690c67430cd4b1a"></a>
CAF_CORE_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcaf_1_1intrusive__ptr.html">strong_actor_ptr</a> &amp;x)</td></tr>
<tr class="separator:ad725700c8e7b4cc4f690c67430cd4b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bed1c34633d124db6f29a39e4501744"><td class="memItemLeft" align="right" valign="top"><a id="a8bed1c34633d124db6f29a39e4501744" name="a8bed1c34633d124db6f29a39e4501744"></a>
CAF_CORE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>append_to_string</b> (std::string &amp;x, const <a class="el" href="classcaf_1_1intrusive__ptr.html">strong_actor_ptr</a> &amp;y)</td></tr>
<tr class="separator:a8bed1c34633d124db6f29a39e4501744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300042beb293813bfb0767bf2439278b"><td class="memItemLeft" align="right" valign="top"><a id="a300042beb293813bfb0767bf2439278b" name="a300042beb293813bfb0767bf2439278b"></a>
CAF_CORE_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcaf_1_1weak__intrusive__ptr.html">weak_actor_ptr</a> &amp;x)</td></tr>
<tr class="separator:a300042beb293813bfb0767bf2439278b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8bd355ddc7d60846abf920b512c125"><td class="memItemLeft" align="right" valign="top"><a id="abc8bd355ddc7d60846abf920b512c125" name="abc8bd355ddc7d60846abf920b512c125"></a>
CAF_CORE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>append_to_string</b> (std::string &amp;x, const <a class="el" href="classcaf_1_1weak__intrusive__ptr.html">weak_actor_ptr</a> &amp;y)</td></tr>
<tr class="separator:abc8bd355ddc7d60846abf920b512c125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e38f314f95d05bbc71f5ceced235a0f"><td class="memTemplParams" colspan="2"><a id="a6e38f314f95d05bbc71f5ceced235a0f" name="a6e38f314f95d05bbc71f5ceced235a0f"></a>
template&lt;class Inspector &gt; </td></tr>
<tr class="memitem:a6e38f314f95d05bbc71f5ceced235a0f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inspect</b> (Inspector &amp;f, <a class="el" href="classcaf_1_1intrusive__ptr.html">strong_actor_ptr</a> &amp;x)</td></tr>
<tr class="separator:a6e38f314f95d05bbc71f5ceced235a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c2ef9fe571bf671fe53b0de6adaf99"><td class="memTemplParams" colspan="2"><a id="ae8c2ef9fe571bf671fe53b0de6adaf99" name="ae8c2ef9fe571bf671fe53b0de6adaf99"></a>
template&lt;class Inspector &gt; </td></tr>
<tr class="memitem:ae8c2ef9fe571bf671fe53b0de6adaf99"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inspect</b> (Inspector &amp;f, <a class="el" href="classcaf_1_1weak__intrusive__ptr.html">weak_actor_ptr</a> &amp;x)</td></tr>
<tr class="separator:ae8c2ef9fe571bf671fe53b0de6adaf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7f740af612cb19a31c0c08c29d35e5"><td class="memTemplParams" colspan="2"><a id="a2b7f740af612cb19a31c0c08c29d35e5" name="a2b7f740af612cb19a31c0c08c29d35e5"></a>
template&lt;class F &gt; </td></tr>
<tr class="memitem:a2b7f740af612cb19a31c0c08c29d35e5"><td class="memTemplItemLeft" align="right" valign="top">actor_factory&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_actor_factory</b> (F fun)</td></tr>
<tr class="separator:a2b7f740af612cb19a31c0c08c29d35e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33f19486c25ef172fb8670453ebe988"><td class="memTemplParams" colspan="2"><a id="ae33f19486c25ef172fb8670453ebe988" name="ae33f19486c25ef172fb8670453ebe988"></a>
template&lt;class T , class... Ts&gt; </td></tr>
<tr class="memitem:ae33f19486c25ef172fb8670453ebe988"><td class="memTemplItemLeft" align="right" valign="top">actor_factory_result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dyn_spawn_class</b> (<a class="el" href="classcaf_1_1actor__config.html">actor_config</a> &amp;cfg, <a class="el" href="classcaf_1_1message.html">message</a> &amp;msg)</td></tr>
<tr class="separator:ae33f19486c25ef172fb8670453ebe988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2641646eabbd4eaade2f743660bd3c49"><td class="memTemplParams" colspan="2"><a id="a2641646eabbd4eaade2f743660bd3c49" name="a2641646eabbd4eaade2f743660bd3c49"></a>
template&lt;class T , class... Ts&gt; </td></tr>
<tr class="memitem:a2641646eabbd4eaade2f743660bd3c49"><td class="memTemplItemLeft" align="right" valign="top">actor_factory&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_actor_factory</b> ()</td></tr>
<tr class="separator:a2641646eabbd4eaade2f743660bd3c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6f74c138230acbee7580364b141e52"><td class="memItemLeft" align="right" valign="top"><a id="aea6f74c138230acbee7580364b141e52" name="aea6f74c138230acbee7580364b141e52"></a>
CAF_CORE_EXPORT <a class="el" href="classcaf_1_1actor__ostream.html">actor_ostream</a>&#160;</td><td class="memItemRight" valign="bottom"><b>aout</b> (<a class="el" href="classcaf_1_1local__actor.html">local_actor</a> *self)</td></tr>
<tr class="memdesc:aea6f74c138230acbee7580364b141e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience factory function for creating an actor output stream. <br /></td></tr>
<tr class="separator:aea6f74c138230acbee7580364b141e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a364e86055bbf3e517b3aa9ffea67c2"><td class="memItemLeft" align="right" valign="top"><a id="a9a364e86055bbf3e517b3aa9ffea67c2" name="a9a364e86055bbf3e517b3aa9ffea67c2"></a>
CAF_CORE_EXPORT <a class="el" href="classcaf_1_1actor__ostream.html">actor_ostream</a>&#160;</td><td class="memItemRight" valign="bottom"><b>aout</b> (<a class="el" href="classcaf_1_1scoped__actor.html">scoped_actor</a> &amp;self)</td></tr>
<tr class="separator:a9a364e86055bbf3e517b3aa9ffea67c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5118217d41625ef31148fd5c6d7ce95"><td class="memTemplParams" colspan="2"><a id="af5118217d41625ef31148fd5c6d7ce95" name="af5118217d41625ef31148fd5c6d7ce95"></a>
template&lt;class... Sigs&gt; </td></tr>
<tr class="memitem:af5118217d41625ef31148fd5c6d7ce95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1actor__ostream.html">actor_ostream</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>aout</b> (const typed_actor_pointer&lt; Sigs... &gt; &amp;ptr)</td></tr>
<tr class="memdesc:af5118217d41625ef31148fd5c6d7ce95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience factory function for creating an actor output stream. <br /></td></tr>
<tr class="separator:af5118217d41625ef31148fd5c6d7ce95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1042959728d1c6b2df830afe6d5e653e"><td class="memItemLeft" align="right" valign="top"><a id="a1042959728d1c6b2df830afe6d5e653e" name="a1042959728d1c6b2df830afe6d5e653e"></a>
CAF_CORE_EXPORT const <a class="el" href="classcaf_1_1dictionary.html">settings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>content</b> (const <a class="el" href="classcaf_1_1actor__system__config.html">actor_system_config</a> &amp;cfg)</td></tr>
<tr class="memdesc:a1042959728d1c6b2df830afe6d5e653e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all user-provided configuration parameters. <br /></td></tr>
<tr class="separator:a1042959728d1c6b2df830afe6d5e653e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff41e650ba731832bc6e1c807cd8957"><td class="memTemplParams" colspan="2"><a id="a6ff41e650ba731832bc6e1c807cd8957" name="a6ff41e650ba731832bc6e1c807cd8957"></a>
template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:a6ff41e650ba731832bc6e1c807cd8957"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>after</b> (std::chrono::duration&lt; Rep, Period &gt; d)</td></tr>
<tr class="memdesc:a6ff41e650ba731832bc6e1c807cd8957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a generator for timeouts. <br /></td></tr>
<tr class="separator:a6ff41e650ba731832bc6e1c807cd8957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a48dbfc20607bdc4fc5d35ec9e30e91"><td class="memTemplParams" colspan="2">template&lt;class Driver , class... Ts&gt; </td></tr>
<tr class="memitem:a2a48dbfc20607bdc4fc5d35ec9e30e91"><td class="memTemplItemLeft" align="right" valign="top">Driver::source_ptr_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a2a48dbfc20607bdc4fc5d35ec9e30e91">attach_continuous_stream_source</a> (scheduled_actor *self, Ts &amp;&amp;... xs)</td></tr>
<tr class="memdesc:a2a48dbfc20607bdc4fc5d35ec9e30e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new continuous stream source by instantiating the default source implementation with <code>Driver</code>.  <br /></td></tr>
<tr class="separator:a2a48dbfc20607bdc4fc5d35ec9e30e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b4b7d9d353b3a8287fdc43a44636dd"><td class="memTemplParams" colspan="2">template&lt;class Init , class Pull , class Done , class Finalize  = unit_t, class Trait  = stream_source_trait_t&lt;Pull&gt;, class DownstreamManager  = broadcast_downstream_manager&lt;            typename Trait::output&gt;&gt; </td></tr>
<tr class="memitem:a93b4b7d9d353b3a8287fdc43a44636dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1intrusive__ptr.html">stream_source_ptr</a>&lt; DownstreamManager &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a93b4b7d9d353b3a8287fdc43a44636dd">attach_continuous_stream_source</a> (scheduled_actor *self, Init init, Pull pull, Done done, Finalize fin={}, <a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt;={})</td></tr>
<tr class="memdesc:a93b4b7d9d353b3a8287fdc43a44636dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new continuous stream source by instantiating the default source implementation with <code>Driver</code>.  <br /></td></tr>
<tr class="separator:a93b4b7d9d353b3a8287fdc43a44636dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f8bd34b9566a65b10e3bead8b17e67"><td class="memTemplParams" colspan="2">template&lt;class Driver , class... Ts&gt; </td></tr>
<tr class="memitem:a92f8bd34b9566a65b10e3bead8b17e67"><td class="memTemplItemLeft" align="right" valign="top">Driver::stage_ptr_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a92f8bd34b9566a65b10e3bead8b17e67">attach_continuous_stream_stage</a> (scheduled_actor *self, Ts &amp;&amp;... xs)</td></tr>
<tr class="memdesc:a92f8bd34b9566a65b10e3bead8b17e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a stream manager (implementing a continuous stage) without in- or outbound path.  <br /></td></tr>
<tr class="separator:a92f8bd34b9566a65b10e3bead8b17e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dfde35ab4e7d585aac7717f4e573bf"><td class="memTemplParams" colspan="2">template&lt;class Init , class Fun , class Finalize  = unit_t, class DownstreamManager  = default_downstream_manager_t&lt;Fun&gt;, class Trait  = stream_stage_trait_t&lt;Fun&gt;&gt; </td></tr>
<tr class="memitem:a65dfde35ab4e7d585aac7717f4e573bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1intrusive__ptr.html">stream_stage_ptr</a>&lt; typename Trait::input, DownstreamManager &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a65dfde35ab4e7d585aac7717f4e573bf">attach_continuous_stream_stage</a> (scheduled_actor *self, Init init, Fun fun, Finalize fin={}, <a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt; token={})</td></tr>
<tr class="separator:a65dfde35ab4e7d585aac7717f4e573bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0642bbc8ae541d35cffc39cf0809f23a"><td class="memTemplParams" colspan="2">template&lt;class Driver , class... Ts&gt; </td></tr>
<tr class="memitem:a0642bbc8ae541d35cffc39cf0809f23a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1make__sink__result.html">make_sink_result</a>&lt; typename Driver::input_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a0642bbc8ae541d35cffc39cf0809f23a">attach_stream_sink</a> (scheduled_actor *self, <a class="el" href="classcaf_1_1stream.html">stream</a>&lt; typename Driver::input_type &gt; in, Ts &amp;&amp;... xs)</td></tr>
<tr class="memdesc:a0642bbc8ae541d35cffc39cf0809f23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a new stream sink to <code>self</code> by creating a default stream sink / manager from given callbacks.  <br /></td></tr>
<tr class="separator:a0642bbc8ae541d35cffc39cf0809f23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f83bc671410a202c06545ec0f4b6891"><td class="memTemplParams" colspan="2">template&lt;class In , class Init , class Fun , class Finalize  = unit_t, class Trait  = stream_sink_trait_t&lt;Fun&gt;&gt; </td></tr>
<tr class="memitem:a2f83bc671410a202c06545ec0f4b6891"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1make__sink__result.html">make_sink_result</a>&lt; In &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a2f83bc671410a202c06545ec0f4b6891">attach_stream_sink</a> (scheduled_actor *self, <a class="el" href="classcaf_1_1stream.html">stream</a>&lt; In &gt; in, Init init, Fun fun, Finalize fin={})</td></tr>
<tr class="memdesc:a2f83bc671410a202c06545ec0f4b6891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a new stream sink to <code>self</code> by creating a default stream sink manager from given callbacks.  <br /></td></tr>
<tr class="separator:a2f83bc671410a202c06545ec0f4b6891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80b3de17d280ae1814cb99305dead40"><td class="memTemplParams" colspan="2">template&lt;class Driver , class... Ts, class... CtorArgs&gt; </td></tr>
<tr class="memitem:ac80b3de17d280ae1814cb99305dead40"><td class="memTemplItemLeft" align="right" valign="top">make_source_result_t&lt; typename Driver::downstream_manager_type, Ts... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#ac80b3de17d280ae1814cb99305dead40">attach_stream_source</a> (scheduled_actor *self, std::tuple&lt; Ts... &gt; xs, CtorArgs &amp;&amp;... ctor_args)</td></tr>
<tr class="memdesc:ac80b3de17d280ae1814cb99305dead40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a new stream source to <code>self</code> by creating a default stream source manager with <code>Driver</code>.  <br /></td></tr>
<tr class="separator:ac80b3de17d280ae1814cb99305dead40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994e986fde8a2b2a80a9e362fe597eb9"><td class="memTemplParams" colspan="2">template&lt;class... Ts, class Init , class Pull , class Done , class Finalize  = unit_t, class Trait  = stream_source_trait_t&lt;Pull&gt;, class DownstreamManager  = broadcast_downstream_manager&lt;            typename Trait::output&gt;&gt; </td></tr>
<tr class="memitem:a994e986fde8a2b2a80a9e362fe597eb9"><td class="memTemplItemLeft" align="right" valign="top">make_source_result_t&lt; DownstreamManager, Ts... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a994e986fde8a2b2a80a9e362fe597eb9">attach_stream_source</a> (scheduled_actor *self, std::tuple&lt; Ts... &gt; xs, Init init, Pull pull, Done done, Finalize fin={}, <a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt;={})</td></tr>
<tr class="memdesc:a994e986fde8a2b2a80a9e362fe597eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a new stream source to <code>self</code> by creating a default stream source manager with the default driver.  <br /></td></tr>
<tr class="separator:a994e986fde8a2b2a80a9e362fe597eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db77aa018331be6ebcaa1dfb762be26"><td class="memTemplParams" colspan="2">template&lt;class Init , class Pull , class Done , class Finalize  = unit_t, class DownstreamManager  = default_downstream_manager_t&lt;Pull&gt;, class Trait  = stream_source_trait_t&lt;Pull&gt;&gt; </td></tr>
<tr class="memitem:a8db77aa018331be6ebcaa1dfb762be26"><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_t&lt;!<a class="el" href="structcaf_1_1is__actor__handle.html">is_actor_handle</a>&lt; Init &gt;::value &amp;&amp;Trait::valid, make_source_result_t&lt; DownstreamManager &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a8db77aa018331be6ebcaa1dfb762be26">attach_stream_source</a> (scheduled_actor *self, Init init, Pull pull, Done done, Finalize fin={}, <a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt; token={})</td></tr>
<tr class="memdesc:a8db77aa018331be6ebcaa1dfb762be26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a new stream source to <code>self</code> by creating a default stream source manager with the default driver.  <br /></td></tr>
<tr class="separator:a8db77aa018331be6ebcaa1dfb762be26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25071db301bf0c57d0113939c2981913"><td class="memTemplParams" colspan="2">template&lt;class ActorHandle , class... Ts, class Init , class Pull , class Done , class Finalize  = unit_t, class DownstreamManager  = default_downstream_manager_t&lt;Pull&gt;, class Trait  = stream_source_trait_t&lt;Pull&gt;&gt; </td></tr>
<tr class="memitem:a25071db301bf0c57d0113939c2981913"><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_t&lt; <a class="el" href="structcaf_1_1is__actor__handle.html">is_actor_handle</a>&lt; ActorHandle &gt;::value, make_source_result_t&lt; DownstreamManager &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a25071db301bf0c57d0113939c2981913">attach_stream_source</a> (scheduled_actor *self, const ActorHandle &amp;dest, std::tuple&lt; Ts... &gt; xs, Init init, Pull pull, Done done, Finalize fin={}, <a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt;={})</td></tr>
<tr class="memdesc:a25071db301bf0c57d0113939c2981913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a new stream source to <code>self</code> by creating a default stream source manager with the default driver and starts sending to <code>dest</code> immediately.  <br /></td></tr>
<tr class="separator:a25071db301bf0c57d0113939c2981913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b6ed4f952ae93fdf415d0128cd9691"><td class="memTemplParams" colspan="2">template&lt;class ActorHandle , class Init , class Pull , class Done , class Finalize  = unit_t, class DownstreamManager  = default_downstream_manager_t&lt;Pull&gt;, class Trait  = stream_source_trait_t&lt;Pull&gt;&gt; </td></tr>
<tr class="memitem:ae1b6ed4f952ae93fdf415d0128cd9691"><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_t&lt; <a class="el" href="structcaf_1_1is__actor__handle.html">is_actor_handle</a>&lt; ActorHandle &gt;::value &amp;&amp;Trait::valid, make_source_result_t&lt; DownstreamManager &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#ae1b6ed4f952ae93fdf415d0128cd9691">attach_stream_source</a> (scheduled_actor *self, const ActorHandle &amp;dest, Init init, Pull pull, Done done, Finalize fin={}, <a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt; token={})</td></tr>
<tr class="memdesc:ae1b6ed4f952ae93fdf415d0128cd9691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a new stream source to <code>self</code> by creating a default stream source manager with the default driver and starts sending to <code>dest</code> immediately.  <br /></td></tr>
<tr class="separator:ae1b6ed4f952ae93fdf415d0128cd9691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3297ece14ba4363d1d0eac988820370a"><td class="memTemplParams" colspan="2">template&lt;class Driver , class In , class... Ts, class... Us&gt; </td></tr>
<tr class="memitem:a3297ece14ba4363d1d0eac988820370a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecaf.html#ac4f35acd9e6d9f1214f1fee72993632b">make_stage_result_t</a>&lt; In, typename Driver::downstream_manager_type, Ts... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a3297ece14ba4363d1d0eac988820370a">attach_stream_stage</a> (scheduled_actor *self, const <a class="el" href="classcaf_1_1stream.html">stream</a>&lt; In &gt; &amp;in, std::tuple&lt; Ts... &gt; xs, Us &amp;&amp;... ys)</td></tr>
<tr class="memdesc:a3297ece14ba4363d1d0eac988820370a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a new stream stage to <code>self</code> by creating a default stream stage manager with <code>Driver</code>.  <br /></td></tr>
<tr class="separator:a3297ece14ba4363d1d0eac988820370a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6227520338c0c0cd0110027c4245796b"><td class="memTemplParams" colspan="2">template&lt;class In , class... Ts, class Init , class Fun , class Finalize  = unit_t, class DownstreamManager  = default_downstream_manager_t&lt;Fun&gt;, class Trait  = stream_stage_trait_t&lt;Fun&gt;&gt; </td></tr>
<tr class="memitem:a6227520338c0c0cd0110027c4245796b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecaf.html#ac4f35acd9e6d9f1214f1fee72993632b">make_stage_result_t</a>&lt; In, DownstreamManager, Ts... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a6227520338c0c0cd0110027c4245796b">attach_stream_stage</a> (scheduled_actor *self, const <a class="el" href="classcaf_1_1stream.html">stream</a>&lt; In &gt; &amp;in, std::tuple&lt; Ts... &gt; xs, Init init, Fun fun, Finalize fin={}, <a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt; token={})</td></tr>
<tr class="memdesc:a6227520338c0c0cd0110027c4245796b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a new stream stage to <code>self</code> by creating a default stream stage manager from given callbacks.  <br /></td></tr>
<tr class="separator:a6227520338c0c0cd0110027c4245796b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad174b610a0d4250177cce3d57cd9378d"><td class="memTemplParams" colspan="2">template&lt;class In , class Init , class Fun , class Finalize  = unit_t, class DownstreamManager  = default_downstream_manager_t&lt;Fun&gt;, class Trait  = stream_stage_trait_t&lt;Fun&gt;&gt; </td></tr>
<tr class="memitem:ad174b610a0d4250177cce3d57cd9378d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecaf.html#ac4f35acd9e6d9f1214f1fee72993632b">make_stage_result_t</a>&lt; In, DownstreamManager &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#ad174b610a0d4250177cce3d57cd9378d">attach_stream_stage</a> (scheduled_actor *self, const <a class="el" href="classcaf_1_1stream.html">stream</a>&lt; In &gt; &amp;in, Init init, Fun fun, Finalize fin={}, <a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt; token={})</td></tr>
<tr class="memdesc:ad174b610a0d4250177cce3d57cd9378d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a new stream stage to <code>self</code> by creating a default stream stage manager from given callbacks.  <br /></td></tr>
<tr class="separator:ad174b610a0d4250177cce3d57cd9378d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcff7caa541e7fd5e8d62094beeed3a"><td class="memTemplParams" colspan="2"><a id="acfcff7caa541e7fd5e8d62094beeed3a" name="acfcff7caa541e7fd5e8d62094beeed3a"></a>
template&lt;class IntegerType , class  = std::enable_if_t&lt;std::is_integral&lt;IntegerType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:acfcff7caa541e7fd5e8d62094beeed3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr IntegerType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_integer</b> (<a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> x) noexcept</td></tr>
<tr class="separator:acfcff7caa541e7fd5e8d62094beeed3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59398195d8f0102482a294c33cc5ee59"><td class="memTemplParams" colspan="2"><a id="a59398195d8f0102482a294c33cc5ee59" name="a59398195d8f0102482a294c33cc5ee59"></a>
template&lt;class IntegerType , class E  = std::enable_if_t&lt;std::is_integral&lt;IntegerType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a59398195d8f0102482a294c33cc5ee59"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;=</b> (<a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> &amp;x, IntegerType shift) noexcept</td></tr>
<tr class="separator:a59398195d8f0102482a294c33cc5ee59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7d030bbb5c00612868d735c43dc8bb"><td class="memTemplParams" colspan="2"><a id="adb7d030bbb5c00612868d735c43dc8bb" name="adb7d030bbb5c00612868d735c43dc8bb"></a>
template&lt;class IntegerType , class E  = std::enable_if_t&lt;std::is_integral&lt;IntegerType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:adb7d030bbb5c00612868d735c43dc8bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> x, IntegerType shift) noexcept</td></tr>
<tr class="separator:adb7d030bbb5c00612868d735c43dc8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab415cc0c9e0dcf6d9c6483ea3e465960"><td class="memTemplParams" colspan="2"><a id="ab415cc0c9e0dcf6d9c6483ea3e465960" name="ab415cc0c9e0dcf6d9c6483ea3e465960"></a>
template&lt;class IntegerType , class E  = std::enable_if_t&lt;std::is_integral&lt;IntegerType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ab415cc0c9e0dcf6d9c6483ea3e465960"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;=</b> (<a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> &amp;x, IntegerType shift) noexcept</td></tr>
<tr class="separator:ab415cc0c9e0dcf6d9c6483ea3e465960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab37120d5c09d9eaf42261d02d28ae59"><td class="memTemplParams" colspan="2"><a id="aab37120d5c09d9eaf42261d02d28ae59" name="aab37120d5c09d9eaf42261d02d28ae59"></a>
template&lt;class IntegerType , class E  = std::enable_if_t&lt;std::is_integral&lt;IntegerType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:aab37120d5c09d9eaf42261d02d28ae59"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> x, IntegerType shift) noexcept</td></tr>
<tr class="separator:aab37120d5c09d9eaf42261d02d28ae59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65702c2cc8e2c1576ea486a08bd4de21"><td class="memItemLeft" align="right" valign="top"><a id="a65702c2cc8e2c1576ea486a08bd4de21" name="a65702c2cc8e2c1576ea486a08bd4de21"></a>
<a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator|=</b> (<a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> &amp;x, <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> y) noexcept</td></tr>
<tr class="separator:a65702c2cc8e2c1576ea486a08bd4de21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0764caa367796838c9a3dca702fab55f"><td class="memItemLeft" align="right" valign="top"><a id="a0764caa367796838c9a3dca702fab55f" name="a0764caa367796838c9a3dca702fab55f"></a>
constexpr <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (<a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> x, <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> y) noexcept</td></tr>
<tr class="separator:a0764caa367796838c9a3dca702fab55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e083a99ba24ceac7cb22f5c0b87fc0"><td class="memItemLeft" align="right" valign="top"><a id="a79e083a99ba24ceac7cb22f5c0b87fc0" name="a79e083a99ba24ceac7cb22f5c0b87fc0"></a>
<a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;=</b> (<a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> &amp;x, <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> y) noexcept</td></tr>
<tr class="separator:a79e083a99ba24ceac7cb22f5c0b87fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc142d10409ec51babf9606b4f59cac"><td class="memItemLeft" align="right" valign="top"><a id="a1cc142d10409ec51babf9606b4f59cac" name="a1cc142d10409ec51babf9606b4f59cac"></a>
constexpr <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;</b> (<a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> x, <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> y) noexcept</td></tr>
<tr class="separator:a1cc142d10409ec51babf9606b4f59cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf4fe79ec625edabcc98db71a8e8e7b"><td class="memItemLeft" align="right" valign="top"><a id="abaf4fe79ec625edabcc98db71a8e8e7b" name="abaf4fe79ec625edabcc98db71a8e8e7b"></a>
<a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator^=</b> (<a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> &amp;x, <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> y) noexcept</td></tr>
<tr class="separator:abaf4fe79ec625edabcc98db71a8e8e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af4cbd415498c347e3af05742ed5282"><td class="memItemLeft" align="right" valign="top"><a id="a4af4cbd415498c347e3af05742ed5282" name="a4af4cbd415498c347e3af05742ed5282"></a>
constexpr <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator^</b> (<a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> x, <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> y) noexcept</td></tr>
<tr class="separator:a4af4cbd415498c347e3af05742ed5282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805c329b14fa44c34ef49f14009649db"><td class="memItemLeft" align="right" valign="top"><a id="a805c329b14fa44c34ef49f14009649db" name="a805c329b14fa44c34ef49f14009649db"></a>
constexpr <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator~</b> (<a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> x) noexcept</td></tr>
<tr class="separator:a805c329b14fa44c34ef49f14009649db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e0c9c43285f7bcdb53a70fdfc1ecaa"><td class="memTemplParams" colspan="2"><a id="a31e0c9c43285f7bcdb53a70fdfc1ecaa" name="a31e0c9c43285f7bcdb53a70fdfc1ecaa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a31e0c9c43285f7bcdb53a70fdfc1ecaa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>statically_typed</b> ()</td></tr>
<tr class="separator:a31e0c9c43285f7bcdb53a70fdfc1ecaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566d584bfa9c78437f22c19b6815f868"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class Sentinel &gt; </td></tr>
<tr class="memitem:a566d584bfa9c78437f22c19b6815f868"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; ForwardIterator, <a class="el" href="classcaf_1_1string__view.html">string_view</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a566d584bfa9c78437f22c19b6815f868">find_by_long_name</a> (const <a class="el" href="classcaf_1_1config__option.html">config_option</a> &amp;x, ForwardIterator first, Sentinel last)</td></tr>
<tr class="memdesc:a566d584bfa9c78437f22c19b6815f868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code><a class="el" href="classcaf_1_1config__option.html" title="Defines a configuration option for the application.">config_option</a></code> string with a matching long name in (<code>first</code>, <code>last</code>], where each entry is a pointer to a string.  <br /></td></tr>
<tr class="separator:a566d584bfa9c78437f22c19b6815f868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fb8ae28802c0f8cf2f224c00b7d85b"><td class="memTemplParams" colspan="2"><a id="a39fb8ae28802c0f8cf2f224c00b7d85b" name="a39fb8ae28802c0f8cf2f224c00b7d85b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a39fb8ae28802c0f8cf2f224c00b7d85b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1expected.html">expected</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_as</b> (const <a class="el" href="classcaf_1_1config__value.html">config_value</a> &amp;, <a class="el" href="structcaf_1_1inspector__access__type_1_1none.html">inspector_access_type::none</a>)</td></tr>
<tr class="separator:a39fb8ae28802c0f8cf2f224c00b7d85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba06c1da94a16a7043cee14ccc99c4b7"><td class="memTemplParams" colspan="2"><a id="aba06c1da94a16a7043cee14ccc99c4b7" name="aba06c1da94a16a7043cee14ccc99c4b7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aba06c1da94a16a7043cee14ccc99c4b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1expected.html">expected</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_as</b> (const <a class="el" href="classcaf_1_1config__value.html">config_value</a> &amp;, <a class="el" href="structcaf_1_1inspector__access__type_1_1unsafe.html">inspector_access_type::unsafe</a>)</td></tr>
<tr class="separator:aba06c1da94a16a7043cee14ccc99c4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba31e624e22796ff0d6139a930d97f69"><td class="memTemplParams" colspan="2"><a id="aba31e624e22796ff0d6139a930d97f69" name="aba31e624e22796ff0d6139a930d97f69"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aba31e624e22796ff0d6139a930d97f69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1expected.html">expected</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_as</b> (const <a class="el" href="classcaf_1_1config__value.html">config_value</a> &amp;x, <a class="el" href="structcaf_1_1inspector__access__type_1_1specialization.html">inspector_access_type::specialization</a> token)</td></tr>
<tr class="separator:aba31e624e22796ff0d6139a930d97f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dff82ec1c84882285eb7621fe27ae54"><td class="memTemplParams" colspan="2"><a id="a6dff82ec1c84882285eb7621fe27ae54" name="a6dff82ec1c84882285eb7621fe27ae54"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6dff82ec1c84882285eb7621fe27ae54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1expected.html">expected</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_as</b> (const <a class="el" href="classcaf_1_1config__value.html">config_value</a> &amp;x, <a class="el" href="structcaf_1_1inspector__access__type_1_1inspect.html">inspector_access_type::inspect</a> token)</td></tr>
<tr class="separator:a6dff82ec1c84882285eb7621fe27ae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b81611e9f2c6eeef615a0c03373a5c"><td class="memTemplParams" colspan="2"><a id="ae4b81611e9f2c6eeef615a0c03373a5c" name="ae4b81611e9f2c6eeef615a0c03373a5c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae4b81611e9f2c6eeef615a0c03373a5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1expected.html">expected</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_as</b> (const <a class="el" href="classcaf_1_1config__value.html">config_value</a> &amp;x, <a class="el" href="structcaf_1_1inspector__access__type_1_1builtin__inspect.html">inspector_access_type::builtin_inspect</a> token)</td></tr>
<tr class="separator:ae4b81611e9f2c6eeef615a0c03373a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcee312a6c5c6be246dea64dc122d50"><td class="memTemplParams" colspan="2"><a id="a7bcee312a6c5c6be246dea64dc122d50" name="a7bcee312a6c5c6be246dea64dc122d50"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7bcee312a6c5c6be246dea64dc122d50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1expected.html">expected</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_as</b> (const <a class="el" href="classcaf_1_1config__value.html">config_value</a> &amp;x, <a class="el" href="structcaf_1_1inspector__access__type_1_1builtin.html">inspector_access_type::builtin</a>)</td></tr>
<tr class="separator:a7bcee312a6c5c6be246dea64dc122d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35c8aae85fe535f3b594680f058a473"><td class="memTemplParams" colspan="2"><a id="aa35c8aae85fe535f3b594680f058a473" name="aa35c8aae85fe535f3b594680f058a473"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa35c8aae85fe535f3b594680f058a473"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1expected.html">expected</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_as</b> (const <a class="el" href="classcaf_1_1config__value.html">config_value</a> &amp;x, <a class="el" href="structcaf_1_1inspector__access__type_1_1empty.html">inspector_access_type::empty</a>)</td></tr>
<tr class="separator:aa35c8aae85fe535f3b594680f058a473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae9c210a7d0ab9d7a9527c5fc0329bd"><td class="memTemplParams" colspan="2"><a id="a1ae9c210a7d0ab9d7a9527c5fc0329bd" name="a1ae9c210a7d0ab9d7a9527c5fc0329bd"></a>
template&lt;class T , size_t... Is&gt; </td></tr>
<tr class="memitem:a1ae9c210a7d0ab9d7a9527c5fc0329bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1expected.html">expected</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_as_tuple</b> (const config_value::list &amp;x, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="separator:a1ae9c210a7d0ab9d7a9527c5fc0329bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03b563ac7f47466f090e0ed327d8341"><td class="memTemplParams" colspan="2"><a id="ab03b563ac7f47466f090e0ed327d8341" name="ab03b563ac7f47466f090e0ed327d8341"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab03b563ac7f47466f090e0ed327d8341"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1expected.html">expected</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_as</b> (const <a class="el" href="classcaf_1_1config__value.html">config_value</a> &amp;x, <a class="el" href="structcaf_1_1inspector__access__type_1_1tuple.html">inspector_access_type::tuple</a>)</td></tr>
<tr class="separator:ab03b563ac7f47466f090e0ed327d8341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5e7b4490f8f3bbb567fa201bb79d4b"><td class="memTemplParams" colspan="2"><a id="ada5e7b4490f8f3bbb567fa201bb79d4b" name="ada5e7b4490f8f3bbb567fa201bb79d4b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ada5e7b4490f8f3bbb567fa201bb79d4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1expected.html">expected</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_as</b> (const <a class="el" href="classcaf_1_1config__value.html">config_value</a> &amp;x, <a class="el" href="structcaf_1_1inspector__access__type_1_1map.html">inspector_access_type::map</a>)</td></tr>
<tr class="separator:ada5e7b4490f8f3bbb567fa201bb79d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8147bd5915f5b12cc704d02ccda42d1"><td class="memTemplParams" colspan="2"><a id="af8147bd5915f5b12cc704d02ccda42d1" name="af8147bd5915f5b12cc704d02ccda42d1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af8147bd5915f5b12cc704d02ccda42d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1expected.html">expected</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_as</b> (const <a class="el" href="classcaf_1_1config__value.html">config_value</a> &amp;x, <a class="el" href="structcaf_1_1inspector__access__type_1_1list.html">inspector_access_type::list</a>)</td></tr>
<tr class="separator:af8147bd5915f5b12cc704d02ccda42d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab426aab1a0f491fd56de35d63a425f86"><td class="memTemplParams" colspan="2"><a id="ab426aab1a0f491fd56de35d63a425f86" name="ab426aab1a0f491fd56de35d63a425f86"></a>
template&lt;class T , class  = std::enable_if_t&lt;detail::is_config_value_type_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ab426aab1a0f491fd56de35d63a425f86"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_if</b> (const <a class="el" href="classcaf_1_1config__value.html">config_value</a> *x)</td></tr>
<tr class="separator:ab426aab1a0f491fd56de35d63a425f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af000a59552195df5e5f1d7bc4559a6ca"><td class="memTemplParams" colspan="2"><a id="af000a59552195df5e5f1d7bc4559a6ca" name="af000a59552195df5e5f1d7bc4559a6ca"></a>
template&lt;class T , class  = std::enable_if_t&lt;detail::is_config_value_type_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:af000a59552195df5e5f1d7bc4559a6ca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_if</b> (<a class="el" href="classcaf_1_1config__value.html">config_value</a> *x)</td></tr>
<tr class="separator:af000a59552195df5e5f1d7bc4559a6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5e6ad326f7c7787b02708fcd71ecd0"><td class="memTemplParams" colspan="2"><a id="a1b5e6ad326f7c7787b02708fcd71ecd0" name="a1b5e6ad326f7c7787b02708fcd71ecd0"></a>
template&lt;class T , class  = std::enable_if_t&lt;detail::is_config_value_type_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:a1b5e6ad326f7c7787b02708fcd71ecd0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="classcaf_1_1config__value.html">config_value</a> &amp;x)</td></tr>
<tr class="separator:a1b5e6ad326f7c7787b02708fcd71ecd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cb4b75f669b429fc7a504f73d9c742"><td class="memTemplParams" colspan="2"><a id="a59cb4b75f669b429fc7a504f73d9c742" name="a59cb4b75f669b429fc7a504f73d9c742"></a>
template&lt;class T , class  = std::enable_if_t&lt;detail::is_config_value_type_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:a59cb4b75f669b429fc7a504f73d9c742"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="classcaf_1_1config__value.html">config_value</a> &amp;x)</td></tr>
<tr class="separator:a59cb4b75f669b429fc7a504f73d9c742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63e99d4aa3862d82068c09830f0b7f1"><td class="memTemplParams" colspan="2"><a id="af63e99d4aa3862d82068c09830f0b7f1" name="af63e99d4aa3862d82068c09830f0b7f1"></a>
template&lt;class T , class  = std::enable_if_t&lt;detail::is_config_value_type_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:af63e99d4aa3862d82068c09830f0b7f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>holds_alternative</b> (const <a class="el" href="classcaf_1_1config__value.html">config_value</a> &amp;x)</td></tr>
<tr class="separator:af63e99d4aa3862d82068c09830f0b7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345f8b79961c062f085192298118e29b"><td class="memTemplParams" colspan="2"><a id="a345f8b79961c062f085192298118e29b" name="a345f8b79961c062f085192298118e29b"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a345f8b79961c062f085192298118e29b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1config__value.html">config_value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_config_value_list</b> (Ts &amp;&amp;... xs)</td></tr>
<tr class="separator:a345f8b79961c062f085192298118e29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2213089ee5e48ddf1af632630d533619"><td class="memTemplParams" colspan="2"><a id="a2213089ee5e48ddf1af632630d533619" name="a2213089ee5e48ddf1af632630d533619"></a>
template&lt;size_t Index, class... Ts&gt; </td></tr>
<tr class="memitem:a2213089ee5e48ddf1af632630d533619"><td class="memTemplItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const_typed_message_view&lt; Ts... &gt; xs)</td></tr>
<tr class="separator:a2213089ee5e48ddf1af632630d533619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0cae4f1085c80c9f335c8ec7a02d07"><td class="memTemplParams" colspan="2"><a id="abb0cae4f1085c80c9f335c8ec7a02d07" name="abb0cae4f1085c80c9f335c8ec7a02d07"></a>
template&lt;class... Ts, size_t... Is&gt; </td></tr>
<tr class="memitem:abb0cae4f1085c80c9f335c8ec7a02d07"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_tuple</b> (const_typed_message_view&lt; Ts... &gt; xs, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="separator:abb0cae4f1085c80c9f335c8ec7a02d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee907f2cab52eebce28248d243e85498"><td class="memTemplParams" colspan="2"><a id="aee907f2cab52eebce28248d243e85498" name="aee907f2cab52eebce28248d243e85498"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:aee907f2cab52eebce28248d243e85498"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_tuple</b> (const_typed_message_view&lt; Ts... &gt; xs)</td></tr>
<tr class="separator:aee907f2cab52eebce28248d243e85498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b411b593d03fdf6f86299076eb1200"><td class="memTemplParams" colspan="2"><a id="a00b411b593d03fdf6f86299076eb1200" name="a00b411b593d03fdf6f86299076eb1200"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a00b411b593d03fdf6f86299076eb1200"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_const_typed_message_view</b> (const <a class="el" href="classcaf_1_1message.html">message</a> &amp;msg)</td></tr>
<tr class="separator:a00b411b593d03fdf6f86299076eb1200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c75f4073eb297a5c6313bb2fe83cde"><td class="memTemplParams" colspan="2"><a id="a22c75f4073eb297a5c6313bb2fe83cde" name="a22c75f4073eb297a5c6313bb2fe83cde"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a22c75f4073eb297a5c6313bb2fe83cde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1optional.html">optional</a>&lt; std::tuple&lt; Ts... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_tuple</b> (const <a class="el" href="classcaf_1_1message.html">message</a> &amp;msg)</td></tr>
<tr class="separator:a22c75f4073eb297a5c6313bb2fe83cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7f4ed8d2f4066779b6192b106225d2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ace7f4ed8d2f4066779b6192b106225d2"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#ace7f4ed8d2f4066779b6192b106225d2">deep_to_string</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ace7f4ed8d2f4066779b6192b106225d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls collections such as vectors/maps, decomposes tuples/pairs/arrays, auto-escapes strings and calls <code>to_string</code> for user-defined types via argument-dependent loopkup (ADL).  <br /></td></tr>
<tr class="separator:ace7f4ed8d2f4066779b6192b106225d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101b778dc3127fe1f46c00c50f2e8b14"><td class="memTemplParams" colspan="2"><a id="a101b778dc3127fe1f46c00c50f2e8b14" name="a101b778dc3127fe1f46c00c50f2e8b14"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a101b778dc3127fe1f46c00c50f2e8b14"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deep_to_string_as_tuple</b> (const Ts &amp;... xs)</td></tr>
<tr class="memdesc:a101b778dc3127fe1f46c00c50f2e8b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for <code>deep_to_string(std::forward_as_tuple(xs...))</code>. <br /></td></tr>
<tr class="separator:a101b778dc3127fe1f46c00c50f2e8b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae060c36113f25850a252a9ec5f91dc78"><td class="memTemplParams" colspan="2">template&lt;class Inspector , class Enumeration &gt; </td></tr>
<tr class="memitem:ae060c36113f25850a252a9ec5f91dc78"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#ae060c36113f25850a252a9ec5f91dc78">default_enum_inspect</a> (Inspector &amp;f, Enumeration &amp;x)</td></tr>
<tr class="memdesc:ae060c36113f25850a252a9ec5f91dc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for providing a default inspection scaffold for custom enumeration types.  <br /></td></tr>
<tr class="separator:ae060c36113f25850a252a9ec5f91dc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dabbbda66e6a1a656adf6abd8ae41e0"><td class="memTemplParams" colspan="2"><a id="a0dabbbda66e6a1a656adf6abd8ae41e0" name="a0dabbbda66e6a1a656adf6abd8ae41e0"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a0dabbbda66e6a1a656adf6abd8ae41e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcaf_1_1delegated.html">delegated</a>&lt; Ts... &gt; &amp;, const <a class="el" href="classcaf_1_1delegated.html">delegated</a>&lt; Ts... &gt; &amp;)</td></tr>
<tr class="separator:a0dabbbda66e6a1a656adf6abd8ae41e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157f55a370f5a097745806a02a8e8281"><td class="memTemplParams" colspan="2"><a id="a157f55a370f5a097745806a02a8e8281" name="a157f55a370f5a097745806a02a8e8281"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a157f55a370f5a097745806a02a8e8281"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcaf_1_1dictionary.html">dictionary</a>&lt; T &gt; &amp;xs, const <a class="el" href="classcaf_1_1dictionary.html">dictionary</a>&lt; T &gt; &amp;ys)</td></tr>
<tr class="separator:a157f55a370f5a097745806a02a8e8281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce73a68c7389856b8b7edae594cd411"><td class="memTemplParams" colspan="2"><a id="a9ce73a68c7389856b8b7edae594cd411" name="a9ce73a68c7389856b8b7edae594cd411"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9ce73a68c7389856b8b7edae594cd411"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcaf_1_1dictionary.html">dictionary</a>&lt; T &gt; &amp;xs, const <a class="el" href="classcaf_1_1dictionary.html">dictionary</a>&lt; T &gt; &amp;ys)</td></tr>
<tr class="separator:a9ce73a68c7389856b8b7edae594cd411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8e4e9358a26d322fe2311f5fabe507"><td class="memTemplParams" colspan="2"><a id="a2f8e4e9358a26d322fe2311f5fabe507" name="a2f8e4e9358a26d322fe2311f5fabe507"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2f8e4e9358a26d322fe2311f5fabe507"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classcaf_1_1dictionary.html">dictionary</a>&lt; T &gt; &amp;xs, const <a class="el" href="classcaf_1_1dictionary.html">dictionary</a>&lt; T &gt; &amp;ys)</td></tr>
<tr class="separator:a2f8e4e9358a26d322fe2311f5fabe507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f58d5d8b9067c28e4b1bbd7ecba473"><td class="memTemplParams" colspan="2"><a id="aa9f58d5d8b9067c28e4b1bbd7ecba473" name="aa9f58d5d8b9067c28e4b1bbd7ecba473"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa9f58d5d8b9067c28e4b1bbd7ecba473"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classcaf_1_1dictionary.html">dictionary</a>&lt; T &gt; &amp;xs, const <a class="el" href="classcaf_1_1dictionary.html">dictionary</a>&lt; T &gt; &amp;ys)</td></tr>
<tr class="separator:aa9f58d5d8b9067c28e4b1bbd7ecba473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bdc20c8d87859bab215aa670dc4924"><td class="memTemplParams" colspan="2"><a id="a87bdc20c8d87859bab215aa670dc4924" name="a87bdc20c8d87859bab215aa670dc4924"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a87bdc20c8d87859bab215aa670dc4924"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classcaf_1_1dictionary.html">dictionary</a>&lt; T &gt; &amp;xs, const <a class="el" href="classcaf_1_1dictionary.html">dictionary</a>&lt; T &gt; &amp;ys)</td></tr>
<tr class="separator:a87bdc20c8d87859bab215aa670dc4924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3deea7c35327faefcaec2d8820be80"><td class="memTemplParams" colspan="2"><a id="aaa3deea7c35327faefcaec2d8820be80" name="aaa3deea7c35327faefcaec2d8820be80"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aaa3deea7c35327faefcaec2d8820be80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classcaf_1_1dictionary.html">dictionary</a>&lt; T &gt; &amp;xs, const <a class="el" href="classcaf_1_1dictionary.html">dictionary</a>&lt; T &gt; &amp;ys)</td></tr>
<tr class="separator:aaa3deea7c35327faefcaec2d8820be80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d20cf7291ca0d3bf6583324d8e21708"><td class="memTemplParams" colspan="2"><a id="a5d20cf7291ca0d3bf6583324d8e21708" name="a5d20cf7291ca0d3bf6583324d8e21708"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5d20cf7291ca0d3bf6583324d8e21708"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="structcaf_1_1downstream__msg.html">downstream_msg</a> &amp;x)</td></tr>
<tr class="memdesc:a5d20cf7291ca0d3bf6583324d8e21708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the testing DSL to unbox <code><a class="el" href="structcaf_1_1downstream__msg.html" title="Stream messages that travel downstream, i.e., batches and close messages.">downstream_msg</a></code> automagically. <br /></td></tr>
<tr class="separator:a5d20cf7291ca0d3bf6583324d8e21708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21c59b5137420150b88f9887123aa26"><td class="memTemplParams" colspan="2"><a id="aa21c59b5137420150b88f9887123aa26" name="aa21c59b5137420150b88f9887123aa26"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa21c59b5137420150b88f9887123aa26"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is</b> (const <a class="el" href="structcaf_1_1downstream__msg.html">downstream_msg</a> &amp;x)</td></tr>
<tr class="memdesc:aa21c59b5137420150b88f9887123aa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the testing DSL to check whether <code><a class="el" href="structcaf_1_1downstream__msg.html" title="Stream messages that travel downstream, i.e., batches and close messages.">downstream_msg</a></code> holds a <code>T</code>. <br /></td></tr>
<tr class="separator:aa21c59b5137420150b88f9887123aa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5e5f830ff0080eae02ab879e83e646"><td class="memTemplParams" colspan="2"><a id="adf5e5f830ff0080eae02ab879e83e646" name="adf5e5f830ff0080eae02ab879e83e646"></a>
template&lt;class Enum &gt; </td></tr>
<tr class="memitem:adf5e5f830ff0080eae02ab879e83e646"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_string</b> (<a class="el" href="classcaf_1_1error__code.html">error_code</a>&lt; Enum &gt; x) -&gt; decltype(to_string(x.value()))</td></tr>
<tr class="memdesc:adf5e5f830ff0080eae02ab879e83e646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>x</code> to a string if <code>Enum</code> provides a <code>to_string</code> function. <br /></td></tr>
<tr class="separator:adf5e5f830ff0080eae02ab879e83e646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aad6c7a7f4cb951bcecc10b07055b17"><td class="memTemplParams" colspan="2"><a id="a1aad6c7a7f4cb951bcecc10b07055b17" name="a1aad6c7a7f4cb951bcecc10b07055b17"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1aad6c7a7f4cb951bcecc10b07055b17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exec_main_init_meta_objects_single</b> ()</td></tr>
<tr class="separator:a1aad6c7a7f4cb951bcecc10b07055b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8754ab4f2980f537e38f14a919351e1"><td class="memTemplParams" colspan="2"><a id="af8754ab4f2980f537e38f14a919351e1" name="af8754ab4f2980f537e38f14a919351e1"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:af8754ab4f2980f537e38f14a919351e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exec_main_init_meta_objects</b> ()</td></tr>
<tr class="separator:af8754ab4f2980f537e38f14a919351e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add55c6eaf26fca42181e043d78e9ef33"><td class="memTemplParams" colspan="2"><a id="add55c6eaf26fca42181e043d78e9ef33" name="add55c6eaf26fca42181e043d78e9ef33"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:add55c6eaf26fca42181e043d78e9ef33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exec_main_load_module</b> (<a class="el" href="classcaf_1_1actor__system__config.html">actor_system_config</a> &amp;cfg)</td></tr>
<tr class="separator:add55c6eaf26fca42181e043d78e9ef33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3f6a280b2235128c8bad7bdb992a3f"><td class="memTemplParams" colspan="2"><a id="a6d3f6a280b2235128c8bad7bdb992a3f" name="a6d3f6a280b2235128c8bad7bdb992a3f"></a>
template&lt;class... Ts, class F  = void (*)(actor_system&amp;)&gt; </td></tr>
<tr class="memitem:a6d3f6a280b2235128c8bad7bdb992a3f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exec_main</b> (F fun, int argc, char **argv)</td></tr>
<tr class="separator:a6d3f6a280b2235128c8bad7bdb992a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d076bb4dddfb27cfbb455675bd19ce"><td class="memTemplParams" colspan="2"><a id="a45d076bb4dddfb27cfbb455675bd19ce" name="a45d076bb4dddfb27cfbb455675bd19ce"></a>
template&lt;class Inspector &gt; </td></tr>
<tr class="memitem:a45d076bb4dddfb27cfbb455675bd19ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inspect</b> (Inspector &amp;f, <a class="el" href="namespacecaf.html#a72ed789d5a799ff8eab4697604ae5784">exit_reason</a> &amp;x)</td></tr>
<tr class="separator:a45d076bb4dddfb27cfbb455675bd19ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a83f78746bc68076322f54a29b3adcf"><td class="memTemplParams" colspan="2"><a id="a9a83f78746bc68076322f54a29b3adcf" name="a9a83f78746bc68076322f54a29b3adcf"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9a83f78746bc68076322f54a29b3adcf"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcaf_1_1expected.html">expected</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a9a83f78746bc68076322f54a29b3adcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c88731250223bf3b569bc5eaba371a"><td class="memItemLeft" align="right" valign="top"><a id="ae4c88731250223bf3b569bc5eaba371a" name="ae4c88731250223bf3b569bc5eaba371a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcaf_1_1expected.html">expected</a>&lt; void &gt; &amp;x)</td></tr>
<tr class="separator:ae4c88731250223bf3b569bc5eaba371a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a002f7ce1ac1cb4a2f5c7c3eaf5f5eb"><td class="memTemplParams" colspan="2"><a id="a4a002f7ce1ac1cb4a2f5c7c3eaf5f5eb" name="a4a002f7ce1ac1cb4a2f5c7c3eaf5f5eb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4a002f7ce1ac1cb4a2f5c7c3eaf5f5eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1config__option.html">config_option</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_config_option</b> (<a class="el" href="classcaf_1_1string__view.html">string_view</a> category, <a class="el" href="classcaf_1_1string__view.html">string_view</a> name, <a class="el" href="classcaf_1_1string__view.html">string_view</a> description)</td></tr>
<tr class="memdesc:a4a002f7ce1ac1cb4a2f5c7c3eaf5f5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a config option that synchronizes with <code>storage</code>. <br /></td></tr>
<tr class="separator:a4a002f7ce1ac1cb4a2f5c7c3eaf5f5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dc160f1c813e4e8f7ff7d5f42415be"><td class="memTemplParams" colspan="2"><a id="aa3dc160f1c813e4e8f7ff7d5f42415be" name="aa3dc160f1c813e4e8f7ff7d5f42415be"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa3dc160f1c813e4e8f7ff7d5f42415be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1config__option.html">config_option</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_config_option</b> (T &amp;storage, <a class="el" href="classcaf_1_1string__view.html">string_view</a> category, <a class="el" href="classcaf_1_1string__view.html">string_view</a> name, <a class="el" href="classcaf_1_1string__view.html">string_view</a> description)</td></tr>
<tr class="memdesc:aa3dc160f1c813e4e8f7ff7d5f42415be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a config option that synchronizes with <code>storage</code>. <br /></td></tr>
<tr class="separator:aa3dc160f1c813e4e8f7ff7d5f42415be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26607dc21bd50d5914cb19f886e040e2"><td class="memTemplParams" colspan="2">template&lt;class ProjectIds , uint16_t... Is&gt; </td></tr>
<tr class="memitem:a26607dc21bd50d5914cb19f886e040e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a26607dc21bd50d5914cb19f886e040e2">init_global_meta_objects_impl</a> (std::integer_sequence&lt; uint16_t, Is... &gt;)</td></tr>
<tr class="separator:a26607dc21bd50d5914cb19f886e040e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac323494144a0417c656f7970d508a962"><td class="memTemplParams" colspan="2">template&lt;class ProjectIds &gt; </td></tr>
<tr class="memitem:ac323494144a0417c656f7970d508a962"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#ac323494144a0417c656f7970d508a962">init_global_meta_objects</a> ()</td></tr>
<tr class="memdesc:ac323494144a0417c656f7970d508a962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the global meta object table with all types in <code>ProjectIds</code>.  <br /></td></tr>
<tr class="separator:ac323494144a0417c656f7970d508a962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d9d45eca66c9fad83784c4e34eb854"><td class="memTemplParams" colspan="2"><a id="a80d9d45eca66c9fad83784c4e34eb854" name="a80d9d45eca66c9fad83784c4e34eb854"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a80d9d45eca66c9fad83784c4e34eb854"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a80d9d45eca66c9fad83784c4e34eb854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f5c744c745067fc69bb0ae13a33882"><td class="memItemLeft" align="right" valign="top"><a id="a67f5c744c745067fc69bb0ae13a33882" name="a67f5c744c745067fc69bb0ae13a33882"></a>
CAF_CORE_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (<a class="el" href="namespacecaf.html#a2d701f7629091f4f89f273ab9bb44a20">invoke_message_result</a>)</td></tr>
<tr class="separator:a67f5c744c745067fc69bb0ae13a33882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad674da48a40de86b9b06fc5fe0c766eb"><td class="memItemLeft" align="right" valign="top"><a id="ad674da48a40de86b9b06fc5fe0c766eb" name="ad674da48a40de86b9b06fc5fe0c766eb"></a>
CAF_CORE_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcaf_1_1ipv4__endpoint.html">ipv4_endpoint</a> &amp;ep)</td></tr>
<tr class="separator:ad674da48a40de86b9b06fc5fe0c766eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367001dc3350b7c21c8c3c90c756e460"><td class="memItemLeft" align="right" valign="top"><a id="a367001dc3350b7c21c8c3c90c756e460" name="a367001dc3350b7c21c8c3c90c756e460"></a>
CAF_CORE_EXPORT <a class="el" href="classcaf_1_1error.html">error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classcaf_1_1string__view.html">string_view</a> str, ipv6_address &amp;dest)</td></tr>
<tr class="separator:a367001dc3350b7c21c8c3c90c756e460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3739f0cf128c65e7cbffbf15c4d94fa1"><td class="memItemLeft" align="right" valign="top"><a id="a3739f0cf128c65e7cbffbf15c4d94fa1" name="a3739f0cf128c65e7cbffbf15c4d94fa1"></a>
CAF_CORE_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcaf_1_1ipv6__endpoint.html">ipv6_endpoint</a> &amp;ep)</td></tr>
<tr class="separator:a3739f0cf128c65e7cbffbf15c4d94fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5de3a1baf1c22139818871c716de78d"><td class="memItemLeft" align="right" valign="top"><a id="ad5de3a1baf1c22139818871c716de78d" name="ad5de3a1baf1c22139818871c716de78d"></a>
CAF_CORE_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (logger::field_type x)</td></tr>
<tr class="separator:ad5de3a1baf1c22139818871c716de78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0c796701b99b3cfb77381ad9175218"><td class="memTemplParams" colspan="2"><a id="aad0c796701b99b3cfb77381ad9175218" name="aad0c796701b99b3cfb77381ad9175218"></a>
template&lt;class T , class R  = infer_handle_from_class_t&lt;T&gt;, class... Ts&gt; </td></tr>
<tr class="memitem:aad0c796701b99b3cfb77381ad9175218"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_actor</b> (actor_id aid, <a class="el" href="classcaf_1_1node__id.html">node_id</a> nid, <a class="el" href="classcaf_1_1actor__system.html">actor_system</a> *sys, Ts &amp;&amp;... xs)</td></tr>
<tr class="separator:aad0c796701b99b3cfb77381ad9175218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc17e63d7bbc4f42f67adaee5c84fa4"><td class="memItemLeft" align="right" valign="top"><a id="a0fc17e63d7bbc4f42f67adaee5c84fa4" name="a0fc17e63d7bbc4f42f67adaee5c84fa4"></a>
CAF_CORE_EXPORT <a class="el" href="classcaf_1_1config__option.html">config_option</a>&#160;</td><td class="memItemRight" valign="bottom"><b>make_negated_config_option</b> (bool &amp;storage, <a class="el" href="classcaf_1_1string__view.html">string_view</a> category, <a class="el" href="classcaf_1_1string__view.html">string_view</a> name, <a class="el" href="classcaf_1_1string__view.html">string_view</a> description)</td></tr>
<tr class="separator:a0fc17e63d7bbc4f42f67adaee5c84fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fc50bad346bbf957324b87ae11b883"><td class="memTemplParams" colspan="2"><a id="a44fc50bad346bbf957324b87ae11b883" name="a44fc50bad346bbf957324b87ae11b883"></a>
template&lt;class Inspector &gt; </td></tr>
<tr class="memitem:a44fc50bad346bbf957324b87ae11b883"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inspect</b> (Inspector &amp;f, <a class="el" href="classcaf_1_1message__id.html">message_id</a> &amp;x)</td></tr>
<tr class="separator:a44fc50bad346bbf957324b87ae11b883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8547dcdba0e67a7528cfee732f4495a5"><td class="memItemLeft" align="right" valign="top"><a id="a8547dcdba0e67a7528cfee732f4495a5" name="a8547dcdba0e67a7528cfee732f4495a5"></a>
CAF_CORE_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (message_priority)</td></tr>
<tr class="separator:a8547dcdba0e67a7528cfee732f4495a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6020da26e171f9095bcd192028c8e3"><td class="memTemplParams" colspan="2">template&lt;class Self , class Adapter , class Reader &gt; </td></tr>
<tr class="memitem:a3a6020da26e171f9095bcd192028c8e3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a3a6020da26e171f9095bcd192028c8e3">make_mtl</a> (Self *self, Adapter adapter, Reader *reader)</td></tr>
<tr class="memdesc:a3a6020da26e171f9095bcd192028c8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an MTL (message translation layer) to enable an actor to exchange messages with non-CAF endpoints over a user-defined data exchange format such as JSON.  <br /></td></tr>
<tr class="separator:a3a6020da26e171f9095bcd192028c8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f7ffaa9ef319bc1e05fcef2633052d"><td class="memTemplParams" colspan="2"><a id="ab7f7ffaa9ef319bc1e05fcef2633052d" name="ab7f7ffaa9ef319bc1e05fcef2633052d"></a>
template&lt;class Iterator , class Sentinel , class... Ts&gt; </td></tr>
<tr class="memitem:ab7f7ffaa9ef319bc1e05fcef2633052d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_error</b> (const <a class="el" href="structcaf_1_1parser__state.html">parser_state</a>&lt; Iterator, Sentinel &gt; &amp;ps, Ts &amp;&amp;... xs) -&gt; decltype(make_error(ps.code, ps.line, ps.column))</td></tr>
<tr class="memdesc:ab7f7ffaa9ef319bc1e05fcef2633052d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an error object from the current code in <code>ps</code> as well as its current position. <br /></td></tr>
<tr class="separator:ab7f7ffaa9ef319bc1e05fcef2633052d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d07cf08482d87700956ffc887d9ca93"><td class="memTemplParams" colspan="2"><a id="a8d07cf08482d87700956ffc887d9ca93" name="a8d07cf08482d87700956ffc887d9ca93"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a8d07cf08482d87700956ffc887d9ca93"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_result</b> (Ts &amp;&amp;... xs)</td></tr>
<tr class="memdesc:a8d07cf08482d87700956ffc887d9ca93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for wrapping the parameter pack <code>xs...</code> into a <code>result</code>. <br /></td></tr>
<tr class="separator:a8d07cf08482d87700956ffc887d9ca93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781ec52fc5f9fdb5b05e71aadc9e6e81"><td class="memTemplParams" colspan="2"><a id="a781ec52fc5f9fdb5b05e71aadc9e6e81" name="a781ec52fc5f9fdb5b05e71aadc9e6e81"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a781ec52fc5f9fdb5b05e71aadc9e6e81"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; T *, <a class="el" href="classcaf_1_1resumable.html">resumable</a> * &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>intrusive_ptr_add_ref</b> (T *ptr)</td></tr>
<tr class="separator:a781ec52fc5f9fdb5b05e71aadc9e6e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fd4cd4e057da2a28efad07b60157bc"><td class="memTemplParams" colspan="2"><a id="ad8fd4cd4e057da2a28efad07b60157bc" name="ad8fd4cd4e057da2a28efad07b60157bc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad8fd4cd4e057da2a28efad07b60157bc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; T *, <a class="el" href="classcaf_1_1resumable.html">resumable</a> * &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>intrusive_ptr_release</b> (T *ptr)</td></tr>
<tr class="separator:ad8fd4cd4e057da2a28efad07b60157bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee28752a022254b78be77c41b6872599"><td class="memTemplParams" colspan="2"><a id="aee28752a022254b78be77c41b6872599" name="aee28752a022254b78be77c41b6872599"></a>
template&lt;message_priority P = message_priority::normal, class Source  = actor, class Dest  = actor, class... Ts&gt; </td></tr>
<tr class="memitem:aee28752a022254b78be77c41b6872599"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>send_as</b> (const Source &amp;src, const Dest &amp;dest, Ts &amp;&amp;... xs)</td></tr>
<tr class="memdesc:aee28752a022254b78be77c41b6872599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>to</code> a message under the identity of <code>from</code> with priority <code>prio</code>. <br /></td></tr>
<tr class="separator:aee28752a022254b78be77c41b6872599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca65d493124985ab0fe46e24f579608"><td class="memTemplParams" colspan="2"><a id="adca65d493124985ab0fe46e24f579608" name="adca65d493124985ab0fe46e24f579608"></a>
template&lt;message_priority P = message_priority::normal, class Source , class Dest , class... Ts&gt; </td></tr>
<tr class="memitem:adca65d493124985ab0fe46e24f579608"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unsafe_send_as</b> (Source *src, const Dest &amp;dest, Ts &amp;&amp;... xs)</td></tr>
<tr class="separator:adca65d493124985ab0fe46e24f579608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1972d233b7fa111caf969b9beecbb3d2"><td class="memTemplParams" colspan="2"><a id="a1972d233b7fa111caf969b9beecbb3d2" name="a1972d233b7fa111caf969b9beecbb3d2"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a1972d233b7fa111caf969b9beecbb3d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unsafe_response</b> (<a class="el" href="classcaf_1_1local__actor.html">local_actor</a> *self, <a class="el" href="classcaf_1_1intrusive__ptr.html">strong_actor_ptr</a> src, std::vector&lt; <a class="el" href="classcaf_1_1intrusive__ptr.html">strong_actor_ptr</a> &gt; stages, <a class="el" href="classcaf_1_1message__id.html">message_id</a> mid, Ts &amp;&amp;... xs)</td></tr>
<tr class="separator:a1972d233b7fa111caf969b9beecbb3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5095ca2b0cf495346a45e3385ae603c1"><td class="memTemplParams" colspan="2"><a id="a5095ca2b0cf495346a45e3385ae603c1" name="a5095ca2b0cf495346a45e3385ae603c1"></a>
template&lt;message_priority P = message_priority::normal, class Dest  = actor, class... Ts&gt; </td></tr>
<tr class="memitem:a5095ca2b0cf495346a45e3385ae603c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>anon_send</b> (const Dest &amp;dest, Ts &amp;&amp;... xs)</td></tr>
<tr class="memdesc:a5095ca2b0cf495346a45e3385ae603c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anonymously sends <code>dest</code> a message. <br /></td></tr>
<tr class="separator:a5095ca2b0cf495346a45e3385ae603c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4875a6164f38470b53ebdba87bce53d"><td class="memTemplParams" colspan="2"><a id="ab4875a6164f38470b53ebdba87bce53d" name="ab4875a6164f38470b53ebdba87bce53d"></a>
template&lt;message_priority P = message_priority::normal, class Dest  = actor, class Rep  = int, class Period  = std::ratio&lt;1&gt;, class... Ts&gt; </td></tr>
<tr class="memitem:ab4875a6164f38470b53ebdba87bce53d"><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_t&lt;!std::is_same&lt; Dest, group &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>delayed_anon_send</b> (const Dest &amp;dest, std::chrono::duration&lt; Rep, Period &gt; rtime, Ts &amp;&amp;... xs)</td></tr>
<tr class="separator:ab4875a6164f38470b53ebdba87bce53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98fdfb5712096e46d16b8c5aa2a0067"><td class="memTemplParams" colspan="2"><a id="ae98fdfb5712096e46d16b8c5aa2a0067" name="ae98fdfb5712096e46d16b8c5aa2a0067"></a>
template&lt;class Rep  = int, class Period  = std::ratio&lt;1&gt;, class... Ts&gt; </td></tr>
<tr class="memitem:ae98fdfb5712096e46d16b8c5aa2a0067"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>delayed_anon_send</b> (const group &amp;dest, std::chrono::duration&lt; Rep, Period &gt; rtime, Ts &amp;&amp;... xs)</td></tr>
<tr class="separator:ae98fdfb5712096e46d16b8c5aa2a0067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125b7391a3206d3243e34ca01ed21bba"><td class="memTemplParams" colspan="2"><a id="a125b7391a3206d3243e34ca01ed21bba" name="a125b7391a3206d3243e34ca01ed21bba"></a>
template&lt;class Dest &gt; </td></tr>
<tr class="memitem:a125b7391a3206d3243e34ca01ed21bba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>anon_send_exit</b> (const Dest &amp;dest, <a class="el" href="namespacecaf.html#a72ed789d5a799ff8eab4697604ae5784">exit_reason</a> reason)</td></tr>
<tr class="memdesc:a125b7391a3206d3243e34ca01ed21bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anonymously sends <code>dest</code> an exit message. <br /></td></tr>
<tr class="separator:a125b7391a3206d3243e34ca01ed21bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631d9dbfe4e073d70d0eff5116aef1f6"><td class="memItemLeft" align="right" valign="top"><a id="a631d9dbfe4e073d70d0eff5116aef1f6" name="a631d9dbfe4e073d70d0eff5116aef1f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>anon_send_exit</b> (const <a class="el" href="classcaf_1_1actor__addr.html">actor_addr</a> &amp;to, <a class="el" href="namespacecaf.html#a72ed789d5a799ff8eab4697604ae5784">exit_reason</a> reason)</td></tr>
<tr class="memdesc:a631d9dbfe4e073d70d0eff5116aef1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anonymously sends <code>to</code> an exit message. <br /></td></tr>
<tr class="separator:a631d9dbfe4e073d70d0eff5116aef1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10337617b8e4a9de6b8e76916388d22e"><td class="memItemLeft" align="right" valign="top"><a id="a10337617b8e4a9de6b8e76916388d22e" name="a10337617b8e4a9de6b8e76916388d22e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>anon_send_exit</b> (const <a class="el" href="classcaf_1_1weak__intrusive__ptr.html">weak_actor_ptr</a> &amp;to, <a class="el" href="namespacecaf.html#a72ed789d5a799ff8eab4697604ae5784">exit_reason</a> reason)</td></tr>
<tr class="memdesc:a10337617b8e4a9de6b8e76916388d22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anonymously sends <code>to</code> an exit message. <br /></td></tr>
<tr class="separator:a10337617b8e4a9de6b8e76916388d22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55f287d51075c5edac2fdc9a683c7d4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac55f287d51075c5edac2fdc9a683c7d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1config__value.html">config_value</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#ac55f287d51075c5edac2fdc9a683c7d4">put</a> (<a class="el" href="classcaf_1_1dictionary.html">settings</a> &amp;dict, <a class="el" href="classcaf_1_1string__view.html">string_view</a> key, T &amp;&amp;value)</td></tr>
<tr class="memdesc:ac55f287d51075c5edac2fdc9a683c7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>value</code> to a <code><a class="el" href="classcaf_1_1config__value.html" title="A type for config parameters with similar interface to a variant.">config_value</a></code> and assigns it to <code>key</code>.  <br /></td></tr>
<tr class="separator:ac55f287d51075c5edac2fdc9a683c7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8002dc38e09d902866cadbe8072ba7fa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8002dc38e09d902866cadbe8072ba7fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a8002dc38e09d902866cadbe8072ba7fa">put_missing</a> (<a class="el" href="classcaf_1_1dictionary.html">settings</a> &amp;xs, <a class="el" href="classcaf_1_1string__view.html">string_view</a> key, T &amp;&amp;value)</td></tr>
<tr class="memdesc:a8002dc38e09d902866cadbe8072ba7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>value</code> to a <code><a class="el" href="classcaf_1_1config__value.html" title="A type for config parameters with similar interface to a variant.">config_value</a></code> and assigns it to <code>key</code> unless <code>xs</code> already contains <code>key</code> (does nothing in this case).  <br /></td></tr>
<tr class="separator:a8002dc38e09d902866cadbe8072ba7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5fdd857461d9a91e1eee478fa27f9c"><td class="memItemLeft" align="right" valign="top">CAF_CORE_EXPORT config_value::list &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a9b5fdd857461d9a91e1eee478fa27f9c">put_list</a> (<a class="el" href="classcaf_1_1dictionary.html">settings</a> &amp;xs, std::string name)</td></tr>
<tr class="memdesc:a9b5fdd857461d9a91e1eee478fa27f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new list named <code>name</code> into the dictionary <code>xs</code> and returns a reference to it.  <br /></td></tr>
<tr class="separator:a9b5fdd857461d9a91e1eee478fa27f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa029eb47370d782d02a9cad74a1a993b"><td class="memItemLeft" align="right" valign="top">CAF_CORE_EXPORT <a class="el" href="classcaf_1_1dictionary.html">config_value::dictionary</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#aa029eb47370d782d02a9cad74a1a993b">put_dictionary</a> (<a class="el" href="classcaf_1_1dictionary.html">settings</a> &amp;xs, std::string name)</td></tr>
<tr class="memdesc:aa029eb47370d782d02a9cad74a1a993b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new list named <code>name</code> into the dictionary <code>xs</code> and returns a reference to it.  <br /></td></tr>
<tr class="separator:aa029eb47370d782d02a9cad74a1a993b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ee8d899727174b1f000dcb7eef5ca9"><td class="memTemplParams" colspan="2"><a id="ad3ee8d899727174b1f000dcb7eef5ca9" name="ad3ee8d899727174b1f000dcb7eef5ca9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad3ee8d899727174b1f000dcb7eef5ca9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>begin</b> (const <a class="el" href="classcaf_1_1span.html">span</a>&lt; T &gt; &amp;xs) -&gt; decltype(xs.begin())</td></tr>
<tr class="separator:ad3ee8d899727174b1f000dcb7eef5ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56ef7834ff7dd3c4ef3a14187fd22d5"><td class="memTemplParams" colspan="2"><a id="af56ef7834ff7dd3c4ef3a14187fd22d5" name="af56ef7834ff7dd3c4ef3a14187fd22d5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af56ef7834ff7dd3c4ef3a14187fd22d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cbegin</b> (const <a class="el" href="classcaf_1_1span.html">span</a>&lt; T &gt; &amp;xs) -&gt; decltype(xs.cbegin())</td></tr>
<tr class="separator:af56ef7834ff7dd3c4ef3a14187fd22d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b8597b883ccbd47c68026657d1784b"><td class="memTemplParams" colspan="2"><a id="a63b8597b883ccbd47c68026657d1784b" name="a63b8597b883ccbd47c68026657d1784b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a63b8597b883ccbd47c68026657d1784b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>end</b> (const <a class="el" href="classcaf_1_1span.html">span</a>&lt; T &gt; &amp;xs) -&gt; decltype(xs.end())</td></tr>
<tr class="separator:a63b8597b883ccbd47c68026657d1784b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa6326c67c85eba007377eda5fba9d7"><td class="memTemplParams" colspan="2"><a id="adfa6326c67c85eba007377eda5fba9d7" name="adfa6326c67c85eba007377eda5fba9d7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adfa6326c67c85eba007377eda5fba9d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cend</b> (const <a class="el" href="classcaf_1_1span.html">span</a>&lt; T &gt; &amp;xs) -&gt; decltype(xs.cend())</td></tr>
<tr class="separator:adfa6326c67c85eba007377eda5fba9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a392cb681415f2a0d77f2d01b53410c"><td class="memTemplParams" colspan="2"><a id="a6a392cb681415f2a0d77f2d01b53410c" name="a6a392cb681415f2a0d77f2d01b53410c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6a392cb681415f2a0d77f2d01b53410c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1span.html">span</a>&lt; const <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_bytes</b> (<a class="el" href="classcaf_1_1span.html">span</a>&lt; T &gt; xs)</td></tr>
<tr class="separator:a6a392cb681415f2a0d77f2d01b53410c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c3a885b78c992e1701287e01ee00cc"><td class="memTemplParams" colspan="2"><a id="af1c3a885b78c992e1701287e01ee00cc" name="af1c3a885b78c992e1701287e01ee00cc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af1c3a885b78c992e1701287e01ee00cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1span.html">span</a>&lt; <a class="el" href="namespacecaf.html#a6dba2c3f22c13a600261c9122becd7dd">byte</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_writable_bytes</b> (<a class="el" href="classcaf_1_1span.html">span</a>&lt; T &gt; xs)</td></tr>
<tr class="separator:af1c3a885b78c992e1701287e01ee00cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5731e52ad65b6eb7a847e04a82e63ff"><td class="memTemplParams" colspan="2"><a id="ab5731e52ad65b6eb7a847e04a82e63ff" name="ab5731e52ad65b6eb7a847e04a82e63ff"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab5731e52ad65b6eb7a847e04a82e63ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_span</b> (T &amp;xs) -&gt; <a class="el" href="classcaf_1_1span.html">span</a>&lt; detail::remove_reference_t&lt; decltype(xs[0])&gt; &gt;</td></tr>
<tr class="memdesc:ab5731e52ad65b6eb7a847e04a82e63ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to make using <code><a class="el" href="classcaf_1_1span.html" title="A C++11/14 drop-in replacement for C++20&#39;s std::span without support for static extents.">caf::span</a></code> more convenient without the deduction guides. <br /></td></tr>
<tr class="separator:ab5731e52ad65b6eb7a847e04a82e63ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51c819f7a11f7f049012a53004dde02"><td class="memTemplParams" colspan="2"><a id="af51c819f7a11f7f049012a53004dde02" name="af51c819f7a11f7f049012a53004dde02"></a>
template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:af51c819f7a11f7f049012a53004dde02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1span.html">span</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_span</b> (T(&amp;xs)[N])</td></tr>
<tr class="memdesc:af51c819f7a11f7f049012a53004dde02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to make using <code><a class="el" href="classcaf_1_1span.html" title="A C++11/14 drop-in replacement for C++20&#39;s std::span without support for static extents.">caf::span</a></code> more convenient without the deduction guides. <br /></td></tr>
<tr class="separator:af51c819f7a11f7f049012a53004dde02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c926b6d0448fc85ed215ad0548cc4f1"><td class="memTemplParams" colspan="2"><a id="a1c926b6d0448fc85ed215ad0548cc4f1" name="a1c926b6d0448fc85ed215ad0548cc4f1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1c926b6d0448fc85ed215ad0548cc4f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1span.html">span</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_span</b> (T *first, size_t size)</td></tr>
<tr class="memdesc:a1c926b6d0448fc85ed215ad0548cc4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to make using <code><a class="el" href="classcaf_1_1span.html" title="A C++11/14 drop-in replacement for C++20&#39;s std::span without support for static extents.">caf::span</a></code> more convenient without the deduction guides. <br /></td></tr>
<tr class="separator:a1c926b6d0448fc85ed215ad0548cc4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7627625966e278331514a160f740ebd2"><td class="memTemplParams" colspan="2"><a id="a7627625966e278331514a160f740ebd2" name="a7627625966e278331514a160f740ebd2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7627625966e278331514a160f740ebd2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1span.html">span</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_span</b> (T *first, T *last)</td></tr>
<tr class="memdesc:a7627625966e278331514a160f740ebd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to make using <code><a class="el" href="classcaf_1_1span.html" title="A C++11/14 drop-in replacement for C++20&#39;s std::span without support for static extents.">caf::span</a></code> more convenient without the deduction guides. <br /></td></tr>
<tr class="separator:a7627625966e278331514a160f740ebd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd9d6b3e5da22eec85ea53017bfe3b4a"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a> x, <a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a> y)</td></tr>
<tr class="memdesc:gabd9d6b3e5da22eec85ea53017bfe3b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two <code><a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a></code>. <br /></td></tr>
<tr class="separator:gabd9d6b3e5da22eec85ea53017bfe3b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b53befb13f6a6dc99e3d62db70f6555"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_spawn_option</b> (<a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a> haystack, <a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a> needle)</td></tr>
<tr class="memdesc:ga4b53befb13f6a6dc99e3d62db70f6555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>haystack</code> contains <code>needle</code>. <br /></td></tr>
<tr class="separator:ga4b53befb13f6a6dc99e3d62db70f6555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90e0bd3ebbd63a168b8ed079fac1856f"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_detach_flag</b> (<a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a> opts)</td></tr>
<tr class="memdesc:ga90e0bd3ebbd63a168b8ed079fac1856f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the <code><a class="el" href="group___actor_creation.html#ga2555e866af2cb032aabd9a506ac191bd">detached</a></code> flag is set in <code>opts</code>. <br /></td></tr>
<tr class="separator:ga90e0bd3ebbd63a168b8ed079fac1856f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41ce2ca3cd55adff0fa818f57dd259ab"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_priority_aware_flag</b> (<a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a>)</td></tr>
<tr class="memdesc:ga41ce2ca3cd55adff0fa818f57dd259ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the <code><a class="el" href="">priority_aware</a></code> flag is set in <code>opts</code>. <br /></td></tr>
<tr class="separator:ga41ce2ca3cd55adff0fa818f57dd259ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a61a67ad27915e97eeb83c3a2f90a77"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_hide_flag</b> (<a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a> opts)</td></tr>
<tr class="memdesc:ga3a61a67ad27915e97eeb83c3a2f90a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the <code><a class="el" href="group___actor_creation.html#gac7b5c96cbf488921f9871ff46b0ea877">hidden</a></code> flag is set in <code>opts</code>. <br /></td></tr>
<tr class="separator:ga3a61a67ad27915e97eeb83c3a2f90a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2622be71c5f4757dc02c95d7f554e1b5"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_link_flag</b> (<a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a> opts)</td></tr>
<tr class="memdesc:ga2622be71c5f4757dc02c95d7f554e1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the <code><a class="el" href="group___actor_creation.html#ga6c2e380b48f98c44b7311bd0725456d5">linked</a></code> flag is set in <code>opts</code>. <br /></td></tr>
<tr class="separator:ga2622be71c5f4757dc02c95d7f554e1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97785492b8ff6bb7bc908a43dbf14165"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_monitor_flag</b> (<a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a> opts)</td></tr>
<tr class="memdesc:ga97785492b8ff6bb7bc908a43dbf14165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the <code><a class="el" href="group___actor_creation.html#ga197ff1f076793001295b672ab23790a2">monitored</a></code> flag is set in <code>opts</code>. <br /></td></tr>
<tr class="separator:ga97785492b8ff6bb7bc908a43dbf14165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a83f81fc67957df87596f813159ba4"><td class="memItemLeft" align="right" valign="top">
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_lazy_init_flag</b> (<a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a> opts)</td></tr>
<tr class="memdesc:gac1a83f81fc67957df87596f813159ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the <code><a class="el" href="group___actor_creation.html#gaa320e439df44a8f73da7e5a975cce7d2">lazy_init</a></code> flag is set in <code>opts</code>. <br /></td></tr>
<tr class="separator:gac1a83f81fc67957df87596f813159ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d90bdead17e87f3e7604096ee097f8"><td class="memItemLeft" align="right" valign="top"><a id="a52d90bdead17e87f3e7604096ee097f8" name="a52d90bdead17e87f3e7604096ee097f8"></a>
CAF_CORE_EXPORT attachable_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>make_stream_aborter</b> (<a class="el" href="classcaf_1_1actor__addr.html">actor_addr</a> observed, <a class="el" href="classcaf_1_1actor__addr.html">actor_addr</a> observer, <a class="el" href="namespacecaf.html#a5e4e3f547c07339f44ef90acdd11a1fe">stream_slot</a> slot, stream_aborter::mode m)</td></tr>
<tr class="separator:a52d90bdead17e87f3e7604096ee097f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730e193e3a097f8ac1df11fb8feb793b"><td class="memItemLeft" align="right" valign="top"><a id="a730e193e3a097f8ac1df11fb8feb793b" name="a730e193e3a097f8ac1df11fb8feb793b"></a>
constexpr <a class="el" href="classcaf_1_1string__view.html">string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_any_of</b> (<a class="el" href="classcaf_1_1string__view.html">string_view</a> arg) noexcept</td></tr>
<tr class="separator:a730e193e3a097f8ac1df11fb8feb793b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded7bd6a81236fcccf23b5849fc90b53"><td class="memItemLeft" align="right" valign="top"><a id="aded7bd6a81236fcccf23b5849fc90b53" name="aded7bd6a81236fcccf23b5849fc90b53"></a>
CAF_CORE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>split</b> (std::vector&lt; std::string &gt; &amp;<a class="el" href="classcaf_1_1result.html">result</a>, <a class="el" href="classcaf_1_1string__view.html">string_view</a> str, <a class="el" href="classcaf_1_1string__view.html">string_view</a> delims, bool keep_all=true)</td></tr>
<tr class="separator:aded7bd6a81236fcccf23b5849fc90b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad487816970e9fa2ab526e8d93b77ce74"><td class="memItemLeft" align="right" valign="top"><a id="ad487816970e9fa2ab526e8d93b77ce74" name="ad487816970e9fa2ab526e8d93b77ce74"></a>
CAF_CORE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>split</b> (std::vector&lt; <a class="el" href="classcaf_1_1string__view.html">string_view</a> &gt; &amp;<a class="el" href="classcaf_1_1result.html">result</a>, <a class="el" href="classcaf_1_1string__view.html">string_view</a> str, <a class="el" href="classcaf_1_1string__view.html">string_view</a> delims, bool keep_all=true)</td></tr>
<tr class="separator:ad487816970e9fa2ab526e8d93b77ce74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15cd3e1b4f4f279f6172599a472fef4"><td class="memItemLeft" align="right" valign="top"><a id="aa15cd3e1b4f4f279f6172599a472fef4" name="aa15cd3e1b4f4f279f6172599a472fef4"></a>
CAF_CORE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>split</b> (std::vector&lt; std::string &gt; &amp;<a class="el" href="classcaf_1_1result.html">result</a>, <a class="el" href="classcaf_1_1string__view.html">string_view</a> str, char delim, bool keep_all=true)</td></tr>
<tr class="separator:aa15cd3e1b4f4f279f6172599a472fef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9616cfffd9bd7616b5e3863457a311"><td class="memItemLeft" align="right" valign="top"><a id="aee9616cfffd9bd7616b5e3863457a311" name="aee9616cfffd9bd7616b5e3863457a311"></a>
CAF_CORE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>split</b> (std::vector&lt; <a class="el" href="classcaf_1_1string__view.html">string_view</a> &gt; &amp;<a class="el" href="classcaf_1_1result.html">result</a>, <a class="el" href="classcaf_1_1string__view.html">string_view</a> str, char delim, bool keep_all=true)</td></tr>
<tr class="separator:aee9616cfffd9bd7616b5e3863457a311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b5ad7e1bec481f732d553ae10177f9"><td class="memTemplParams" colspan="2"><a id="ac8b5ad7e1bec481f732d553ae10177f9" name="ac8b5ad7e1bec481f732d553ae10177f9"></a>
template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:ac8b5ad7e1bec481f732d553ae10177f9"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>join</b> (InputIterator first, InputIterator last, <a class="el" href="classcaf_1_1string__view.html">string_view</a> glue)</td></tr>
<tr class="separator:ac8b5ad7e1bec481f732d553ae10177f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae555e9f2e41088169f17e4572c2a6253"><td class="memTemplParams" colspan="2"><a id="ae555e9f2e41088169f17e4572c2a6253" name="ae555e9f2e41088169f17e4572c2a6253"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:ae555e9f2e41088169f17e4572c2a6253"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>join</b> (const Container &amp;c, <a class="el" href="classcaf_1_1string__view.html">string_view</a> glue)</td></tr>
<tr class="separator:ae555e9f2e41088169f17e4572c2a6253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14aa6a04c644fcc6cc79430308d3ffc7"><td class="memItemLeft" align="right" valign="top"><a id="a14aa6a04c644fcc6cc79430308d3ffc7" name="a14aa6a04c644fcc6cc79430308d3ffc7"></a>
CAF_CORE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>replace_all</b> (std::string &amp;str, <a class="el" href="classcaf_1_1string__view.html">string_view</a> what, <a class="el" href="classcaf_1_1string__view.html">string_view</a> with)</td></tr>
<tr class="memdesc:a14aa6a04c644fcc6cc79430308d3ffc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of <code>what</code> by <code>with</code> in <code>str</code>. <br /></td></tr>
<tr class="separator:a14aa6a04c644fcc6cc79430308d3ffc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e124d1991623741534c168c8da0ffc"><td class="memItemLeft" align="right" valign="top"><a id="af6e124d1991623741534c168c8da0ffc" name="af6e124d1991623741534c168c8da0ffc"></a>
CAF_CORE_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><b>starts_with</b> (<a class="el" href="classcaf_1_1string__view.html">string_view</a> str, <a class="el" href="classcaf_1_1string__view.html">string_view</a> prefix)</td></tr>
<tr class="memdesc:af6e124d1991623741534c168c8da0ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <code>str</code> begins with <code>prefix</code>. <br /></td></tr>
<tr class="separator:af6e124d1991623741534c168c8da0ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0078d0f0f6816b51ff73c401c2b826"><td class="memItemLeft" align="right" valign="top"><a id="aec0078d0f0f6816b51ff73c401c2b826" name="aec0078d0f0f6816b51ff73c401c2b826"></a>
CAF_CORE_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><b>ends_with</b> (<a class="el" href="classcaf_1_1string__view.html">string_view</a> str, <a class="el" href="classcaf_1_1string__view.html">string_view</a> suffix)</td></tr>
<tr class="memdesc:aec0078d0f0f6816b51ff73c401c2b826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <code>str</code> ends with <code>suffix</code>. <br /></td></tr>
<tr class="separator:aec0078d0f0f6816b51ff73c401c2b826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccdfb8613c0451145d3ebcf1f02d8625"><td class="memTemplParams" colspan="2">
template&lt;class T &gt; </td></tr>
<tr class="memitem:gaccdfb8613c0451145d3ebcf1f02d8625"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SumType</b> ()</td></tr>
<tr class="memdesc:gaccdfb8613c0451145d3ebcf1f02d8625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for checking whether <code>T</code> supports the sum type API by specializing <code><a class="el" href="structcaf_1_1sum__type__access.html" title="Specializing this trait allows users to enable holds_alternative, get, get_if, and visit for any user...">sum_type_access</a></code>. <br /></td></tr>
<tr class="separator:gaccdfb8613c0451145d3ebcf1f02d8625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbddf9962cf277b6558e1b49b578a134"><td class="memTemplParams" colspan="2">
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:gabbddf9962cf277b6558e1b49b578a134"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SumTypes</b> ()</td></tr>
<tr class="memdesc:gabbddf9962cf277b6558e1b49b578a134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for checking whether all <code>Ts</code> support the sum type API by specializing <code><a class="el" href="structcaf_1_1sum__type__access.html" title="Specializing this trait allows users to enable holds_alternative, get, get_if, and visit for any user...">sum_type_access</a></code>. <br /></td></tr>
<tr class="separator:gabbddf9962cf277b6558e1b49b578a134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82abc5f022cb053804988b7a6c57c192"><td class="memTemplParams" colspan="2">
template&lt;class Trait , class T &gt; </td></tr>
<tr class="memitem:ga82abc5f022cb053804988b7a6c57c192"><td class="memTemplItemLeft" align="right" valign="top">constexpr sum_type_token&lt; T, sum_type_index&lt; Trait, T &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_sum_type_token</b> ()</td></tr>
<tr class="separator:ga82abc5f022cb053804988b7a6c57c192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a583c63df0d4e85047aae61dac2ea95"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class Trait  = sum_type_access&lt;U&gt;&gt; </td></tr>
<tr class="memitem:ga8a583c63df0d4e85047aae61dac2ea95"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___sum_type.html#ga8a583c63df0d4e85047aae61dac2ea95">get</a> (U &amp;x) -&gt; decltype(Trait::get(x, make_sum_type_token&lt; Trait, T &gt;()))</td></tr>
<tr class="memdesc:ga8a583c63df0d4e85047aae61dac2ea95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the value of a sum type.  <br /></td></tr>
<tr class="separator:ga8a583c63df0d4e85047aae61dac2ea95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331d23545196453019da955f5625ffb6"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class Trait  = sum_type_access&lt;U&gt;&gt; </td></tr>
<tr class="memitem:ga331d23545196453019da955f5625ffb6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___sum_type.html#ga331d23545196453019da955f5625ffb6">get</a> (const U &amp;x) -&gt; decltype(Trait::get(x, make_sum_type_token&lt; Trait, T &gt;()))</td></tr>
<tr class="memdesc:ga331d23545196453019da955f5625ffb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the value of a sum type.  <br /></td></tr>
<tr class="separator:ga331d23545196453019da955f5625ffb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf73f90cf7fdde44301991aeaedb91916"><td class="memTemplParams" colspan="2">
template&lt;class T , class U , class Trait  = sum_type_access&lt;U&gt;&gt; </td></tr>
<tr class="memitem:gaf73f90cf7fdde44301991aeaedb91916"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_if</b> (U *x) -&gt; decltype(Trait::get_if(x, make_sum_type_token&lt; Trait, T &gt;()))</td></tr>
<tr class="memdesc:gaf73f90cf7fdde44301991aeaedb91916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the value of a sum type if it is of type <code>T</code>, <code>nullptr</code> otherwise. <br /></td></tr>
<tr class="separator:gaf73f90cf7fdde44301991aeaedb91916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2c08ee6a67c6bd83885f65be9159b35"><td class="memTemplParams" colspan="2">
template&lt;class T , class U , class Trait  = sum_type_access&lt;U&gt;&gt; </td></tr>
<tr class="memitem:gac2c08ee6a67c6bd83885f65be9159b35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_if</b> (const U *x) -&gt; decltype(Trait::get_if(x, make_sum_type_token&lt; Trait, T &gt;()))</td></tr>
<tr class="memdesc:gac2c08ee6a67c6bd83885f65be9159b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the value of a sum type if it is of type <code>T</code>, <code>nullptr</code> otherwise. <br /></td></tr>
<tr class="separator:gac2c08ee6a67c6bd83885f65be9159b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1439a06e73cbf999195ba94639dc1903"><td class="memTemplParams" colspan="2">
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ga1439a06e73cbf999195ba94639dc1903"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>holds_alternative</b> (const U &amp;x)</td></tr>
<tr class="memdesc:ga1439a06e73cbf999195ba94639dc1903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a sum type has a value of type <code>T</code>. <br /></td></tr>
<tr class="separator:ga1439a06e73cbf999195ba94639dc1903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2d23eaf35077919b86fc07a1da7014f"><td class="memTemplParams" colspan="2">
template&lt;class Visitor , class T , class... Ts, class Result  = sum_type_visit_result_t&lt;Visitor, T, Ts...&gt;&gt; </td></tr>
<tr class="memitem:gaa2d23eaf35077919b86fc07a1da7014f"><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_t&lt; <a class="el" href="group___sum_type.html#gabbddf9962cf277b6558e1b49b578a134">SumTypes</a>&lt; T, Ts... &gt;(), Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit</b> (Visitor &amp;&amp;f, T &amp;&amp;x, Ts &amp;&amp;... xs)</td></tr>
<tr class="memdesc:gaa2d23eaf35077919b86fc07a1da7014f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the values of any number of sum types to the visitor. <br /></td></tr>
<tr class="separator:gaa2d23eaf35077919b86fc07a1da7014f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bfe149cb96409067ba3bc19f17dc3c"><td class="memTemplParams" colspan="2"><a id="a36bfe149cb96409067ba3bc19f17dc3c" name="a36bfe149cb96409067ba3bc19f17dc3c"></a>
template&lt;class T , int Pos&gt; </td></tr>
<tr class="memitem:a36bfe149cb96409067ba3bc19f17dc3c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::integral_constant&lt; int, Pos &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pos</b> (sum_type_token&lt; T, Pos &gt;)</td></tr>
<tr class="separator:a36bfe149cb96409067ba3bc19f17dc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11468e352b84ccfe26be2f57eefcd390"><td class="memItemLeft" align="right" valign="top"><a id="a11468e352b84ccfe26be2f57eefcd390" name="a11468e352b84ccfe26be2f57eefcd390"></a>
CAF_CORE_EXPORT std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, <a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccc">term</a> x)</td></tr>
<tr class="separator:a11468e352b84ccfe26be2f57eefcd390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec7e847ba16b09eadd119adedd1b21c"><td class="memItemLeft" align="right" valign="top"><a id="aeec7e847ba16b09eadd119adedd1b21c" name="aeec7e847ba16b09eadd119adedd1b21c"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_infinite</b> (<a class="el" href="namespacecaf.html#adc3db7177cb06bf8d5bfd2df387729d4">timespan</a> value)</td></tr>
<tr class="memdesc:aeec7e847ba16b09eadd119adedd1b21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>value</code> represents an infinite amount of time. <br /></td></tr>
<tr class="separator:aeec7e847ba16b09eadd119adedd1b21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3974470b33f9b34505395e71be98d48d"><td class="memItemLeft" align="right" valign="top"><a id="a3974470b33f9b34505395e71be98d48d" name="a3974470b33f9b34505395e71be98d48d"></a>
CAF_CORE_EXPORT <a class="el" href="namespacecaf.html#a04add1a401710dc6f24029aab294b9b7">timestamp</a>&#160;</td><td class="memItemRight" valign="bottom"><b>make_timestamp</b> ()</td></tr>
<tr class="memdesc:a3974470b33f9b34505395e71be98d48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for returning a <code>timestamp</code> representing the current system time. <br /></td></tr>
<tr class="separator:a3974470b33f9b34505395e71be98d48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08d72d161a3f122b7575372ea585106"><td class="memItemLeft" align="right" valign="top"><a id="aa08d72d161a3f122b7575372ea585106" name="aa08d72d161a3f122b7575372ea585106"></a>
CAF_CORE_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><b>timestamp_to_string</b> (<a class="el" href="namespacecaf.html#a04add1a401710dc6f24029aab294b9b7">timestamp</a> x)</td></tr>
<tr class="memdesc:aa08d72d161a3f122b7575372ea585106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints <code>x</code> in ISO 8601 format, e.g., <code>2018-11-15T06:25:01.462</code>. <br /></td></tr>
<tr class="separator:aa08d72d161a3f122b7575372ea585106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada229949e64f68f39c8ad4f66a5468c3"><td class="memItemLeft" align="right" valign="top"><a id="ada229949e64f68f39c8ad4f66a5468c3" name="ada229949e64f68f39c8ad4f66a5468c3"></a>
CAF_CORE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>append_timestamp_to_string</b> (std::string &amp;x, <a class="el" href="namespacecaf.html#a04add1a401710dc6f24029aab294b9b7">timestamp</a> y)</td></tr>
<tr class="memdesc:ada229949e64f68f39c8ad4f66a5468c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the timestamp <code>x</code> in ISO 8601 format, e.g., <code>2018-11-15T06:25:01.462</code>, to <code>y</code>. <br /></td></tr>
<tr class="separator:ada229949e64f68f39c8ad4f66a5468c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfec060cd56dddef3fc243be02e78f18"><td class="memTemplParams" colspan="2"><a id="abfec060cd56dddef3fc243be02e78f18" name="abfec060cd56dddef3fc243be02e78f18"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abfec060cd56dddef3fc243be02e78f18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1string__view.html">string_view</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>type_name_or_anonymous</b> ()</td></tr>
<tr class="memdesc:abfec060cd56dddef3fc243be02e78f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>type_name_v&lt;T&gt;</code> if available, "anonymous" otherwise. <br /></td></tr>
<tr class="separator:abfec060cd56dddef3fc243be02e78f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9118fa35206ce330745240016ecee9ca"><td class="memTemplParams" colspan="2"><a id="a9118fa35206ce330745240016ecee9ca" name="a9118fa35206ce330745240016ecee9ca"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9118fa35206ce330745240016ecee9ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecaf.html#a44855080188b6693187137bd666c7eb4">type_id_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>type_id_or_invalid</b> ()</td></tr>
<tr class="memdesc:a9118fa35206ce330745240016ecee9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>type_id_v&lt;T&gt;</code> if available, <code>invalid_type_id</code> otherwise. <br /></td></tr>
<tr class="separator:a9118fa35206ce330745240016ecee9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba8e7df0f06ba2accee7b240b2e27a4"><td class="memItemLeft" align="right" valign="top"><a id="adba8e7df0f06ba2accee7b240b2e27a4" name="adba8e7df0f06ba2accee7b240b2e27a4"></a>
CAF_CORE_EXPORT <a class="el" href="classcaf_1_1string__view.html">string_view</a>&#160;</td><td class="memItemRight" valign="bottom"><b>query_type_name</b> (<a class="el" href="namespacecaf.html#a44855080188b6693187137bd666c7eb4">type_id_t</a> type)</td></tr>
<tr class="memdesc:adba8e7df0f06ba2accee7b240b2e27a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type name of given <code>type</code> or an empty string if <code>type</code> is an invalid ID. <br /></td></tr>
<tr class="separator:adba8e7df0f06ba2accee7b240b2e27a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98b1008d4ffdc0507cbc6f7879a213b"><td class="memItemLeft" align="right" valign="top"><a id="ab98b1008d4ffdc0507cbc6f7879a213b" name="ab98b1008d4ffdc0507cbc6f7879a213b"></a>
CAF_CORE_EXPORT <a class="el" href="namespacecaf.html#a44855080188b6693187137bd666c7eb4">type_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>query_type_id</b> (<a class="el" href="classcaf_1_1string__view.html">string_view</a> name)</td></tr>
<tr class="memdesc:ab98b1008d4ffdc0507cbc6f7879a213b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of given <code>name</code> or <code>invalid_type_id</code> if no type matches. <br /></td></tr>
<tr class="separator:ab98b1008d4ffdc0507cbc6f7879a213b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c47469220e21a276af8e7d4608348f"><td class="memTemplParams" colspan="2"><a id="a24c47469220e21a276af8e7d4608348f" name="a24c47469220e21a276af8e7d4608348f"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a24c47469220e21a276af8e7d4608348f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1type__id__list.html">type_id_list</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>types_of</b> (const std::tuple&lt; Ts... &gt; &amp;)</td></tr>
<tr class="separator:a24c47469220e21a276af8e7d4608348f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0079f80484551c985de070948745c7"><td class="memTemplParams" colspan="2"><a id="a6b0079f80484551c985de070948745c7" name="a6b0079f80484551c985de070948745c7"></a>
template&lt;class... Fs&gt; </td></tr>
<tr class="memitem:a6b0079f80484551c985de070948745c7"><td class="memTemplItemLeft" align="right" valign="top">typed_behavior&lt; <a class="el" href="namespacecaf.html#a5e9c4fbee59d5d10b359bd7d827d3017">deduce_mpi_t</a>&lt; Fs &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_typed_behavior</b> (Fs... fs)</td></tr>
<tr class="memdesc:a6b0079f80484551c985de070948745c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a typed behavior from given function objects. <br /></td></tr>
<tr class="separator:a6b0079f80484551c985de070948745c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9de476bcfe1ca33daad5dd568f6aab9"><td class="memTemplParams" colspan="2"><a id="ad9de476bcfe1ca33daad5dd568f6aab9" name="ad9de476bcfe1ca33daad5dd568f6aab9"></a>
template&lt;size_t Index, class... Ts&gt; </td></tr>
<tr class="memitem:ad9de476bcfe1ca33daad5dd568f6aab9"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (typed_message_view&lt; Ts... &gt; x)</td></tr>
<tr class="separator:ad9de476bcfe1ca33daad5dd568f6aab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d1fb77ae9bf3fa0821965aacd55272"><td class="memTemplParams" colspan="2"><a id="a39d1fb77ae9bf3fa0821965aacd55272" name="a39d1fb77ae9bf3fa0821965aacd55272"></a>
template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a39d1fb77ae9bf3fa0821965aacd55272"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_typed_message_view</b> (<a class="el" href="classcaf_1_1message.html">message</a> &amp;msg)</td></tr>
<tr class="separator:a39d1fb77ae9bf3fa0821965aacd55272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f31dd8a591a046a7d485ff77db72c10"><td class="memTemplParams" colspan="2"><a id="a2f31dd8a591a046a7d485ff77db72c10" name="a2f31dd8a591a046a7d485ff77db72c10"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2f31dd8a591a046a7d485ff77db72c10"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="structcaf_1_1upstream__msg.html">upstream_msg</a> &amp;x)</td></tr>
<tr class="memdesc:a2f31dd8a591a046a7d485ff77db72c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the testing DSL to unbox <code><a class="el" href="structcaf_1_1upstream__msg.html" title="Stream messages that flow upstream, i.e., acks and drop messages.">upstream_msg</a></code> automagically. <br /></td></tr>
<tr class="separator:a2f31dd8a591a046a7d485ff77db72c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45301afc69d716d4e5ecba536418edb"><td class="memTemplParams" colspan="2"><a id="ac45301afc69d716d4e5ecba536418edb" name="ac45301afc69d716d4e5ecba536418edb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac45301afc69d716d4e5ecba536418edb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is</b> (const <a class="el" href="structcaf_1_1upstream__msg.html">upstream_msg</a> &amp;x)</td></tr>
<tr class="memdesc:ac45301afc69d716d4e5ecba536418edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the testing DSL to check whether <code><a class="el" href="structcaf_1_1upstream__msg.html" title="Stream messages that flow upstream, i.e., acks and drop messages.">upstream_msg</a></code> holds a <code>T</code>. <br /></td></tr>
<tr class="separator:ac45301afc69d716d4e5ecba536418edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a14b64038a4ac76fa3afc10753a2f49"><td class="memTemplParams" colspan="2"><a id="a8a14b64038a4ac76fa3afc10753a2f49" name="a8a14b64038a4ac76fa3afc10753a2f49"></a>
template&lt;class Inspector &gt; </td></tr>
<tr class="memitem:a8a14b64038a4ac76fa3afc10753a2f49"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inspect</b> (Inspector &amp;f, <a class="el" href="structcaf_1_1uri_1_1authority__type.html">uri::authority_type</a> &amp;x)</td></tr>
<tr class="separator:a8a14b64038a4ac76fa3afc10753a2f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ceeb97722c77c270046b51879cd3a24"><td class="memTemplParams" colspan="2"><a id="a1ceeb97722c77c270046b51879cd3a24" name="a1ceeb97722c77c270046b51879cd3a24"></a>
template&lt;class Inspector &gt; </td></tr>
<tr class="memitem:a1ceeb97722c77c270046b51879cd3a24"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inspect</b> (Inspector &amp;f, uri::impl_type &amp;x)</td></tr>
<tr class="separator:a1ceeb97722c77c270046b51879cd3a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a634bae6bff966f7fc1f7943267d4c03c"><td class="memItemLeft" align="right" valign="top"><a id="a634bae6bff966f7fc1f7943267d4c03c" name="a634bae6bff966f7fc1f7943267d4c03c"></a>
constexpr actor_id&#160;</td><td class="memItemRight" valign="bottom"><b>invalid_actor_id</b> = 0</td></tr>
<tr class="memdesc:a634bae6bff966f7fc1f7943267d4c03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes an ID that is never used by an actor. <br /></td></tr>
<tr class="separator:a634bae6bff966f7fc1f7943267d4c03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefea5afa12345bb69062e3d2d03196b4"><td class="memTemplParams" colspan="2"><a id="aefea5afa12345bb69062e3d2d03196b4" name="aefea5afa12345bb69062e3d2d03196b4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aefea5afa12345bb69062e3d2d03196b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_allowed_unsafe_message_type_v</b> = <a class="el" href="structcaf_1_1allowed__unsafe__message__type.html">allowed_unsafe_message_type</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aefea5afa12345bb69062e3d2d03196b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a93b514b7b7df53613c3f4bc0ef10c"><td class="memItemLeft" align="right" valign="top"><a id="a14a93b514b7b7df53613c3f4bc0ef10c" name="a14a93b514b7b7df53613c3f4bc0ef10c"></a>
constexpr invalid_stream_t&#160;</td><td class="memItemRight" valign="bottom"><b>invalid_stream</b> = invalid_stream_t{}</td></tr>
<tr class="separator:a14a93b514b7b7df53613c3f4bc0ef10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2ac1865d02c771357096eef2d670fd"><td class="memItemLeft" align="right" valign="top"><a id="a7d2ac1865d02c771357096eef2d670fd" name="a7d2ac1865d02c771357096eef2d670fd"></a>
constexpr <a class="el" href="structcaf_1_1no__stages__t.html">no_stages_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>no_stages</b> = <a class="el" href="structcaf_1_1no__stages__t.html">no_stages_t</a>{}</td></tr>
<tr class="memdesc:a7d2ac1865d02c771357096eef2d670fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience tag for producing empty forwarding stacks. <br /></td></tr>
<tr class="separator:a7d2ac1865d02c771357096eef2d670fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d88e174972c62830f90aa1e47dda3ed"><td class="memItemLeft" align="right" valign="top"><a id="a1d88e174972c62830f90aa1e47dda3ed" name="a1d88e174972c62830f90aa1e47dda3ed"></a>
static constexpr <a class="el" href="structcaf_1_1none__t.html">none_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>none</b> = <a class="el" href="structcaf_1_1none__t.html">none_t</a>{}</td></tr>
<tr class="separator:a1d88e174972c62830f90aa1e47dda3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8302e4b7cd1dfee859fe3e9b8bd7207"><td class="memItemLeft" align="right" valign="top"><a id="ae8302e4b7cd1dfee859fe3e9b8bd7207" name="ae8302e4b7cd1dfee859fe3e9b8bd7207"></a>
constexpr others_t&#160;</td><td class="memItemRight" valign="bottom"><b>others</b> = others_t{}</td></tr>
<tr class="separator:ae8302e4b7cd1dfee859fe3e9b8bd7207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84d6d941d8b84d0172578e56fc4539b"><td class="memItemLeft" align="right" valign="top"><a id="ac84d6d941d8b84d0172578e56fc4539b" name="ac84d6d941d8b84d0172578e56fc4539b"></a>
constexpr <a class="el" href="classcaf_1_1skip__t.html">skip_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>skip</b> = <a class="el" href="classcaf_1_1skip__t.html">skip_t</a>{}</td></tr>
<tr class="memdesc:ac84d6d941d8b84d0172578e56fc4539b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the runtime system to skip a message when used as message handler, i.e., causes the runtime to leave the message in the mailbox of an actor. <br /></td></tr>
<tr class="separator:ac84d6d941d8b84d0172578e56fc4539b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbb9f9de56a173754932f0c6473925ed"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><b>no_spawn_options</b> = spawn_options::no_flags</td></tr>
<tr class="memdesc:gabbb9f9de56a173754932f0c6473925ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes default settings. <br /></td></tr>
<tr class="separator:gabbb9f9de56a173754932f0c6473925ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga197ff1f076793001295b672ab23790a2"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><b>monitored</b> = spawn_options::monitor_flag</td></tr>
<tr class="memdesc:ga197ff1f076793001295b672ab23790a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes <code>spawn</code> to call `self-&gt;monitor(...) immediately after the new actor was spawned. <br /></td></tr>
<tr class="separator:ga197ff1f076793001295b672ab23790a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c2e380b48f98c44b7311bd0725456d5"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><b>linked</b> = spawn_options::link_flag</td></tr>
<tr class="memdesc:ga6c2e380b48f98c44b7311bd0725456d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes <code>spawn</code> to call `self-&gt;link_to(...) immediately after the new actor was spawned. <br /></td></tr>
<tr class="separator:ga6c2e380b48f98c44b7311bd0725456d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2555e866af2cb032aabd9a506ac191bd"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><b>detached</b> = spawn_options::detach_flag</td></tr>
<tr class="memdesc:ga2555e866af2cb032aabd9a506ac191bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the new actor to opt out of the cooperative scheduling. <br /></td></tr>
<tr class="separator:ga2555e866af2cb032aabd9a506ac191bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7b5c96cbf488921f9871ff46b0ea877"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hidden</b> = spawn_options::hide_flag</td></tr>
<tr class="memdesc:gac7b5c96cbf488921f9871ff46b0ea877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the runtime to ignore the new actor in <code>await_all_actors_done()</code>. <br /></td></tr>
<tr class="separator:gac7b5c96cbf488921f9871ff46b0ea877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa320e439df44a8f73da7e5a975cce7d2"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="group___actor_creation.html#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lazy_init</b> = spawn_options::lazy_init_flag</td></tr>
<tr class="memdesc:gaa320e439df44a8f73da7e5a975cce7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the new actor to delay its initialization until a message arrives. <br /></td></tr>
<tr class="separator:gaa320e439df44a8f73da7e5a975cce7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab6348891c41765656408d612a0cbec"><td class="memItemLeft" align="right" valign="top"><a id="aaab6348891c41765656408d612a0cbec" name="aaab6348891c41765656408d612a0cbec"></a>
constexpr <a class="el" href="namespacecaf.html#a5e4e3f547c07339f44ef90acdd11a1fe">stream_slot</a>&#160;</td><td class="memItemRight" valign="bottom"><b>invalid_stream_slot</b> = 0</td></tr>
<tr class="memdesc:aaab6348891c41765656408d612a0cbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies an invalid slot. <br /></td></tr>
<tr class="separator:aaab6348891c41765656408d612a0cbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7c553cccbcd493d4e7311b46cfb05e"><td class="memItemLeft" align="right" valign="top"><a id="a3f7c553cccbcd493d4e7311b46cfb05e" name="a3f7c553cccbcd493d4e7311b46cfb05e"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>token_compress_on</b> = false</td></tr>
<tr class="separator:a3f7c553cccbcd493d4e7311b46cfb05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c1cb40a74f68414caba0cffd153637"><td class="memItemLeft" align="right" valign="top"><a id="a63c1cb40a74f68414caba0cffd153637" name="a63c1cb40a74f68414caba0cffd153637"></a>
static constexpr <a class="el" href="namespacecaf.html#adc3db7177cb06bf8d5bfd2df387729d4">timespan</a>&#160;</td><td class="memItemRight" valign="bottom"><b>infinite</b> = <a class="el" href="namespacecaf.html#adc3db7177cb06bf8d5bfd2df387729d4">timespan</a>{std::numeric_limits&lt;int64_t&gt;::max()}</td></tr>
<tr class="memdesc:a63c1cb40a74f68414caba0cffd153637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant representing an infinite amount of time. <br /></td></tr>
<tr class="separator:a63c1cb40a74f68414caba0cffd153637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843669aeffc99e0fc80664b6731f77c4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecaf.html#a44855080188b6693187137bd666c7eb4">type_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaf.html#a843669aeffc99e0fc80664b6731f77c4">invalid_type_id</a> = 65535</td></tr>
<tr class="memdesc:a843669aeffc99e0fc80664b6731f77c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special value equal to the greatest possible value for <code>type_id_t</code>.  <br /></td></tr>
<tr class="separator:a843669aeffc99e0fc80664b6731f77c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa991b63b2dedd98ea202a3bd9b8a1f9a"><td class="memItemLeft" align="right" valign="top"><a id="aa991b63b2dedd98ea202a3bd9b8a1f9a" name="aa991b63b2dedd98ea202a3bd9b8a1f9a"></a>
constexpr <a class="el" href="namespacecaf.html#a44855080188b6693187137bd666c7eb4">type_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>first_custom_type_id</b> = 200</td></tr>
<tr class="memdesc:aa991b63b2dedd98ea202a3bd9b8a1f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first type ID not reserved by CAF and its modules. <br /></td></tr>
<tr class="separator:aa991b63b2dedd98ea202a3bd9b8a1f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcebb374d52528e75810fe53080974e3"><td class="memTemplParams" colspan="2"><a id="adcebb374d52528e75810fe53080974e3" name="adcebb374d52528e75810fe53080974e3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adcebb374d52528e75810fe53080974e3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_type_id_v</b> = detail::is_complete&lt;<a class="el" href="structcaf_1_1type__id.html">type_id</a>&lt;T&gt;&gt;</td></tr>
<tr class="memdesc:adcebb374d52528e75810fe53080974e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code><a class="el" href="structcaf_1_1type__id.html" title="Maps the type T to a globally unique ID.">type_id</a></code> is specialized for <code>T</code>. <br /></td></tr>
<tr class="separator:adcebb374d52528e75810fe53080974e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa924604b16a69f9a5d00518a5a8d3860"><td class="memItemLeft" align="right" valign="top"><a id="aa924604b16a69f9a5d00518a5a8d3860" name="aa924604b16a69f9a5d00518a5a8d3860"></a>
constexpr <a class="el" href="structcaf_1_1partial__behavior__init__t.html">partial_behavior_init_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>partial_behavior_init</b> = <a class="el" href="structcaf_1_1partial__behavior__init__t.html">partial_behavior_init_t</a>{}</td></tr>
<tr class="separator:aa924604b16a69f9a5d00518a5a8d3860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c13c88cc2dbdf94635f48198ff325b"><td class="memItemLeft" align="right" valign="top"><a id="a23c13c88cc2dbdf94635f48198ff325b" name="a23c13c88cc2dbdf94635f48198ff325b"></a>
static constexpr <a class="el" href="structcaf_1_1unit__t.html">unit_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unit</b> = <a class="el" href="structcaf_1_1unit__t.html">unit_t</a>{}</td></tr>
<tr class="separator:a23c13c88cc2dbdf94635f48198ff325b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979eb3497b45bd81afb2a6651c8f7fac"><td class="memItemLeft" align="right" valign="top"><a id="a979eb3497b45bd81afb2a6651c8f7fac" name="a979eb3497b45bd81afb2a6651c8f7fac"></a>
constexpr <a class="el" href="structcaf_1_1unsafe__behavior__init__t.html">unsafe_behavior_init_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unsafe_behavior_init</b> = <a class="el" href="structcaf_1_1unsafe__behavior__init__t.html">unsafe_behavior_init_t</a>{}</td></tr>
<tr class="memdesc:a979eb3497b45bd81afb2a6651c8f7fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience constant for constructing a typed behavior from an untyped behavior. <br /></td></tr>
<tr class="separator:a979eb3497b45bd81afb2a6651c8f7fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4205af671d62c8b68ef05465a5145c9c"><td class="memItemLeft" align="right" valign="top"><a id="a4205af671d62c8b68ef05465a5145c9c" name="a4205af671d62c8b68ef05465a5145c9c"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>variant_npos</b> = static_cast&lt;size_t&gt;(-1)</td></tr>
<tr class="separator:a4205af671d62c8b68ef05465a5145c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Root namespace of libcaf. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a8da1769b99ebcb3e6774c0640f20e1ad" name="a8da1769b99ebcb3e6774c0640f20e1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da1769b99ebcb3e6774c0640f20e1ad">&#9670;&#160;</a></span>interface_mismatch_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Found , class Expected &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecaf.html#a8da1769b99ebcb3e6774c0640f20e1ad">caf::interface_mismatch_t</a> = typedef detail::imi&lt;0, Found, Expected, <a class="el" href="structcaf_1_1detail_1_1type__list.html">detail::type_list</a>&lt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans two typed MPI lists for compatibility, returning the index of the first mismatch. </p>
<p>Returns the number of elements on a match. </p><dl class="section pre"><dt>Precondition</dt><dd>len(Found) == len(Expected) </dd></dl>

</div>
</div>
<a id="a867900a9604021e6344cc21c9a55537a" name="a867900a9604021e6344cc21c9a55537a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867900a9604021e6344cc21c9a55537a">&#9670;&#160;</a></span>ip_subnet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ipv6_subnet <a class="el" href="namespacecaf.html#a867900a9604021e6344cc21c9a55537a">caf::ip_subnet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An IP subnetwork. </p>
<p>The address family is IPv6 unless <code>embeds_v4</code> returns true. </p>

</div>
</div>
<a id="ac4f35acd9e6d9f1214f1fee72993632b" name="ac4f35acd9e6d9f1214f1fee72993632b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f35acd9e6d9f1214f1fee72993632b">&#9670;&#160;</a></span>make_stage_result_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class In , class DownstreamManager , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecaf.html#ac4f35acd9e6d9f1214f1fee72993632b">caf::make_stage_result_t</a> = typedef <a class="el" href="classcaf_1_1make__stage__result.html">make_stage_result</a>&lt;In, DownstreamManager, detail::strip_and_convert_t&lt;Ts&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type for defining a <code><a class="el" href="classcaf_1_1make__stage__result.html" title="Returns a stream stage with the slot IDs of its first in- and outbound paths.">make_stage_result</a></code> from a downstream manager plus additional handshake types. </p>
<p>Hardwires <code>message</code> as result type. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a72ed789d5a799ff8eab4697604ae5784" name="a72ed789d5a799ff8eab4697604ae5784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ed789d5a799ff8eab4697604ae5784">&#9670;&#160;</a></span>exit_reason</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacecaf.html#a72ed789d5a799ff8eab4697604ae5784">caf::exit_reason</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This error category represents fail conditions for actors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a72ed789d5a799ff8eab4697604ae5784afea087517c26fadd409bd4b9dc642555" name="a72ed789d5a799ff8eab4697604ae5784afea087517c26fadd409bd4b9dc642555"></a>normal&#160;</td><td class="fielddoc"><p>Indicates that an actor finished execution without error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a72ed789d5a799ff8eab4697604ae5784aad921d60486366258809553a3db49a4a" name="a72ed789d5a799ff8eab4697604ae5784aad921d60486366258809553a3db49a4a"></a>unknown&#160;</td><td class="fielddoc"><p>Indicates that the exit reason for this actor is unknown, i.e., the actor has been terminated and no longer exists. </p>
</td></tr>
<tr><td class="fieldname"><a id="a72ed789d5a799ff8eab4697604ae5784a30b691fbbd96cde0f7637f48823509af" name="a72ed789d5a799ff8eab4697604ae5784a30b691fbbd96cde0f7637f48823509af"></a>out_of_workers&#160;</td><td class="fielddoc"><p>Indicates that an actor pool unexpectedly ran out of workers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a72ed789d5a799ff8eab4697604ae5784aa0ea9b704b284e4ea1d35df90b587e2b" name="a72ed789d5a799ff8eab4697604ae5784aa0ea9b704b284e4ea1d35df90b587e2b"></a>user_shutdown&#160;</td><td class="fielddoc"><p>Indicates that an actor was forced to shutdown by a user-generated event. </p>
</td></tr>
<tr><td class="fieldname"><a id="a72ed789d5a799ff8eab4697604ae5784a534735884d341071762ede7af01c53e8" name="a72ed789d5a799ff8eab4697604ae5784a534735884d341071762ede7af01c53e8"></a>kill&#160;</td><td class="fielddoc"><p>Indicates that an actor was killed unconditionally. </p>
</td></tr>
<tr><td class="fieldname"><a id="a72ed789d5a799ff8eab4697604ae5784a43a121b7034424d4b02495c1a9e2ba34" name="a72ed789d5a799ff8eab4697604ae5784a43a121b7034424d4b02495c1a9e2ba34"></a>remote_link_unreachable&#160;</td><td class="fielddoc"><p>Indicates that an actor finished execution because a connection to a remote link was closed unexpectedly. </p>
</td></tr>
<tr><td class="fieldname"><a id="a72ed789d5a799ff8eab4697604ae5784ab748f56cf76526f8606d7463b9df9f2e" name="a72ed789d5a799ff8eab4697604ae5784ab748f56cf76526f8606d7463b9df9f2e"></a>unreachable&#160;</td><td class="fielddoc"><p>Indicates that an actor was killed because it became unreachable. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2d701f7629091f4f89f273ab9bb44a20" name="a2d701f7629091f4f89f273ab9bb44a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d701f7629091f4f89f273ab9bb44a20">&#9670;&#160;</a></span>invoke_message_result</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacecaf.html#a2d701f7629091f4f89f273ab9bb44a20">caf::invoke_message_result</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the result of a message invocation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2d701f7629091f4f89f273ab9bb44a20a48fe8558ce14c4c865198444c538ecc5" name="a2d701f7629091f4f89f273ab9bb44a20a48fe8558ce14c4c865198444c538ecc5"></a>consumed&#160;</td><td class="fielddoc"><p>Indicates that the actor consumed the message. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2d701f7629091f4f89f273ab9bb44a20ae52e279299e912838f689d4380c81f4a" name="a2d701f7629091f4f89f273ab9bb44a20ae52e279299e912838f689d4380c81f4a"></a>skipped&#160;</td><td class="fielddoc"><p>Indicates that the actor left the message in the mailbox. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2d701f7629091f4f89f273ab9bb44a20a41d368a58ee26891a6a586ddaaa604f8" name="a2d701f7629091f4f89f273ab9bb44a20a41d368a58ee26891a6a586ddaaa604f8"></a>dropped&#160;</td><td class="fielddoc"><p>Indicates that the actor discarded the message based on meta data. </p>
<p>For example, timeout messages for already received requests usually get dropped without calling any user-defined code. </p>
</td></tr>
</table>

</div>
</div>
<a id="a82b93288f573f015630a689bd03607ca" name="a82b93288f573f015630a689bd03607ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b93288f573f015630a689bd03607ca">&#9670;&#160;</a></span>pec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacecaf.html#a82b93288f573f015630a689bd03607ca">caf::pec</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PEC stands for "Parser Error Code". </p>
<p>This enum contains error codes used by various CAF parsers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caa260ca9dd8a4577fc00b7bd5810298076" name="a82b93288f573f015630a689bd03607caa260ca9dd8a4577fc00b7bd5810298076"></a>success&#160;</td><td class="fielddoc"><p>Not-an-error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caa6c7d599b08d42472b1bad3d33b9bed3a" name="a82b93288f573f015630a689bd03607caa6c7d599b08d42472b1bad3d33b9bed3a"></a>trailing_character&#160;</td><td class="fielddoc"><p>Parser succeeded but found trailing character(s). </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caa1a5b101afc11147048312dd33b62e008" name="a82b93288f573f015630a689bd03607caa1a5b101afc11147048312dd33b62e008"></a>unexpected_eof&#160;</td><td class="fielddoc"><p>Parser stopped after reaching the end while still expecting input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caadf367fb990f1a76035e3c1884443d8ee" name="a82b93288f573f015630a689bd03607caadf367fb990f1a76035e3c1884443d8ee"></a>unexpected_character&#160;</td><td class="fielddoc"><p>Parser stopped after reading an unexpected character. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caae9c695325dd91c8074c3445c2edecebe" name="a82b93288f573f015630a689bd03607caae9c695325dd91c8074c3445c2edecebe"></a>timespan_overflow&#160;</td><td class="fielddoc"><p>Parsed integer exceeds the number of available bits of a <code>timespan</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caa30b10fb73b7640a186b1b369b702fc4b" name="a82b93288f573f015630a689bd03607caa30b10fb73b7640a186b1b369b702fc4b"></a>fractional_timespan&#160;</td><td class="fielddoc"><p>Tried constructing a <code>timespan</code> with from a floating point number. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caa6beb6e2a9cef45cf6f85766c71931c22" name="a82b93288f573f015630a689bd03607caa6beb6e2a9cef45cf6f85766c71931c22"></a>too_many_characters&#160;</td><td class="fielddoc"><p>Too many characters for an atom. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caa089031f44942f5039bf1c4eae7bedd44" name="a82b93288f573f015630a689bd03607caa089031f44942f5039bf1c4eae7bedd44"></a>invalid_escape_sequence&#160;</td><td class="fielddoc"><p>Unrecognized character after escaping <code>\</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caa6fe7694a5d04b5e82a2deb21f2a5c004" name="a82b93288f573f015630a689bd03607caa6fe7694a5d04b5e82a2deb21f2a5c004"></a>unexpected_newline&#160;</td><td class="fielddoc"><p>Misplaced newline, e.g., inside a string. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caae9a83ecfce47bad5a02cf347e7cd5796" name="a82b93288f573f015630a689bd03607caae9a83ecfce47bad5a02cf347e7cd5796"></a>integer_overflow&#160;</td><td class="fielddoc"><p>Parsed positive integer exceeds the number of available bits. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caaff3b21a97947ac46215370aee7af776b" name="a82b93288f573f015630a689bd03607caaff3b21a97947ac46215370aee7af776b"></a>integer_underflow&#160;</td><td class="fielddoc"><p>Parsed negative integer exceeds the number of available bits. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caafe59dbfda3078f50d0f5a39dcae23571" name="a82b93288f573f015630a689bd03607caafe59dbfda3078f50d0f5a39dcae23571"></a>exponent_underflow&#160;</td><td class="fielddoc"><p>Exponent of parsed double is less than the minimum supported exponent. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caad77666a4c1efd86d546cbd54f71e5bdf" name="a82b93288f573f015630a689bd03607caad77666a4c1efd86d546cbd54f71e5bdf"></a>exponent_overflow&#160;</td><td class="fielddoc"><p>Exponent of parsed double is greater than the maximum supported exponent. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caa570a4fa126d94bc89332b5f610420adf" name="a82b93288f573f015630a689bd03607caa570a4fa126d94bc89332b5f610420adf"></a>type_mismatch&#160;</td><td class="fielddoc"><p>Parsed type does not match the expected type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caa7cd12b6998314dc0ad565a7ea5d2de4e" name="a82b93288f573f015630a689bd03607caa7cd12b6998314dc0ad565a7ea5d2de4e"></a>not_an_option&#160;</td><td class="fielddoc"><p>Stopped at an unrecognized option name. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caae55d43eabeefe5a8271b4a3c898bd18f" name="a82b93288f573f015630a689bd03607caae55d43eabeefe5a8271b4a3c898bd18f"></a>invalid_argument&#160;</td><td class="fielddoc"><p>Stopped at an unparsable argument. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caab2d7cd4bd5ec469e66ccfe2d27c7e415" name="a82b93288f573f015630a689bd03607caab2d7cd4bd5ec469e66ccfe2d27c7e415"></a>missing_argument&#160;</td><td class="fielddoc"><p>Stopped because an argument was omitted. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caa0416e200d7acdab3eb1d301e458ebd21" name="a82b93288f573f015630a689bd03607caa0416e200d7acdab3eb1d301e458ebd21"></a>invalid_category&#160;</td><td class="fielddoc"><p>Stopped because the key of a category was taken. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caa9b38077cbfb9d7b3ebb1a586cf3a1b54" name="a82b93288f573f015630a689bd03607caa9b38077cbfb9d7b3ebb1a586cf3a1b54"></a>invalid_field_name&#160;</td><td class="fielddoc"><p>Stopped at an unexpected field name while reading a user-defined type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caa44b773b5b5d63d98552267dfd07c053f" name="a82b93288f573f015630a689bd03607caa44b773b5b5d63d98552267dfd07c053f"></a>repeated_field_name&#160;</td><td class="fielddoc"><p>Stopped at a repeated field name while reading a user-defined type. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caa5ac1975aa5d9e092d334e9a64ddc9d37" name="a82b93288f573f015630a689bd03607caa5ac1975aa5d9e092d334e9a64ddc9d37"></a>missing_field&#160;</td><td class="fielddoc"><p>Stopped while reading a user-defined type with one or more missing mandatory fields. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caa6bdbd4c80b3712ffd66335d14f16ba61" name="a82b93288f573f015630a689bd03607caa6bdbd4c80b3712ffd66335d14f16ba61"></a>invalid_range_expression&#160;</td><td class="fielddoc"><p>Parsing a range statement ('n..m' or 'n..m..step') failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caa1528b2e7d0051d6d859b53639dd6f49c" name="a82b93288f573f015630a689bd03607caa1528b2e7d0051d6d859b53639dd6f49c"></a>invalid_state&#160;</td><td class="fielddoc"><p>Stopped after running into an invalid parser state. </p>
<p>Should never happen and most likely indicates a bug in the implementation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a82b93288f573f015630a689bd03607caaee55faef8c86d3222e023c98a9246331" name="a82b93288f573f015630a689bd03607caaee55faef8c86d3222e023c98a9246331"></a>nested_too_deeply&#160;</td><td class="fielddoc"><p>Parser stopped after exceeding its maximum supported level of nesting. </p>
</td></tr>
</table>

</div>
</div>
<a id="aad31759ecbee7d4d2133a5618a053a78" name="aad31759ecbee7d4d2133a5618a053a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad31759ecbee7d4d2133a5618a053a78">&#9670;&#160;</a></span>sec</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacecaf.html#aad31759ecbee7d4d2133a5618a053a78">caf::sec</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SEC stands for "System Error Code". </p>
<p>This enum contains error codes for ::actor_system and its modules. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a334c4a4c42fdb79d7ebc3e73b517e6f8" name="aad31759ecbee7d4d2133a5618a053a78a334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"><p>No error. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a597cfdb46675641f694b1f918760d432" name="aad31759ecbee7d4d2133a5618a053a78a597cfdb46675641f694b1f918760d432"></a>unexpected_message&#160;</td><td class="fielddoc"><p>Indicates that an actor dropped an unexpected message. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78ad4a1781764e87a2801983ce8181c27cf" name="aad31759ecbee7d4d2133a5618a053a78ad4a1781764e87a2801983ce8181c27cf"></a>unexpected_response&#160;</td><td class="fielddoc"><p>Indicates that a response message did not match the provided handler. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a7f4365e77fb6f589c84c20e81197c79d" name="aad31759ecbee7d4d2133a5618a053a78a7f4365e77fb6f589c84c20e81197c79d"></a>request_receiver_down&#160;</td><td class="fielddoc"><p>Indicates that the receiver of a request is no longer alive. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78ad3e570068c1caf02414be8c33ed0870f" name="aad31759ecbee7d4d2133a5618a053a78ad3e570068c1caf02414be8c33ed0870f"></a>request_timeout&#160;</td><td class="fielddoc"><p>Indicates that a request message timed out. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a182e28a53823e6df87a1ed00aa5ed058" name="aad31759ecbee7d4d2133a5618a053a78a182e28a53823e6df87a1ed00aa5ed058"></a>no_such_group_module&#160;</td><td class="fielddoc"><p>Indicates that requested group module does not exist. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a72401a7ff0db08ed2aa28a34733e8d40" name="aad31759ecbee7d4d2133a5618a053a78a72401a7ff0db08ed2aa28a34733e8d40"></a>no_actor_published_at_port&#160;</td><td class="fielddoc"><p>Unpublishing or connecting failed: no actor bound to given port. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a7f84bdf352032576d3d804762a214a9a" name="aad31759ecbee7d4d2133a5618a053a78a7f84bdf352032576d3d804762a214a9a"></a>unexpected_actor_messaging_interface&#160;</td><td class="fielddoc"><p>Connecting failed because a remote actor had an unexpected interface. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78ac439cf91e7ec59d69162275db58d478e" name="aad31759ecbee7d4d2133a5618a053a78ac439cf91e7ec59d69162275db58d478e"></a>state_not_serializable&#160;</td><td class="fielddoc"><p>Migration failed because the state of an actor is not serializable. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a8daeacea51521a5662fa6abed16df722" name="aad31759ecbee7d4d2133a5618a053a78a8daeacea51521a5662fa6abed16df722"></a>unsupported_sys_key&#160;</td><td class="fielddoc"><p>An actor received an unsupported key for &lsquo;('sys&rsquo;, 'get', key)` messages. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a3af43f852e2ac3a3c37136c787dd5976" name="aad31759ecbee7d4d2133a5618a053a78a3af43f852e2ac3a3c37136c787dd5976"></a>unsupported_sys_message&#160;</td><td class="fielddoc"><p>An actor received an unsupported system message. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a83e7246ebfde490dddd886250bab9f4f" name="aad31759ecbee7d4d2133a5618a053a78a83e7246ebfde490dddd886250bab9f4f"></a>disconnect_during_handshake&#160;</td><td class="fielddoc"><p>A remote node disconnected during CAF handshake. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a2e6d121b6903ac137b1d99661f2e5b7f" name="aad31759ecbee7d4d2133a5618a053a78a2e6d121b6903ac137b1d99661f2e5b7f"></a>cannot_forward_to_invalid_actor&#160;</td><td class="fielddoc"><p>Tried to forward a message via BASP to an invalid actor handle. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a57be9b695350dca990b35a9152085b54" name="aad31759ecbee7d4d2133a5618a053a78a57be9b695350dca990b35a9152085b54"></a>no_route_to_receiving_node&#160;</td><td class="fielddoc"><p>Tried to forward a message via BASP to an unknown node ID. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a8a52ad217cfb8e32d90340a4c2c25806" name="aad31759ecbee7d4d2133a5618a053a78a8a52ad217cfb8e32d90340a4c2c25806"></a>failed_to_assign_scribe_from_handle&#160;</td><td class="fielddoc"><p>Middleman could not assign a connection handle to a broker. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a141b4e2bb3270cefa57c93e914ef6f3a" name="aad31759ecbee7d4d2133a5618a053a78a141b4e2bb3270cefa57c93e914ef6f3a"></a>failed_to_assign_doorman_from_handle&#160;</td><td class="fielddoc"><p>Middleman could not assign an acceptor handle to a broker. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a90b4b331c03edf609637a75a282597eb" name="aad31759ecbee7d4d2133a5618a053a78a90b4b331c03edf609637a75a282597eb"></a>cannot_close_invalid_port&#160;</td><td class="fielddoc"><p>User requested to close port 0 or to close a port not managed by CAF. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78ac6da4afffebf441d165db9e552649f6a" name="aad31759ecbee7d4d2133a5618a053a78ac6da4afffebf441d165db9e552649f6a"></a>cannot_connect_to_node&#160;</td><td class="fielddoc"><p>Middleman could not connect to a remote node. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78aa791028a7c1dc4ee2617c72fd999906d" name="aad31759ecbee7d4d2133a5618a053a78aa791028a7c1dc4ee2617c72fd999906d"></a>cannot_open_port&#160;</td><td class="fielddoc"><p>Middleman could not open requested port. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a2dfd755a3f71048412701b4a22bc1614" name="aad31759ecbee7d4d2133a5618a053a78a2dfd755a3f71048412701b4a22bc1614"></a>network_syscall_failed&#160;</td><td class="fielddoc"><p>A C system call in the middleman failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78ae55d43eabeefe5a8271b4a3c898bd18f" name="aad31759ecbee7d4d2133a5618a053a78ae55d43eabeefe5a8271b4a3c898bd18f"></a>invalid_argument&#160;</td><td class="fielddoc"><p>A function received one or more invalid arguments. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78adff503db0417804f50d2ef49a5280366" name="aad31759ecbee7d4d2133a5618a053a78adff503db0417804f50d2ef49a5280366"></a>invalid_protocol_family&#160;</td><td class="fielddoc"><p>A network socket reported an invalid network protocol family. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78afe9f9410355ad948b97dbf13a296758b" name="aad31759ecbee7d4d2133a5618a053a78afe9f9410355ad948b97dbf13a296758b"></a>cannot_publish_invalid_actor&#160;</td><td class="fielddoc"><p>Middleman could not publish an actor because it was invalid. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a2bee4050533a327c092b95adbc3e0839" name="aad31759ecbee7d4d2133a5618a053a78a2bee4050533a327c092b95adbc3e0839"></a>cannot_spawn_actor_from_arguments&#160;</td><td class="fielddoc"><p>A remote spawn failed because the provided types did not match. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a09f3645c755dc42466f97cbbc7896000" name="aad31759ecbee7d4d2133a5618a053a78a09f3645c755dc42466f97cbbc7896000"></a>end_of_stream&#160;</td><td class="fielddoc"><p>Serialization failed because there was not enough data to read. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a43e1a8d7d8c3dd37b9358e3f9dcb9473" name="aad31759ecbee7d4d2133a5618a053a78a43e1a8d7d8c3dd37b9358e3f9dcb9473"></a>no_context&#160;</td><td class="fielddoc"><p>Serialization failed because no CAF context is available. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78ad09109cd4d5da45ade59d2563b00936a" name="aad31759ecbee7d4d2133a5618a053a78ad09109cd4d5da45ade59d2563b00936a"></a>unknown_type&#160;</td><td class="fielddoc"><p>Serialization failed because CAF misses run-time type information. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78aa4557d86914df2ee9493a8c7e559b7c3" name="aad31759ecbee7d4d2133a5618a053a78aa4557d86914df2ee9493a8c7e559b7c3"></a>no_proxy_registry&#160;</td><td class="fielddoc"><p>Serialization of actors failed because no proxy registry is available. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a5b32065884bcc1f2ed126c47e6410808" name="aad31759ecbee7d4d2133a5618a053a78a5b32065884bcc1f2ed126c47e6410808"></a>runtime_error&#160;</td><td class="fielddoc"><p>An exception was thrown during message handling. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a1023fb495955973a444b9d285a9129c1" name="aad31759ecbee7d4d2133a5618a053a78a1023fb495955973a444b9d285a9129c1"></a>remote_linking_failed&#160;</td><td class="fielddoc"><p>Linking to a remote actor failed because actor no longer exists. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a374b2d9beed3dabe37612ee5851afa78" name="aad31759ecbee7d4d2133a5618a053a78a374b2d9beed3dabe37612ee5851afa78"></a>cannot_add_upstream&#160;</td><td class="fielddoc"><p>Adding an upstream to a stream failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a686e18b530d3b66e314a78041bfab873" name="aad31759ecbee7d4d2133a5618a053a78a686e18b530d3b66e314a78041bfab873"></a>upstream_already_exists&#160;</td><td class="fielddoc"><p>Adding an upstream to a stream failed because it already exists. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a49bbf68a3bb43f766f0d936c7498b3f6" name="aad31759ecbee7d4d2133a5618a053a78a49bbf68a3bb43f766f0d936c7498b3f6"></a>invalid_upstream&#160;</td><td class="fielddoc"><p>Unable to process upstream messages because upstream is invalid. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78af7d600ebee28dc40f6dedecbbea1457b" name="aad31759ecbee7d4d2133a5618a053a78af7d600ebee28dc40f6dedecbbea1457b"></a>cannot_add_downstream&#160;</td><td class="fielddoc"><p>Adding a downstream to a stream failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a79db1b95b8a19ac96be1326e1c37e1ea" name="aad31759ecbee7d4d2133a5618a053a78a79db1b95b8a19ac96be1326e1c37e1ea"></a>downstream_already_exists&#160;</td><td class="fielddoc"><p>Adding a downstream to a stream failed because it already exists. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a6e1024bb2c206a3787fbc66bf815d71f" name="aad31759ecbee7d4d2133a5618a053a78a6e1024bb2c206a3787fbc66bf815d71f"></a>invalid_downstream&#160;</td><td class="fielddoc"><p>Unable to process downstream messages because downstream is invalid. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a37bbe6b3372a9b92da8a90f189b7fc19" name="aad31759ecbee7d4d2133a5618a053a78a37bbe6b3372a9b92da8a90f189b7fc19"></a>no_downstream_stages_defined&#160;</td><td class="fielddoc"><p>Cannot start streaming without next stage. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a7aff60e790581bfaf2bd29203d3af224" name="aad31759ecbee7d4d2133a5618a053a78a7aff60e790581bfaf2bd29203d3af224"></a>stream_init_failed&#160;</td><td class="fielddoc"><p>Actor failed to initialize state after receiving a stream handshake. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78aa59d243db5f771529aac4080f5c11814" name="aad31759ecbee7d4d2133a5618a053a78aa59d243db5f771529aac4080f5c11814"></a>invalid_stream_state&#160;</td><td class="fielddoc"><p>Unable to process a stream since due to missing state. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a3a5b02a7e1fc4444f0b8b0ee7fca2ec3" name="aad31759ecbee7d4d2133a5618a053a78a3a5b02a7e1fc4444f0b8b0ee7fca2ec3"></a>unhandled_stream_error&#160;</td><td class="fielddoc"><p>Stream aborted due to unexpected error. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78aeeed16271ec14658fb1a840778a1fea2" name="aad31759ecbee7d4d2133a5618a053a78aeeed16271ec14658fb1a840778a1fea2"></a>bad_function_call&#160;</td><td class="fielddoc"><p>A function view was called without assigning an actor first. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a094da9add5824bd75d5a77345ceae3e1" name="aad31759ecbee7d4d2133a5618a053a78a094da9add5824bd75d5a77345ceae3e1"></a>feature_disabled&#160;</td><td class="fielddoc"><p>Feature is disabled in the actor system config. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78aac1f4cf357f10c246b3baf4249a5bf54" name="aad31759ecbee7d4d2133a5618a053a78aac1f4cf357f10c246b3baf4249a5bf54"></a>cannot_open_file&#160;</td><td class="fielddoc"><p>Failed to open file. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78aaa37af5140de69d45d25429ebb117c64" name="aad31759ecbee7d4d2133a5618a053a78aaa37af5140de69d45d25429ebb117c64"></a>socket_invalid&#160;</td><td class="fielddoc"><p>A socket descriptor argument is invalid. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a12dc50fa4c160bf4c296cc76f62e1c08" name="aad31759ecbee7d4d2133a5618a053a78a12dc50fa4c160bf4c296cc76f62e1c08"></a>socket_disconnected&#160;</td><td class="fielddoc"><p>A socket became disconnected from the remote host (hang up). </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a63f7dcf058c93eadecbf31a04b91364e" name="aad31759ecbee7d4d2133a5618a053a78a63f7dcf058c93eadecbf31a04b91364e"></a>socket_operation_failed&#160;</td><td class="fielddoc"><p>An operation on a socket (e.g. <code>poll</code>) failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a8f26bd94d3f683889fa8afe778415bc7" name="aad31759ecbee7d4d2133a5618a053a78a8f26bd94d3f683889fa8afe778415bc7"></a>unavailable_or_would_block&#160;</td><td class="fielddoc"><p>A resource is temporarily unavailable or would block. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a3c5b83ab628258751100cdcabaf5971d" name="aad31759ecbee7d4d2133a5618a053a78a3c5b83ab628258751100cdcabaf5971d"></a>incompatible_versions&#160;</td><td class="fielddoc"><p>Connection refused because of incompatible CAF versions. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a6642893019029eb5392c48c23df33a7c" name="aad31759ecbee7d4d2133a5618a053a78a6642893019029eb5392c48c23df33a7c"></a>incompatible_application_ids&#160;</td><td class="fielddoc"><p>Connection refused because of incompatible application IDs. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a14d077ff432a34ef7c3eb283d537048a" name="aad31759ecbee7d4d2133a5618a053a78a14d077ff432a34ef7c3eb283d537048a"></a>malformed_basp_message&#160;</td><td class="fielddoc"><p>The middleman received a malformed BASP message from another node. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78ae700afffc67d712f83909d1dccfe0a45" name="aad31759ecbee7d4d2133a5618a053a78ae700afffc67d712f83909d1dccfe0a45"></a>serializing_basp_payload_failed&#160;</td><td class="fielddoc"><p>The middleman closed a connection because it failed to serialize or deserialize a payload. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a1defcc2f092a086729836d8c2d7ba6ef" name="aad31759ecbee7d4d2133a5618a053a78a1defcc2f092a086729836d8c2d7ba6ef"></a>redundant_connection&#160;</td><td class="fielddoc"><p>The middleman closed a connection to itself or an already connected node. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a059ab9f40c68954d6638cd16b0de78ac" name="aad31759ecbee7d4d2133a5618a053a78a059ab9f40c68954d6638cd16b0de78ac"></a>remote_lookup_failed&#160;</td><td class="fielddoc"><p>Resolving a path on a remote node failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a28f5f35f759489092936a167d1d1e532" name="aad31759ecbee7d4d2133a5618a053a78a28f5f35f759489092936a167d1d1e532"></a>no_tracing_context&#160;</td><td class="fielddoc"><p>Serialization failed because actor_system::tracing_context is null. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a11b3b23cfd05ebb04793fde6ec02aa30" name="aad31759ecbee7d4d2133a5618a053a78a11b3b23cfd05ebb04793fde6ec02aa30"></a>all_requests_failed&#160;</td><td class="fielddoc"><p>No request produced a valid result. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78af1aa7cc385e9bf213707f9cc8c1e3dab" name="aad31759ecbee7d4d2133a5618a053a78af1aa7cc385e9bf213707f9cc8c1e3dab"></a>field_invariant_check_failed&#160;</td><td class="fielddoc"><p>Deserialization failed because an invariant got violated after reading the content of a field. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a73309fa931e6d5e0c9bad76669f41c32" name="aad31759ecbee7d4d2133a5618a053a78a73309fa931e6d5e0c9bad76669f41c32"></a>field_value_synchronization_failed&#160;</td><td class="fielddoc"><p>Deserialization failed because a setter rejected the input. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a975d2ebf2eeb2499c359b46331a9d5b8" name="aad31759ecbee7d4d2133a5618a053a78a975d2ebf2eeb2499c359b46331a9d5b8"></a>invalid_field_type&#160;</td><td class="fielddoc"><p>Deserialization failed because the source announced an invalid type. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78aa50e2449803ba25e376c3eef5ccdfafd" name="aad31759ecbee7d4d2133a5618a053a78aa50e2449803ba25e376c3eef5ccdfafd"></a>unsafe_type&#160;</td><td class="fielddoc"><p>Serialization failed because a type was flagged as unsafe message type. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a263046755e1736d41d45ba04e05786de" name="aad31759ecbee7d4d2133a5618a053a78a263046755e1736d41d45ba04e05786de"></a>save_callback_failed&#160;</td><td class="fielddoc"><p>Serialization failed because a save callback returned <code>false</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78ac04928ba66bb6a2f4e1898402a00f8c7" name="aad31759ecbee7d4d2133a5618a053a78ac04928ba66bb6a2f4e1898402a00f8c7"></a>load_callback_failed&#160;</td><td class="fielddoc"><p>Deserialization failed because a load callback returned <code>false</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a30cd543aac9d9d6e01b647c70848cabd" name="aad31759ecbee7d4d2133a5618a053a78a30cd543aac9d9d6e01b647c70848cabd"></a>conversion_failed&#160;</td><td class="fielddoc"><p>Converting between two types failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a5a4d02758bc275845aca53ff718b3c57" name="aad31759ecbee7d4d2133a5618a053a78a5a4d02758bc275845aca53ff718b3c57"></a>connection_closed&#160;</td><td class="fielddoc"><p>A network connection was closed by the remote side. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a8e9620a3e2665fcf7b8a4b1b69945931" name="aad31759ecbee7d4d2133a5618a053a78a8e9620a3e2665fcf7b8a4b1b69945931"></a>type_clash&#160;</td><td class="fielddoc"><p>An operation failed because run-time type information diverged from the expected type. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78acc640652ae07f015b97e295c1d10a537" name="aad31759ecbee7d4d2133a5618a053a78acc640652ae07f015b97e295c1d10a537"></a>unsupported_operation&#160;</td><td class="fielddoc"><p>An operation failed because the callee does not implement this functionality. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a90001cae602348443ea1dc98bbdd4bf7" name="aad31759ecbee7d4d2133a5618a053a78a90001cae602348443ea1dc98bbdd4bf7"></a>no_such_key&#160;</td><td class="fielddoc"><p>A key lookup failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a2c6bc6062e72db1c0915032943cb6452" name="aad31759ecbee7d4d2133a5618a053a78a2c6bc6062e72db1c0915032943cb6452"></a>broken_promise&#160;</td><td class="fielddoc"><p>An destroyed a response promise without calling deliver or delegate on it. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a3536bed60dc32e8c16f87261b9a17a99" name="aad31759ecbee7d4d2133a5618a053a78a3536bed60dc32e8c16f87261b9a17a99"></a>connection_timeout&#160;</td><td class="fielddoc"><p>Disconnected from a BASP node after reaching the connection timeout. </p>
</td></tr>
<tr><td class="fieldname"><a id="aad31759ecbee7d4d2133a5618a053a78a9063edf6d57bc0142267406a56c17f3b" name="aad31759ecbee7d4d2133a5618a053a78a9063edf6d57bc0142267406a56c17f3b"></a>action_reschedule_failed&#160;</td><td class="fielddoc"><p>Signals that an actor fell behind a periodic action trigger. </p>
<p>After raising this error, an <a class="el" href="classcaf_1_1actor__clock.html">actor_clock</a> stops scheduling the action. </p>
</td></tr>
</table>

</div>
</div>
<a id="acb3512d365fcd27e9b37110c7fcdd6b4" name="acb3512d365fcd27e9b37110c7fcdd6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3512d365fcd27e9b37110c7fcdd6b4">&#9670;&#160;</a></span>stream_priority</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacecaf.html#acb3512d365fcd27e9b37110c7fcdd6b4">caf::stream_priority</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Categorizes individual streams. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acb3512d365fcd27e9b37110c7fcdd6b4aaa4cea18ae7516f9a3c28d597055082f" name="acb3512d365fcd27e9b37110c7fcdd6b4aaa4cea18ae7516f9a3c28d597055082f"></a>very_high&#160;</td><td class="fielddoc"><p>Denotes soft-realtime traffic. </p>
</td></tr>
<tr><td class="fieldname"><a id="acb3512d365fcd27e9b37110c7fcdd6b4a8d966b2253a917086c8604959e152243" name="acb3512d365fcd27e9b37110c7fcdd6b4a8d966b2253a917086c8604959e152243"></a>high&#160;</td><td class="fielddoc"><p>Denotes time-sensitive traffic. </p>
</td></tr>
<tr><td class="fieldname"><a id="acb3512d365fcd27e9b37110c7fcdd6b4afea087517c26fadd409bd4b9dc642555" name="acb3512d365fcd27e9b37110c7fcdd6b4afea087517c26fadd409bd4b9dc642555"></a>normal&#160;</td><td class="fielddoc"><p>Denotes traffic with moderate timing requirements. </p>
</td></tr>
<tr><td class="fieldname"><a id="acb3512d365fcd27e9b37110c7fcdd6b4a53cced8d281a1a0ace3cb6594daaa4f7" name="acb3512d365fcd27e9b37110c7fcdd6b4a53cced8d281a1a0ace3cb6594daaa4f7"></a>low&#160;</td><td class="fielddoc"><p>Denotes uncritical traffic without timing requirements. </p>
</td></tr>
<tr><td class="fieldname"><a id="acb3512d365fcd27e9b37110c7fcdd6b4ab7619bc8e14fe34d78820f979605ee8b" name="acb3512d365fcd27e9b37110c7fcdd6b4ab7619bc8e14fe34d78820f979605ee8b"></a>very_low&#160;</td><td class="fielddoc"><p>Denotes best-effort traffic. </p>
</td></tr>
</table>

</div>
</div>
<a id="aa601da0abafbe531a0068d454c7e8ccc" name="aa601da0abafbe531a0068d454c7e8ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa601da0abafbe531a0068d454c7e8ccc">&#9670;&#160;</a></span>term</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacecaf.html#aa601da0abafbe531a0068d454c7e8ccc">caf::term</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Terminal color and font face options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8ccca86266ee937d97f812a8e57d22b62ee29" name="aa601da0abafbe531a0068d454c7e8ccca86266ee937d97f812a8e57d22b62ee29"></a>reset&#160;</td><td class="fielddoc"><p>Resets the color to the default color and the font weight to normal. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8ccca3cf983ff848c5f880c537d8cef3e76c3" name="aa601da0abafbe531a0068d454c7e8ccca3cf983ff848c5f880c537d8cef3e76c3"></a>reset_endl&#160;</td><td class="fielddoc"><p>Like <code>reset</code> but also prints a newline. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8ccca1ffd9e753c8054cc61456ac7fac1ac89" name="aa601da0abafbe531a0068d454c7e8ccca1ffd9e753c8054cc61456ac7fac1ac89"></a>black&#160;</td><td class="fielddoc"><p>Sets the terminal color to black. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8cccabda9643ac6601722a28f238714274da4" name="aa601da0abafbe531a0068d454c7e8cccabda9643ac6601722a28f238714274da4"></a>red&#160;</td><td class="fielddoc"><p>Sets the terminal color to red. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8ccca9f27410725ab8cc8854a2769c7a516b8" name="aa601da0abafbe531a0068d454c7e8ccca9f27410725ab8cc8854a2769c7a516b8"></a>green&#160;</td><td class="fielddoc"><p>Sets the terminal color to green. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8cccad487dd0b55dfcacdd920ccbdaeafa351" name="aa601da0abafbe531a0068d454c7e8cccad487dd0b55dfcacdd920ccbdaeafa351"></a>yellow&#160;</td><td class="fielddoc"><p>Sets the terminal color to yellow. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8ccca48d6215903dff56238e52e8891380c8f" name="aa601da0abafbe531a0068d454c7e8ccca48d6215903dff56238e52e8891380c8f"></a>blue&#160;</td><td class="fielddoc"><p>Sets the terminal color to blue. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8ccca4c2a4a7078da0ac6733464eacfd00f86" name="aa601da0abafbe531a0068d454c7e8ccca4c2a4a7078da0ac6733464eacfd00f86"></a>magenta&#160;</td><td class="fielddoc"><p>Sets the terminal color to magenta. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8ccca6411532ba4971f378391776a9db629d3" name="aa601da0abafbe531a0068d454c7e8ccca6411532ba4971f378391776a9db629d3"></a>cyan&#160;</td><td class="fielddoc"><p>Sets the terminal color to cyan. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8cccad508fe45cecaf653904a0e774084bb5c" name="aa601da0abafbe531a0068d454c7e8cccad508fe45cecaf653904a0e774084bb5c"></a>white&#160;</td><td class="fielddoc"><p>Sets the terminal color to white. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8ccca5f9b622730053f7063ada5e969325e64" name="aa601da0abafbe531a0068d454c7e8ccca5f9b622730053f7063ada5e969325e64"></a>bold_black&#160;</td><td class="fielddoc"><p>Sets the terminal color to black and the font weight to bold. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8cccabb3d08e30223136bcfd186360e97e4f7" name="aa601da0abafbe531a0068d454c7e8cccabb3d08e30223136bcfd186360e97e4f7"></a>bold_red&#160;</td><td class="fielddoc"><p>Sets the terminal color to red and the font weight to bold. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8ccca797c3638f6188754f08441b1ecc5613c" name="aa601da0abafbe531a0068d454c7e8ccca797c3638f6188754f08441b1ecc5613c"></a>bold_green&#160;</td><td class="fielddoc"><p>Sets the terminal color to green and the font weight to bold. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8ccca6366363dc00bb036c6027c8919dabb64" name="aa601da0abafbe531a0068d454c7e8ccca6366363dc00bb036c6027c8919dabb64"></a>bold_yellow&#160;</td><td class="fielddoc"><p>Sets the terminal color to yellow and the font weight to bold. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8ccca1f23307b7fb5697014697d14a225ba18" name="aa601da0abafbe531a0068d454c7e8ccca1f23307b7fb5697014697d14a225ba18"></a>bold_blue&#160;</td><td class="fielddoc"><p>Sets the terminal color to blue and the font weight to bold. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8ccca83bf3e2728755397fe9ce2ba7f583add" name="aa601da0abafbe531a0068d454c7e8ccca83bf3e2728755397fe9ce2ba7f583add"></a>bold_magenta&#160;</td><td class="fielddoc"><p>Sets the terminal color to magenta and the font weight to bold. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8cccab50236763fd3f98a2414e91c208ac5e0" name="aa601da0abafbe531a0068d454c7e8cccab50236763fd3f98a2414e91c208ac5e0"></a>bold_cyan&#160;</td><td class="fielddoc"><p>Sets the terminal color to cyan and the font weight to bold. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa601da0abafbe531a0068d454c7e8cccaeb5e1e280820375730b379c984c34697" name="aa601da0abafbe531a0068d454c7e8cccaeb5e1e280820375730b379c984c34697"></a>bold_white&#160;</td><td class="fielddoc"><p>Sets the terminal color to white and the font weight to bold. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a93b4b7d9d353b3a8287fdc43a44636dd" name="a93b4b7d9d353b3a8287fdc43a44636dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b4b7d9d353b3a8287fdc43a44636dd">&#9670;&#160;</a></span>attach_continuous_stream_source() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Init , class Pull , class Done , class Finalize  = unit_t, class Trait  = stream_source_trait_t&lt;Pull&gt;, class DownstreamManager  = broadcast_downstream_manager&lt;            typename Trait::output&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcaf_1_1intrusive__ptr.html">stream_source_ptr</a>&lt; DownstreamManager &gt; caf::attach_continuous_stream_source </td>
          <td>(</td>
          <td class="paramtype">scheduled_actor *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Init&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pull&#160;</td>
          <td class="paramname"><em>pull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Done&#160;</td>
          <td class="paramname"><em>done</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Finalize&#160;</td>
          <td class="paramname"><em>fin</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt;&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new continuous stream source by instantiating the default source implementation with <code>Driver</code>. </p>
<p>The returned manager is not connected to any slot and thus not stored by the actor automatically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Points to the hosting actor. </td></tr>
    <tr><td class="paramname">init</td><td>Function object for initializing the state of the source. </td></tr>
    <tr><td class="paramname">pull</td><td>Generator function object for producing downstream messages. </td></tr>
    <tr><td class="paramname">done</td><td>Predicate returning <code>true</code> when generator is done. </td></tr>
    <tr><td class="paramname">fin</td><td>Cleanup handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new <code><a class="el" href="classcaf_1_1stream__manager.html" title="Manages a single stream with any number of in- and outbound paths.">stream_manager</a></code>. </dd></dl>

</div>
</div>
<a id="a2a48dbfc20607bdc4fc5d35ec9e30e91" name="a2a48dbfc20607bdc4fc5d35ec9e30e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a48dbfc20607bdc4fc5d35ec9e30e91">&#9670;&#160;</a></span>attach_continuous_stream_source() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Driver , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Driver::source_ptr_type caf::attach_continuous_stream_source </td>
          <td>(</td>
          <td class="paramtype">scheduled_actor *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>xs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new continuous stream source by instantiating the default source implementation with <code>Driver</code>. </p>
<p>The returned manager is not connected to any slot and thus not stored by the actor automatically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Points to the hosting actor. </td></tr>
    <tr><td class="paramname">xs</td><td>Parameter pack for constructing the driver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new <code><a class="el" href="classcaf_1_1stream__manager.html" title="Manages a single stream with any number of in- and outbound paths.">stream_manager</a></code>. </dd></dl>

</div>
</div>
<a id="a65dfde35ab4e7d585aac7717f4e573bf" name="a65dfde35ab4e7d585aac7717f4e573bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65dfde35ab4e7d585aac7717f4e573bf">&#9670;&#160;</a></span>attach_continuous_stream_stage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Init , class Fun , class Finalize  = unit_t, class DownstreamManager  = default_downstream_manager_t&lt;Fun&gt;, class Trait  = stream_stage_trait_t&lt;Fun&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcaf_1_1intrusive__ptr.html">stream_stage_ptr</a>&lt; typename Trait::input, DownstreamManager &gt; caf::attach_continuous_stream_stage </td>
          <td>(</td>
          <td class="paramtype">scheduled_actor *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Init&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Finalize&#160;</td>
          <td class="paramname"><em>fin</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Points to the hosting actor. </td></tr>
    <tr><td class="paramname">init</td><td>Function object for initializing the state of the stage. </td></tr>
    <tr><td class="paramname">fun</td><td>Processing function. </td></tr>
    <tr><td class="paramname">fin</td><td>Optional cleanup handler. </td></tr>
    <tr><td class="paramname">token</td><td>Policy token for selecting a downstream manager implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92f8bd34b9566a65b10e3bead8b17e67" name="a92f8bd34b9566a65b10e3bead8b17e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f8bd34b9566a65b10e3bead8b17e67">&#9670;&#160;</a></span>attach_continuous_stream_stage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Driver , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Driver::stage_ptr_type caf::attach_continuous_stream_stage </td>
          <td>(</td>
          <td class="paramtype">scheduled_actor *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>xs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a stream manager (implementing a continuous stage) without in- or outbound path. </p>
<p>The returned manager is not connected to any slot and thus not stored by the actor automatically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Points to the hosting actor. </td></tr>
    <tr><td class="paramname">xs</td><td>User-defined arguments for the downstream handshake. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new <code><a class="el" href="classcaf_1_1stream__manager.html" title="Manages a single stream with any number of in- and outbound paths.">stream_manager</a></code>. </dd></dl>

</div>
</div>
<a id="a2f83bc671410a202c06545ec0f4b6891" name="a2f83bc671410a202c06545ec0f4b6891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f83bc671410a202c06545ec0f4b6891">&#9670;&#160;</a></span>attach_stream_sink() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class In , class Init , class Fun , class Finalize  = unit_t, class Trait  = stream_sink_trait_t&lt;Fun&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcaf_1_1make__sink__result.html">make_sink_result</a>&lt; In &gt; caf::attach_stream_sink </td>
          <td>(</td>
          <td class="paramtype">scheduled_actor *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcaf_1_1stream.html">stream</a>&lt; In &gt;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Init&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Finalize&#160;</td>
          <td class="paramname"><em>fin</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a new stream sink to <code>self</code> by creating a default stream sink manager from given callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Points to the hosting actor. </td></tr>
    <tr><td class="paramname">in</td><td>Stream handshake from upstream path. </td></tr>
    <tr><td class="paramname">init</td><td>Function object for initializing the state of the sink. </td></tr>
    <tr><td class="paramname">fun</td><td>Processing function. </td></tr>
    <tr><td class="paramname">fin</td><td>Optional cleanup handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new <code><a class="el" href="classcaf_1_1stream__manager.html" title="Manages a single stream with any number of in- and outbound paths.">stream_manager</a></code> and the inbound slot. </dd></dl>

</div>
</div>
<a id="a0642bbc8ae541d35cffc39cf0809f23a" name="a0642bbc8ae541d35cffc39cf0809f23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0642bbc8ae541d35cffc39cf0809f23a">&#9670;&#160;</a></span>attach_stream_sink() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Driver , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcaf_1_1make__sink__result.html">make_sink_result</a>&lt; typename Driver::input_type &gt; caf::attach_stream_sink </td>
          <td>(</td>
          <td class="paramtype">scheduled_actor *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcaf_1_1stream.html">stream</a>&lt; typename Driver::input_type &gt;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>xs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a new stream sink to <code>self</code> by creating a default stream sink / manager from given callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Points to the hosting actor. </td></tr>
    <tr><td class="paramname">xs</td><td>Additional constructor arguments for <code>Driver</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new <code><a class="el" href="classcaf_1_1stream__manager.html" title="Manages a single stream with any number of in- and outbound paths.">stream_manager</a></code>, an inbound slot, and an outbound slot. </dd></dl>

</div>
</div>
<a id="ae1b6ed4f952ae93fdf415d0128cd9691" name="ae1b6ed4f952ae93fdf415d0128cd9691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b6ed4f952ae93fdf415d0128cd9691">&#9670;&#160;</a></span>attach_stream_source() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ActorHandle , class Init , class Pull , class Done , class Finalize  = unit_t, class DownstreamManager  = default_downstream_manager_t&lt;Pull&gt;, class Trait  = stream_source_trait_t&lt;Pull&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::enable_if_t&lt; <a class="el" href="structcaf_1_1is__actor__handle.html">is_actor_handle</a>&lt; ActorHandle &gt;::value &amp;&amp;Trait::valid, make_source_result_t&lt; DownstreamManager &gt; &gt; caf::attach_stream_source </td>
          <td>(</td>
          <td class="paramtype">scheduled_actor *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ActorHandle &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Init&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pull&#160;</td>
          <td class="paramname"><em>pull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Done&#160;</td>
          <td class="paramname"><em>done</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Finalize&#160;</td>
          <td class="paramname"><em>fin</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a new stream source to <code>self</code> by creating a default stream source manager with the default driver and starts sending to <code>dest</code> immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Points to the hosting actor. </td></tr>
    <tr><td class="paramname">dest</td><td>Handle to the next stage in the pipeline. </td></tr>
    <tr><td class="paramname">init</td><td>Function object for initializing the state of the source. </td></tr>
    <tr><td class="paramname">pull</td><td>Generator function object for producing downstream messages. </td></tr>
    <tr><td class="paramname">done</td><td>Predicate returning <code>true</code> when generator is done. </td></tr>
    <tr><td class="paramname">fin</td><td>Cleanup handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated <code><a class="el" href="classcaf_1_1stream__manager.html" title="Manages a single stream with any number of in- and outbound paths.">stream_manager</a></code> and the output slot. </dd></dl>

</div>
</div>
<a id="a25071db301bf0c57d0113939c2981913" name="a25071db301bf0c57d0113939c2981913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25071db301bf0c57d0113939c2981913">&#9670;&#160;</a></span>attach_stream_source() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ActorHandle , class... Ts, class Init , class Pull , class Done , class Finalize  = unit_t, class DownstreamManager  = default_downstream_manager_t&lt;Pull&gt;, class Trait  = stream_source_trait_t&lt;Pull&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::enable_if_t&lt; <a class="el" href="structcaf_1_1is__actor__handle.html">is_actor_handle</a>&lt; ActorHandle &gt;::value, make_source_result_t&lt; DownstreamManager &gt; &gt; caf::attach_stream_source </td>
          <td>(</td>
          <td class="paramtype">scheduled_actor *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ActorHandle &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Ts... &gt;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Init&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pull&#160;</td>
          <td class="paramname"><em>pull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Done&#160;</td>
          <td class="paramname"><em>done</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Finalize&#160;</td>
          <td class="paramname"><em>fin</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt;&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a new stream source to <code>self</code> by creating a default stream source manager with the default driver and starts sending to <code>dest</code> immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Points to the hosting actor. </td></tr>
    <tr><td class="paramname">dest</td><td>Handle to the next stage in the pipeline. </td></tr>
    <tr><td class="paramname">xs</td><td>User-defined arguments for the stream handshake. </td></tr>
    <tr><td class="paramname">init</td><td>Function object for initializing the state of the source. </td></tr>
    <tr><td class="paramname">pull</td><td>Generator function object for producing downstream messages. </td></tr>
    <tr><td class="paramname">done</td><td>Predicate returning <code>true</code> when generator is done. </td></tr>
    <tr><td class="paramname">fin</td><td>Cleanup handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated <code><a class="el" href="classcaf_1_1stream__manager.html" title="Manages a single stream with any number of in- and outbound paths.">stream_manager</a></code> and the output slot. </dd></dl>

</div>
</div>
<a id="a8db77aa018331be6ebcaa1dfb762be26" name="a8db77aa018331be6ebcaa1dfb762be26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db77aa018331be6ebcaa1dfb762be26">&#9670;&#160;</a></span>attach_stream_source() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Init , class Pull , class Done , class Finalize  = unit_t, class DownstreamManager  = default_downstream_manager_t&lt;Pull&gt;, class Trait  = stream_source_trait_t&lt;Pull&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::enable_if_t&lt;!<a class="el" href="structcaf_1_1is__actor__handle.html">is_actor_handle</a>&lt; Init &gt;::value &amp;&amp;Trait::valid, make_source_result_t&lt; DownstreamManager &gt; &gt; caf::attach_stream_source </td>
          <td>(</td>
          <td class="paramtype">scheduled_actor *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Init&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pull&#160;</td>
          <td class="paramname"><em>pull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Done&#160;</td>
          <td class="paramname"><em>done</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Finalize&#160;</td>
          <td class="paramname"><em>fin</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a new stream source to <code>self</code> by creating a default stream source manager with the default driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Points to the hosting actor. </td></tr>
    <tr><td class="paramname">init</td><td>Function object for initializing the state of the source. </td></tr>
    <tr><td class="paramname">pull</td><td>Generator function object for producing downstream messages. </td></tr>
    <tr><td class="paramname">done</td><td>Predicate returning <code>true</code> when generator is done. </td></tr>
    <tr><td class="paramname">fin</td><td>Cleanup handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated <code><a class="el" href="classcaf_1_1stream__manager.html" title="Manages a single stream with any number of in- and outbound paths.">stream_manager</a></code> and the output slot. </dd></dl>

</div>
</div>
<a id="ac80b3de17d280ae1814cb99305dead40" name="ac80b3de17d280ae1814cb99305dead40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80b3de17d280ae1814cb99305dead40">&#9670;&#160;</a></span>attach_stream_source() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Driver , class... Ts, class... CtorArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">make_source_result_t&lt; typename Driver::downstream_manager_type, Ts... &gt; caf::attach_stream_source </td>
          <td>(</td>
          <td class="paramtype">scheduled_actor *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Ts... &gt;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CtorArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ctor_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a new stream source to <code>self</code> by creating a default stream source manager with <code>Driver</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Points to the hosting actor. </td></tr>
    <tr><td class="paramname">xs</td><td>User-defined arguments for the stream handshake. </td></tr>
    <tr><td class="paramname">ctor_args</td><td>Parameter pack for constructing the driver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated <code><a class="el" href="classcaf_1_1stream__manager.html" title="Manages a single stream with any number of in- and outbound paths.">stream_manager</a></code> and the output slot. </dd></dl>

</div>
</div>
<a id="a994e986fde8a2b2a80a9e362fe597eb9" name="a994e986fde8a2b2a80a9e362fe597eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994e986fde8a2b2a80a9e362fe597eb9">&#9670;&#160;</a></span>attach_stream_source() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts, class Init , class Pull , class Done , class Finalize  = unit_t, class Trait  = stream_source_trait_t&lt;Pull&gt;, class DownstreamManager  = broadcast_downstream_manager&lt;            typename Trait::output&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">make_source_result_t&lt; DownstreamManager, Ts... &gt; caf::attach_stream_source </td>
          <td>(</td>
          <td class="paramtype">scheduled_actor *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Ts... &gt;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Init&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pull&#160;</td>
          <td class="paramname"><em>pull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Done&#160;</td>
          <td class="paramname"><em>done</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Finalize&#160;</td>
          <td class="paramname"><em>fin</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt;&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a new stream source to <code>self</code> by creating a default stream source manager with the default driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Points to the hosting actor. </td></tr>
    <tr><td class="paramname">xs</td><td>User-defined arguments for the stream handshake. </td></tr>
    <tr><td class="paramname">init</td><td>Function object for initializing the state of the source. </td></tr>
    <tr><td class="paramname">pull</td><td>Generator function object for producing downstream messages. </td></tr>
    <tr><td class="paramname">done</td><td>Predicate returning <code>true</code> when generator is done. </td></tr>
    <tr><td class="paramname">fin</td><td>Cleanup handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated <code><a class="el" href="classcaf_1_1stream__manager.html" title="Manages a single stream with any number of in- and outbound paths.">stream_manager</a></code> and the output slot. </dd></dl>

</div>
</div>
<a id="ad174b610a0d4250177cce3d57cd9378d" name="ad174b610a0d4250177cce3d57cd9378d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad174b610a0d4250177cce3d57cd9378d">&#9670;&#160;</a></span>attach_stream_stage() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class In , class Init , class Fun , class Finalize  = unit_t, class DownstreamManager  = default_downstream_manager_t&lt;Fun&gt;, class Trait  = stream_stage_trait_t&lt;Fun&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecaf.html#ac4f35acd9e6d9f1214f1fee72993632b">make_stage_result_t</a>&lt; In, DownstreamManager &gt; caf::attach_stream_stage </td>
          <td>(</td>
          <td class="paramtype">scheduled_actor *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcaf_1_1stream.html">stream</a>&lt; In &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Init&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Finalize&#160;</td>
          <td class="paramname"><em>fin</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a new stream stage to <code>self</code> by creating a default stream stage manager from given callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Points to the hosting actor. </td></tr>
    <tr><td class="paramname">in</td><td>Stream handshake from upstream path. </td></tr>
    <tr><td class="paramname">init</td><td>Function object for initializing the state of the stage. </td></tr>
    <tr><td class="paramname">fun</td><td>Processing function. </td></tr>
    <tr><td class="paramname">fin</td><td>Optional cleanup handler. </td></tr>
    <tr><td class="paramname">token</td><td>Policy token for selecting a downstream manager implementation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new <code><a class="el" href="classcaf_1_1stream__manager.html" title="Manages a single stream with any number of in- and outbound paths.">stream_manager</a></code>, an inbound slot, and an outbound slot. </dd></dl>

</div>
</div>
<a id="a6227520338c0c0cd0110027c4245796b" name="a6227520338c0c0cd0110027c4245796b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6227520338c0c0cd0110027c4245796b">&#9670;&#160;</a></span>attach_stream_stage() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class In , class... Ts, class Init , class Fun , class Finalize  = unit_t, class DownstreamManager  = default_downstream_manager_t&lt;Fun&gt;, class Trait  = stream_stage_trait_t&lt;Fun&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecaf.html#ac4f35acd9e6d9f1214f1fee72993632b">make_stage_result_t</a>&lt; In, DownstreamManager, Ts... &gt; caf::attach_stream_stage </td>
          <td>(</td>
          <td class="paramtype">scheduled_actor *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcaf_1_1stream.html">stream</a>&lt; In &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Ts... &gt;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Init&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Finalize&#160;</td>
          <td class="paramname"><em>fin</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcaf_1_1policy_1_1arg.html">policy::arg</a>&lt; DownstreamManager &gt;&#160;</td>
          <td class="paramname"><em>token</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a new stream stage to <code>self</code> by creating a default stream stage manager from given callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Points to the hosting actor. </td></tr>
    <tr><td class="paramname">in</td><td>Stream handshake from upstream path. </td></tr>
    <tr><td class="paramname">xs</td><td>User-defined arguments for the downstream handshake. </td></tr>
    <tr><td class="paramname">init</td><td>Function object for initializing the state of the stage. </td></tr>
    <tr><td class="paramname">fun</td><td>Processing function. </td></tr>
    <tr><td class="paramname">fin</td><td>Optional cleanup handler. </td></tr>
    <tr><td class="paramname">token</td><td>Policy token for selecting a downstream manager implementation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new <code><a class="el" href="classcaf_1_1stream__manager.html" title="Manages a single stream with any number of in- and outbound paths.">stream_manager</a></code>, an inbound slot, and an outbound slot. </dd></dl>

</div>
</div>
<a id="a3297ece14ba4363d1d0eac988820370a" name="a3297ece14ba4363d1d0eac988820370a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3297ece14ba4363d1d0eac988820370a">&#9670;&#160;</a></span>attach_stream_stage() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Driver , class In , class... Ts, class... Us&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecaf.html#ac4f35acd9e6d9f1214f1fee72993632b">make_stage_result_t</a>&lt; In, typename Driver::downstream_manager_type, Ts... &gt; caf::attach_stream_stage </td>
          <td>(</td>
          <td class="paramtype">scheduled_actor *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcaf_1_1stream.html">stream</a>&lt; In &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Ts... &gt;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Us &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches a new stream stage to <code>self</code> by creating a default stream stage manager with <code>Driver</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Points to the hosting actor. </td></tr>
    <tr><td class="paramname">in</td><td>Stream handshake from upstream path. </td></tr>
    <tr><td class="paramname">xs</td><td>User-defined arguments for the downstream handshake. </td></tr>
    <tr><td class="paramname">ys</td><td>Additional constructor arguments for <code>Driver</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new <code><a class="el" href="classcaf_1_1stream__manager.html" title="Manages a single stream with any number of in- and outbound paths.">stream_manager</a></code>, an inbound slot, and an outbound slot. </dd></dl>

</div>
</div>
<a id="ace7f4ed8d2f4066779b6192b106225d2" name="ace7f4ed8d2f4066779b6192b106225d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7f4ed8d2f4066779b6192b106225d2">&#9670;&#160;</a></span>deep_to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string caf::deep_to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls collections such as vectors/maps, decomposes tuples/pairs/arrays, auto-escapes strings and calls <code>to_string</code> for user-defined types via argument-dependent loopkup (ADL). </p>
<p>Any user-defined type that does not provide a <code>to_string</code> is mapped to <code>&lt;unprintable&gt;</code>. </p>

</div>
</div>
<a id="ae060c36113f25850a252a9ec5f91dc78" name="ae060c36113f25850a252a9ec5f91dc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae060c36113f25850a252a9ec5f91dc78">&#9670;&#160;</a></span>default_enum_inspect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Inspector , class Enumeration &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool caf::default_enum_inspect </td>
          <td>(</td>
          <td class="paramtype">Inspector &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Enumeration &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for providing a default inspection scaffold for custom enumeration types. </p>
<p>The enumeration type must provide the following interface based on free functions:</p>
<div class="fragment"><div class="line"> {(cpp)}</div>
<div class="line"><span class="keyword">enum class</span> Enumeration : ... { ... };</div>
<div class="line">std::string to_string(Enumeration);</div>
<div class="line"><span class="keywordtype">bool</span> from_string(string_view, Enumeration&amp;);</div>
<div class="line"><span class="keywordtype">bool</span> from_integer(std::underlying_type_t&lt;Enumeration&gt;, Enumeration&amp;);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a566d584bfa9c78437f22c19b6815f868" name="a566d584bfa9c78437f22c19b6815f868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566d584bfa9c78437f22c19b6815f868">&#9670;&#160;</a></span>find_by_long_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class Sentinel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; ForwardIterator, <a class="el" href="classcaf_1_1string__view.html">string_view</a> &gt; caf::find_by_long_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcaf_1_1config__option.html">config_option</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds <code><a class="el" href="classcaf_1_1config__option.html" title="Defines a configuration option for the application.">config_option</a></code> string with a matching long name in (<code>first</code>, <code>last</code>], where each entry is a pointer to a string. </p>
<p>Returns a <code>ForwardIterator</code> to the match and a <code><a class="el" href="classcaf_1_1string__view.html" title="Drop-in replacement for C++17 std::string_view.">caf::string_view</a></code> of the option value if the entry is found and a <code>ForwardIterator</code> to <code>last</code> with an empty <code><a class="el" href="classcaf_1_1string__view.html" title="Drop-in replacement for C++17 std::string_view.">string_view</a></code> otherwise. </p>

</div>
</div>
<a id="ac323494144a0417c656f7970d508a962" name="ac323494144a0417c656f7970d508a962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac323494144a0417c656f7970d508a962">&#9670;&#160;</a></span>init_global_meta_objects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProjectIds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void caf::init_global_meta_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the global meta object table with all types in <code>ProjectIds</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>calling this after constructing any ::actor_system is unsafe and causes undefined behavior. </dd></dl>

</div>
</div>
<a id="a26607dc21bd50d5914cb19f886e040e2" name="a26607dc21bd50d5914cb19f886e040e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26607dc21bd50d5914cb19f886e040e2">&#9670;&#160;</a></span>init_global_meta_objects_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProjectIds , uint16_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void caf::init_global_meta_objects_impl </td>
          <td>(</td>
          <td class="paramtype">std::integer_sequence&lt; uint16_t, Is... &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>calling this after constructing any ::actor_system is unsafe and causes undefined behavior. </dd></dl>

</div>
</div>
<a id="a2e94a756127f21081dee74a570ac25a2" name="a2e94a756127f21081dee74a570ac25a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e94a756127f21081dee74a570ac25a2">&#9670;&#160;</a></span>make_action()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcaf_1_1action.html">action</a> caf::make_action </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcaf_1_1action.html#a8c8ca1629afa927e277da0d8133ad981">action::state</a>&#160;</td>
          <td class="paramname"><em>init_state</em> = <code><a class="el" href="classcaf_1_1action.html#a8c8ca1629afa927e277da0d8133ad981a638a6d925c422c868b28b9562498ea1d">action::state::scheduled</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for creating <a class="el" href="classcaf_1_1action.html">action</a> objects from a function object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The body for the action. </td></tr>
    <tr><td class="paramname">init_state</td><td>either <code><a class="el" href="classcaf_1_1action.html#a8c8ca1629afa927e277da0d8133ad981a638a6d925c422c868b28b9562498ea1d" title="The action may no longer run.">action::state::scheduled</a></code> or <code><a class="el" href="classcaf_1_1action.html#a8c8ca1629afa927e277da0d8133ad981acb05cab65afefab8fd3831d92cfc68be" title="The action fired and needs rescheduling before running again.">action::state::waiting</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a6020da26e171f9095bcd192028c8e3" name="a3a6020da26e171f9095bcd192028c8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6020da26e171f9095bcd192028c8e3">&#9670;&#160;</a></span>make_mtl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Self , class Adapter , class Reader &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto caf::make_mtl </td>
          <td>(</td>
          <td class="paramtype">Self *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Adapter&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reader *&#160;</td>
          <td class="paramname"><em>reader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an MTL (message translation layer) to enable an actor to exchange messages with non-CAF endpoints over a user-defined data exchange format such as JSON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Points to an event-based or blocking actor. </td></tr>
    <tr><td class="paramname">adapter</td><td>Translates between internal and external message types. </td></tr>
    <tr><td class="paramname">reader</td><td>Points to an object that either implements the interface <a class="el" href="classcaf_1_1deserializer.html">deserializer</a> directly or that provides a compatible API. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac55f287d51075c5edac2fdc9a683c7d4" name="ac55f287d51075c5edac2fdc9a683c7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55f287d51075c5edac2fdc9a683c7d4">&#9670;&#160;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcaf_1_1config__value.html">config_value</a> &amp; caf::put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcaf_1_1dictionary.html">settings</a> &amp;&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcaf_1_1string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts <code>value</code> to a <code><a class="el" href="classcaf_1_1config__value.html" title="A type for config parameters with similar interface to a variant.">config_value</a></code> and assigns it to <code>key</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dict</td><td>Dictionary of key-value pairs. </td></tr>
    <tr><td class="paramname">key</td><td>Human-readable nested keys in the form <code>category.key</code>. </td></tr>
    <tr><td class="paramname">value</td><td>New value for given <code>key</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa029eb47370d782d02a9cad74a1a993b" name="aa029eb47370d782d02a9cad74a1a993b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa029eb47370d782d02a9cad74a1a993b">&#9670;&#160;</a></span>put_dictionary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CAF_CORE_EXPORT <a class="el" href="classcaf_1_1dictionary.html">config_value::dictionary</a> &amp; caf::put_dictionary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcaf_1_1dictionary.html">settings</a> &amp;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new list named <code>name</code> into the dictionary <code>xs</code> and returns a reference to it. </p>
<p>Overrides existing entries with the same name. </p>

</div>
</div>
<a id="a9b5fdd857461d9a91e1eee478fa27f9c" name="a9b5fdd857461d9a91e1eee478fa27f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5fdd857461d9a91e1eee478fa27f9c">&#9670;&#160;</a></span>put_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CAF_CORE_EXPORT config_value::list &amp; caf::put_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcaf_1_1dictionary.html">settings</a> &amp;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new list named <code>name</code> into the dictionary <code>xs</code> and returns a reference to it. </p>
<p>Overrides existing entries with the same name. </p>

</div>
</div>
<a id="a8002dc38e09d902866cadbe8072ba7fa" name="a8002dc38e09d902866cadbe8072ba7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8002dc38e09d902866cadbe8072ba7fa">&#9670;&#160;</a></span>put_missing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void caf::put_missing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcaf_1_1dictionary.html">settings</a> &amp;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcaf_1_1string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts <code>value</code> to a <code><a class="el" href="classcaf_1_1config__value.html" title="A type for config parameters with similar interface to a variant.">config_value</a></code> and assigns it to <code>key</code> unless <code>xs</code> already contains <code>key</code> (does nothing in this case). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>Dictionary of key-value pairs. </td></tr>
    <tr><td class="paramname">key</td><td>Human-readable nested keys in the form <code>category.key</code>. </td></tr>
    <tr><td class="paramname">value</td><td>New value for given <code>key</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a843669aeffc99e0fc80664b6731f77c4" name="a843669aeffc99e0fc80664b6731f77c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843669aeffc99e0fc80664b6731f77c4">&#9670;&#160;</a></span>invalid_type_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacecaf.html#a44855080188b6693187137bd666c7eb4">type_id_t</a> caf::invalid_type_id = 65535</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Special value equal to the greatest possible value for <code>type_id_t</code>. </p>
<p>Generally indicates that no type ID for a given type exists. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
