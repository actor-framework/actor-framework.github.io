<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ Actor Framework: Creating Actors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C++ Actor Framework<span id="projectnumber">&#160;0.19</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Creating Actors</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga291d9d4fcae86cf8d3de7d28c500a308" id="r_ga291d9d4fcae86cf8d3de7d28c500a308"><td class="memItemLeft" align="right" valign="top"><a id="ga291d9d4fcae86cf8d3de7d28c500a308" name="ga291d9d4fcae86cf8d3de7d28c500a308"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga291d9d4fcae86cf8d3de7d28c500a308">caf::spawn_options</a> : int { <br />
&#160;&#160;<b>no_flags</b> = 0x00
, <br />
&#160;&#160;<b>link_flag</b> = 0x01
, <br />
&#160;&#160;<b>monitor_flag</b> = 0x02
, <br />
&#160;&#160;<b>detach_flag</b> = 0x04
, <br />
&#160;&#160;<b>hide_flag</b> = 0x08
, <br />
&#160;&#160;<b>priority_aware_flag</b> = 0x20
, <br />
&#160;&#160;<b>lazy_init_flag</b> = 0x40
<br />
 }</td></tr>
<tr class="memdesc:ga291d9d4fcae86cf8d3de7d28c500a308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores options passed to the <code>spawn</code> function family. <br /></td></tr>
<tr class="separator:ga291d9d4fcae86cf8d3de7d28c500a308"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabd9d6b3e5da22eec85ea53017bfe3b4a" id="r_gabd9d6b3e5da22eec85ea53017bfe3b4a"><td class="memItemLeft" align="right" valign="top"><a id="gabd9d6b3e5da22eec85ea53017bfe3b4a" name="gabd9d6b3e5da22eec85ea53017bfe3b4a"></a>
constexpr <a class="el" href="#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><b>caf::operator+</b> (<a class="el" href="#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a> x, <a class="el" href="#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a> y)</td></tr>
<tr class="memdesc:gabd9d6b3e5da22eec85ea53017bfe3b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two <code><a class="el" href="#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a></code>. <br /></td></tr>
<tr class="separator:gabd9d6b3e5da22eec85ea53017bfe3b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a83f81fc67957df87596f813159ba4" id="r_gac1a83f81fc67957df87596f813159ba4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac1a83f81fc67957df87596f813159ba4">caf::has_lazy_init_flag</a> (<a class="el" href="#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a> opts)</td></tr>
<tr class="memdesc:gac1a83f81fc67957df87596f813159ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes <code>spawn</code> to call `self-&gt;link_to(...) immediately / after the new actor was spawned.  <br /></td></tr>
<tr class="separator:gac1a83f81fc67957df87596f813159ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gabbb9f9de56a173754932f0c6473925ed" id="r_gabbb9f9de56a173754932f0c6473925ed"><td class="memItemLeft" align="right" valign="top"><a id="gabbb9f9de56a173754932f0c6473925ed" name="gabbb9f9de56a173754932f0c6473925ed"></a>
constexpr <a class="el" href="#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><b>caf::no_spawn_options</b> = spawn_options::no_flags</td></tr>
<tr class="memdesc:gabbb9f9de56a173754932f0c6473925ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes default settings. <br /></td></tr>
<tr class="separator:gabbb9f9de56a173754932f0c6473925ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga197ff1f076793001295b672ab23790a2" id="r_ga197ff1f076793001295b672ab23790a2"><td class="memItemLeft" align="right" valign="top"><a id="ga197ff1f076793001295b672ab23790a2" name="ga197ff1f076793001295b672ab23790a2"></a>
constexpr <a class="el" href="#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><b>caf::monitored</b> = spawn_options::monitor_flag</td></tr>
<tr class="separator:ga197ff1f076793001295b672ab23790a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<pre class="fragment">@mainpage CAF

@section Intro Introduction

This framework provides an implementation of the actor model for C++. It
uses network transparent messaging to ease development of concurrent and
distributed software.

To get started with the framework, please read the
[manual](https://actor-framework.readthedocs.io) first.

@section IntroHelloWorld Hello World Example

@include hello_world.cpp

@section IntroMoreExamples More Examples

The {@link math_actor.cpp Math Actor Example} shows the usage
of {@link receive_loop} and {@link caf::arg_match arg_match}.
The {@link dining_philosophers.cpp Dining Philosophers Example}
introduces event-based actors covers various features of CAF.

@namespace caf
Root namespace of libcaf.

@namespace caf::mixin
Contains mixin classes implementing several actor traits.

@namespace caf::exit_reason
Contains all predefined exit reasons.

@namespace caf::policy
Contains policies encapsulating characteristics or algorithms.

@namespace caf::telemetry
Contains classes and functions for collecting telemetry data.

@namespace caf::net
Contains all classes and functions related to network protocols.

@namespace caf::net::dsl
Contains building blocks to assemble protocol stacks in a declarative way.

@namespace caf::net::http
Contains an implementation for HTTP.

@namespace caf::net::ssl
Contains wrappers for convenient access to SSL.

@namespace caf::net::octet_stream
Contains classes and utilities for transports that operate on raw octets.

@namespace caf::net::prometheus
Contains a scraper for exposing metrics from an actor system to Prometheus.

@namespace caf::net::web_socket
Contains an implementation for message exchange over the WebSocket protocol.

@namespace caf::net::lp
Contains an implementation for message exchange over length-prefix framing.

@namespace caf::io
Contains all IO-related classes and functions.

@namespace caf::io::network
Contains classes and functions used for network abstraction.

@namespace caf::io::basp
Contains all classes and functions for the Binary Actor System Protocol.

@defgroup MessageHandling Message Handling

This is the beating heart of CAF, since actor programming is
a message oriented programming paradigm.

A message in CAF is a n-tuple of values (with size &gt;= 1).
You can use almost every type in a messages as long as it is announced,
i.e., known by the type system of CAF.

@defgroup BlockingAPI Blocking API

Blocking functions to receive messages.

The blocking API of CAF is intended to be used for migrating
previously threaded applications. When writing new code, you should
consider the nonblocking API based on `become` and `unbecome` first.

@section Send Sending Messages

The function `send` can be used to send a message to an actor.
The first argument is the receiver of the message followed by any number
of values:

~~
// spawn some actors
actor_system_config cfg;
actor_system system{cfg};
auto a1 = system.spawn(...);
auto a2 = system.spawn(...);
auto a3 = system.spawn(...);

// an actor executed in the current thread
scoped_actor self{system};

// define an atom for message annotation
using hello_atom = atom_constant&lt;atom("hello")&gt;;
using compute_atom = atom_constant&lt;atom("compute")&gt;;
using result_atom = atom_constant&lt;atom("result")&gt;;

// send a message to a1
self-&gt;mail(hello_atom::value, "hello a1!").send(a1);

// send a message to a1, a2, and a3
auto msg = make_message(compute_atom::value, 1, 2, 3);
self-&gt;mail(msg).send(a1);
self-&gt;mail(msg).send(a2);
self-&gt;mail(msg).send(a3);
~~

@section Receive Receive messages

The function `receive` takes a `behavior` as argument. The behavior
is a list of { callback } rules where the callback argument types
define a pattern for matching messages.

~~
{
  [&amp;self](hello_atom, const std::string&amp; msg) {
    self-&gt;println("received hello message: {}", msg);
  },
  [](compute_atom, int i0, int i1, int i2) {
    // send our result back to the sender of this messages
    return make_message(result_atom::value, i0 + i1 + i2);
  }
}
~~

Blocking actors such as the scoped actor can call their receive member
to handle incoming messages.

~~
self-&gt;receive(
 [&amp;self](result_atom, int i) {
   self-&gt;println("result is: {}", i);
 }
);
~~

Please read the manual for further details about pattern matching.

@section Atoms Atoms

Atoms are a nice way to add semantic information to a message. Assuming an
actor wants to provide a "math service" for integers. It could provide
operations such as addition, subtraction, etc. This operations all have two
operands. Thus, the actor does not know what operation the sender of a
message wanted by receiving just two integers.

Example actor:
~~
using plus_atom = atom_constant&lt;atom("plus")&gt;;
using minus_atom = atom_constant&lt;atom("minus")&gt;;
behavior math_actor() {
  return {
    [](plus_atom, int a, int b) {
      return make_message(atom("result"), a + b);
    },
    [](minus_atom, int a, int b) {
      return make_message(atom("result"), a - b);
    }
  };
}
~~

@section ReceiveLoops Receive Loops

The previous examples used `receive` to create a behavior on-the-fly.
This is inefficient in a loop since the argument passed to receive
is created in each iteration again. It's possible to store the behavior
in a variable and pass that variable to receive. This fixes the issue
of re-creation each iteration but rips apart definition and usage.

There are three convenience functions implementing receive loops to
declare behavior where it belongs without unnecessary
copies: `receive_while,` `receive_for` and `do_receive`.

`receive_while` creates a functor evaluating a lambda expression.
The loop continues until the given lambda returns `false`. A simple example:

~~
size_t received = 0;
receive_while([&amp;] { return received &lt; 10; }) (
  [&amp;](int) {
    ++received;
  }
);
// ...
~~

`receive_for` is a simple ranged-based loop:

~~
std::vector&lt;int&gt; results;
size_t i = 0;
receive_for(i, 10) (
  [&amp;](int value) {
    results.push_back(value);
  }
);
~~

`do_receive` returns a functor providing the function `until` that
takes a lambda expression. The loop continues until the given lambda
returns true. Example:

~~
size_t received = 0;
do_receive (
  [&amp;](int) {
    ++received;
  }
).until([&amp;] { return received &gt;= 10; });
// ...
~~

@section FutureSend Sending Delayed Messages

The function `delayed_send` provides a simple way to delay a message.
This is particularly useful for recurring events, e.g., periodical polling.
Usage example:

~~
scoped_actor self{...};

self-&gt;mail(poll_atom::value).delay(std::chrono::seconds(1)).send(self);
bool running = true;
self-&gt;receive_while([&amp;](){ return running; }) (
  // ...
  [&amp;](poll_atom) {
    // ... poll something ...
    // and do it again after 1sec
    self-&gt;mail(poll_atom::value).delay(std::chrono::seconds(1)).send(self);
  }
);
~~

See also the {@link dancing_kirby.cpp dancing kirby example}.

@defgroup ImplicitConversion Implicit Type Conversions

The message passing of `libcaf` prohibits pointers in messages because
it enforces network transparent messaging.
Unfortunately, string literals in `C++` have the type `const char*,
</pre><p> / resp. <code>const char[]. Since</code>libcaf<code>is a user-friendly library, it silently converts string literals and C-strings to</code>std::string` objects. It also converts unicode literals to the corresponding STL container.</p>
<p>A few examples: ~~ // sends an std::string containing "hello actor!" to itself send(self, "hello actor!");</p>
<p>const char* cstring = "cstring"; // sends an std::string containing "cstring" to itself send(self, cstring);</p>
<p>// sends an std::u16string containing "hello unicode world!" send(self, u"hello unicode world!");</p>
<p>// x has the type caf::tuple&lt;std::string, std::string&gt; auto x = make_message("hello", "tuple"); ~~</p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac1a83f81fc67957df87596f813159ba4" name="gac1a83f81fc67957df87596f813159ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1a83f81fc67957df87596f813159ba4">&#9670;&#160;</a></span>has_lazy_init_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool caf::has_lazy_init_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga291d9d4fcae86cf8d3de7d28c500a308">spawn_options</a></td>          <td class="paramname"><span class="paramname"><em>opts</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes <code>spawn</code> to call `self-&gt;link_to(...) immediately / after the new actor was spawned. </p>
<p>constexpr spawn_options linked = spawn_options::link_flag;</p>
<p>/ Causes the new actor to opt out of the cooperative scheduling. constexpr spawn_options detached = spawn_options::detach_flag;</p>
<p>/ Causes the runtime to ignore the new actor in <code>await_all_actors_done()</code>. constexpr spawn_options hidden = spawn_options::hide_flag;</p>
<p>/ Causes the new actor to delay its / initialization until a message arrives. constexpr spawn_options lazy_init = spawn_options::lazy_init_flag;</p>
<p>/ Checks whether <code>haystack</code> contains <code>needle</code>. constexpr bool has_spawn_option(spawn_options haystack, spawn_options needle) { return (static_cast&lt;int&gt;(haystack) &amp; static_cast&lt;int&gt;(needle)) != 0; }</p>
<p>/ Checks whether the <code><a class="el" href="">detached</a></code> flag is set in <code>opts</code>. constexpr bool has_detach_flag(spawn_options opts) { return has_spawn_option(opts, detached); }</p>
<p>/ Checks whether the <code><a class="el" href="">priority_aware</a></code> flag is set in <code>opts</code>. constexpr bool has_priority_aware_flag(spawn_options) { return true; }</p>
<p>/ Checks whether the <code><a class="el" href="">hidden</a></code> flag is set in <code>opts</code>. constexpr bool has_hide_flag(spawn_options opts) { return has_spawn_option(opts, hidden); }</p>
<p>/ Checks whether the <code><a class="el" href="">linked</a></code> flag is set in <code>opts</code>. constexpr bool has_link_flag(spawn_options opts) { return has_spawn_option(opts, linked); }</p>
<p>/ Checks whether the <code><a class="el" href="#ga197ff1f076793001295b672ab23790a2">monitored</a></code> flag is set in <code>opts</code>. constexpr bool has_monitor_flag(spawn_options opts) { return has_spawn_option(opts, spawn_options::monitor_flag); }</p>
<p>/ Checks whether the <code><a class="el" href="">lazy_init</a></code> flag is set in <code>opts</code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
