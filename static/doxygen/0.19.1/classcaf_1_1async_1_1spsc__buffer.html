<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ Actor Framework: caf::async::spsc_buffer&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C++ Actor Framework<span id="projectnumber">&#160;0.19</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecaf.html">caf</a></li><li class="navelem"><b>async</b></li><li class="navelem"><a class="el" href="classcaf_1_1async_1_1spsc__buffer.html">spsc_buffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classcaf_1_1async_1_1spsc__buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">caf::async::spsc_buffer&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A Single Producer Single Consumer buffer.  
 <a href="classcaf_1_1async_1_1spsc__buffer.html#details">More...</a></p>

<p><code>#include &lt;spsc_buffer.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for caf::async::spsc_buffer&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcaf_1_1async_1_1spsc__buffer.png" usemap="#caf::async::spsc_5Fbuffer_3C_20T_20_3E_map" alt=""/>
  <map id="caf::async::spsc_5Fbuffer_3C_20T_20_3E_map" name="caf::async::spsc_5Fbuffer_3C_20T_20_3E_map">
<area href="classcaf_1_1ref__counted.html" title="Base class for reference counted objects with an atomic reference count." alt="caf::ref_counted" shape="rect" coords="0,56,183,80"/>
<area href="classcaf_1_1detail_1_1atomic__ref__counted.html" title="Base class for reference counted objects with an atomic reference count." alt="caf::detail::atomic_ref_counted" shape="rect" coords="0,0,183,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaf_1_1async_1_1spsc__buffer_1_1flags.html">flags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs various status flags for the buffer into a single struct.  <a href="structcaf_1_1async_1_1spsc__buffer_1_1flags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1626849e49ddd34298cc5ec8d78f2571"><td class="memItemLeft" align="right" valign="top"><a id="a1626849e49ddd34298cc5ec8d78f2571" name="a1626849e49ddd34298cc5ec8d78f2571"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a1626849e49ddd34298cc5ec8d78f2571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6176c7d91f5acae0e829d10cb5e5e68d"><td class="memItemLeft" align="right" valign="top"><a id="a6176c7d91f5acae0e829d10cb5e5e68d" name="a6176c7d91f5acae0e829d10cb5e5e68d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>lock_type</b> = std::unique_lock&lt; std::mutex &gt;</td></tr>
<tr class="separator:a6176c7d91f5acae0e829d10cb5e5e68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classcaf_1_1ref__counted"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcaf_1_1ref__counted')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classcaf_1_1ref__counted.html">caf::ref_counted</a></td></tr>
<tr class="memitem:a09dd639f1fa1ec5c2712dc18e8c52f61 inherit pub_types_classcaf_1_1ref__counted"><td class="memItemLeft" align="right" valign="top"><a id="a09dd639f1fa1ec5c2712dc18e8c52f61" name="a09dd639f1fa1ec5c2712dc18e8c52f61"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>super</b> = <a class="el" href="classcaf_1_1detail_1_1atomic__ref__counted.html">detail::atomic_ref_counted</a></td></tr>
<tr class="separator:a09dd639f1fa1ec5c2712dc18e8c52f61 inherit pub_types_classcaf_1_1ref__counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a64a7bf4010b9773e206636970b13871f"><td class="memItemLeft" align="right" valign="top"><a id="a64a7bf4010b9773e206636970b13871f" name="a64a7bf4010b9773e206636970b13871f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>spsc_buffer</b> (uint32_t <a class="el" href="classcaf_1_1async_1_1spsc__buffer.html#ad6e550a88d18d98b7d8615dd71e7a26d">capacity</a>, uint32_t min_pull_size)</td></tr>
<tr class="separator:a64a7bf4010b9773e206636970b13871f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad932876f191d522d0385e3fe4ce271cc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1async_1_1spsc__buffer.html#ad932876f191d522d0385e3fe4ce271cc">push</a> (<a class="el" href="classcaf_1_1span.html">span</a>&lt; const T &gt; items)</td></tr>
<tr class="memdesc:ad932876f191d522d0385e3fe4ce271cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to the buffer and calls <code>on_producer_wakeup</code> on the consumer if the buffer becomes non-empty.  <br /></td></tr>
<tr class="separator:ad932876f191d522d0385e3fe4ce271cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28a24545afe59b615aeadecea663130"><td class="memItemLeft" align="right" valign="top"><a id="af28a24545afe59b615aeadecea663130" name="af28a24545afe59b615aeadecea663130"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>push</b> (const T &amp;item)</td></tr>
<tr class="separator:af28a24545afe59b615aeadecea663130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d0be89043154ff45b11e6fd64f7c7c"><td class="memTemplParams" colspan="2">template&lt;class Policy , class Observer &gt; </td></tr>
<tr class="memitem:a39d0be89043154ff45b11e6fd64f7c7c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcaf_1_1async_1_1spsc__buffer.html#a39d0be89043154ff45b11e6fd64f7c7c">pull</a> (Policy policy, size_t demand, Observer &amp;dst)</td></tr>
<tr class="memdesc:a39d0be89043154ff45b11e6fd64f7c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes up to <code>demand</code> items from the buffer.  <br /></td></tr>
<tr class="separator:a39d0be89043154ff45b11e6fd64f7c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee934f8d747054cd7931438f80341b65"><td class="memItemLeft" align="right" valign="top"><a id="aee934f8d747054cd7931438f80341b65" name="aee934f8d747054cd7931438f80341b65"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_data</b> () const noexcept</td></tr>
<tr class="memdesc:aee934f8d747054cd7931438f80341b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether there is any pending data in the buffer. <br /></td></tr>
<tr class="separator:aee934f8d747054cd7931438f80341b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca268c51bfe68bb45fa95c8ad1f7c9a"><td class="memItemLeft" align="right" valign="top"><a id="a7ca268c51bfe68bb45fa95c8ad1f7c9a" name="a7ca268c51bfe68bb45fa95c8ad1f7c9a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_consumer_event</b> () const noexcept</td></tr>
<tr class="memdesc:a7ca268c51bfe68bb45fa95c8ad1f7c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the there is data available or whether the producer has closed or aborted the flow. <br /></td></tr>
<tr class="separator:a7ca268c51bfe68bb45fa95c8ad1f7c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a7dd3a28703c618da33fe442084b69"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1async_1_1spsc__buffer.html#a74a7dd3a28703c618da33fe442084b69">available</a> () const noexcept</td></tr>
<tr class="memdesc:a74a7dd3a28703c618da33fe442084b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many items are currently available.  <br /></td></tr>
<tr class="separator:a74a7dd3a28703c618da33fe442084b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1102d28e8deb2e5f04ea8ac141035b11"><td class="memItemLeft" align="right" valign="top"><a id="a1102d28e8deb2e5f04ea8ac141035b11" name="a1102d28e8deb2e5f04ea8ac141035b11"></a>
<a class="el" href="classcaf_1_1error.html">error</a>&#160;</td><td class="memItemRight" valign="bottom"><b>abort_reason</b> () const</td></tr>
<tr class="memdesc:a1102d28e8deb2e5f04ea8ac141035b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error from the producer or a default-constructed error if abort was not called yet. <br /></td></tr>
<tr class="separator:a1102d28e8deb2e5f04ea8ac141035b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c928875510aed1b241cb0ced197e94"><td class="memItemLeft" align="right" valign="top"><a id="af7c928875510aed1b241cb0ced197e94" name="af7c928875510aed1b241cb0ced197e94"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>close</b> ()</td></tr>
<tr class="memdesc:af7c928875510aed1b241cb0ced197e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the buffer by request of the producer. <br /></td></tr>
<tr class="separator:af7c928875510aed1b241cb0ced197e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888954753b86b33f6ca973b6366c1b9c"><td class="memItemLeft" align="right" valign="top"><a id="a888954753b86b33f6ca973b6366c1b9c" name="a888954753b86b33f6ca973b6366c1b9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>abort</b> (<a class="el" href="classcaf_1_1error.html">error</a> reason)</td></tr>
<tr class="memdesc:a888954753b86b33f6ca973b6366c1b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the buffer by request of the producer and signals an error to the consumer. <br /></td></tr>
<tr class="separator:a888954753b86b33f6ca973b6366c1b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4012d9d7161d7b614fad654e4adff4f"><td class="memItemLeft" align="right" valign="top"><a id="ac4012d9d7161d7b614fad654e4adff4f" name="ac4012d9d7161d7b614fad654e4adff4f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cancel</b> ()</td></tr>
<tr class="memdesc:ac4012d9d7161d7b614fad654e4adff4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the buffer by request of the consumer. <br /></td></tr>
<tr class="separator:ac4012d9d7161d7b614fad654e4adff4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc07b371e13c614d9c252c8926956568"><td class="memItemLeft" align="right" valign="top"><a id="adc07b371e13c614d9c252c8926956568" name="adc07b371e13c614d9c252c8926956568"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_consumer</b> (consumer_ptr <a class="el" href="classcaf_1_1async_1_1consumer.html">consumer</a>)</td></tr>
<tr class="memdesc:adc07b371e13c614d9c252c8926956568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumer callback for the initial handshake between producer and consumer. <br /></td></tr>
<tr class="separator:adc07b371e13c614d9c252c8926956568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb16c93d6a5ecaa59efc00ceaf7cc8d"><td class="memItemLeft" align="right" valign="top"><a id="a3bb16c93d6a5ecaa59efc00ceaf7cc8d" name="a3bb16c93d6a5ecaa59efc00ceaf7cc8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_producer</b> (producer_ptr <a class="el" href="classcaf_1_1async_1_1producer.html">producer</a>)</td></tr>
<tr class="memdesc:a3bb16c93d6a5ecaa59efc00ceaf7cc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Producer callback for the initial handshake between producer and consumer. <br /></td></tr>
<tr class="separator:a3bb16c93d6a5ecaa59efc00ceaf7cc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e550a88d18d98b7d8615dd71e7a26d"><td class="memItemLeft" align="right" valign="top"><a id="ad6e550a88d18d98b7d8615dd71e7a26d" name="ad6e550a88d18d98b7d8615dd71e7a26d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b> () const noexcept</td></tr>
<tr class="memdesc:ad6e550a88d18d98b7d8615dd71e7a26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the capacity as passed to the constructor of the buffer. <br /></td></tr>
<tr class="separator:ad6e550a88d18d98b7d8615dd71e7a26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfac81fb401b0c1d47cc4892129726a4"><td class="memItemLeft" align="right" valign="top"><a id="acfac81fb401b0c1d47cc4892129726a4" name="acfac81fb401b0c1d47cc4892129726a4"></a>
auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>mtx</b> () const noexcept</td></tr>
<tr class="memdesc:acfac81fb401b0c1d47cc4892129726a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mutex for this object. <br /></td></tr>
<tr class="separator:acfac81fb401b0c1d47cc4892129726a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8f6938cf59fc45941456f1af17c461"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1async_1_1spsc__buffer.html#a4c8f6938cf59fc45941456f1af17c461">available_unsafe</a> () const noexcept</td></tr>
<tr class="memdesc:a4c8f6938cf59fc45941456f1af17c461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many items are currently available.  <br /></td></tr>
<tr class="separator:a4c8f6938cf59fc45941456f1af17c461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae8a9052d958d086b223a5ac84f27b7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcaf_1_1error.html">error</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1async_1_1spsc__buffer.html#adae8a9052d958d086b223a5ac84f27b7">abort_reason_unsafe</a> () const noexcept</td></tr>
<tr class="memdesc:adae8a9052d958d086b223a5ac84f27b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error from the producer.  <br /></td></tr>
<tr class="separator:adae8a9052d958d086b223a5ac84f27b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c89e10e0d275fd9b9222954ef530c9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaf_1_1async_1_1spsc__buffer.html#a0c89e10e0d275fd9b9222954ef530c9d">await_consumer_ready</a> (lock_type &amp;guard, std::condition_variable &amp;cv)</td></tr>
<tr class="memdesc:a0c89e10e0d275fd9b9222954ef530c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until there is at least one item available or the producer stopped.  <br /></td></tr>
<tr class="separator:a0c89e10e0d275fd9b9222954ef530c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad696e83967da3efdb35ab36a4b9f6ac7"><td class="memTemplParams" colspan="2">template&lt;class TimePoint &gt; </td></tr>
<tr class="memitem:ad696e83967da3efdb35ab36a4b9f6ac7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcaf_1_1async_1_1spsc__buffer.html#ad696e83967da3efdb35ab36a4b9f6ac7">await_consumer_ready</a> (lock_type &amp;guard, std::condition_variable &amp;cv, TimePoint timeout)</td></tr>
<tr class="memdesc:ad696e83967da3efdb35ab36a4b9f6ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until there is at least one item available, the producer stopped, or a timeout occurs.  <br /></td></tr>
<tr class="separator:ad696e83967da3efdb35ab36a4b9f6ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac904b7126be77718d2549ce60643e351"><td class="memTemplParams" colspan="2"><a id="ac904b7126be77718d2549ce60643e351" name="ac904b7126be77718d2549ce60643e351"></a>
template&lt;class Policy , class Observer &gt; </td></tr>
<tr class="memitem:ac904b7126be77718d2549ce60643e351"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pull_unsafe</b> (lock_type &amp;guard, Policy, size_t demand, Observer &amp;dst)</td></tr>
<tr class="separator:ac904b7126be77718d2549ce60643e351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcaf_1_1detail_1_1atomic__ref__counted')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcaf_1_1detail_1_1atomic__ref__counted.html">caf::detail::atomic_ref_counted</a></td></tr>
<tr class="memitem:a8563bcae271b09698f6b124892ac192d inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="memItemLeft" align="right" valign="top"><a id="a8563bcae271b09698f6b124892ac192d" name="a8563bcae271b09698f6b124892ac192d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>atomic_ref_counted</b> (const <a class="el" href="classcaf_1_1detail_1_1atomic__ref__counted.html">atomic_ref_counted</a> &amp;)</td></tr>
<tr class="separator:a8563bcae271b09698f6b124892ac192d inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f21424ddbd264ecf4b58b770c936330 inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="memItemLeft" align="right" valign="top"><a id="a4f21424ddbd264ecf4b58b770c936330" name="a4f21424ddbd264ecf4b58b770c936330"></a>
<a class="el" href="classcaf_1_1detail_1_1atomic__ref__counted.html">atomic_ref_counted</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classcaf_1_1detail_1_1atomic__ref__counted.html">atomic_ref_counted</a> &amp;)</td></tr>
<tr class="separator:a4f21424ddbd264ecf4b58b770c936330 inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0236768cf816c95727109bde8980fa inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="memItemLeft" align="right" valign="top"><a id="aef0236768cf816c95727109bde8980fa" name="aef0236768cf816c95727109bde8980fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ref</b> () const noexcept</td></tr>
<tr class="memdesc:aef0236768cf816c95727109bde8980fa inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases reference count by one. <br /></td></tr>
<tr class="separator:aef0236768cf816c95727109bde8980fa inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d7eacacdfa45ed8e0bd1ca17548a82 inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="memItemLeft" align="right" valign="top"><a id="a74d7eacacdfa45ed8e0bd1ca17548a82" name="a74d7eacacdfa45ed8e0bd1ca17548a82"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>deref</b> () const noexcept</td></tr>
<tr class="memdesc:a74d7eacacdfa45ed8e0bd1ca17548a82 inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases reference count by one and calls <code>request_deletion</code> when it drops to zero. <br /></td></tr>
<tr class="separator:a74d7eacacdfa45ed8e0bd1ca17548a82 inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bca4f5d134bcd22f218f50adead3bd0 inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="memItemLeft" align="right" valign="top"><a id="a3bca4f5d134bcd22f218f50adead3bd0" name="a3bca4f5d134bcd22f218f50adead3bd0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>unique</b> () const noexcept</td></tr>
<tr class="memdesc:a3bca4f5d134bcd22f218f50adead3bd0 inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries whether there is exactly one reference. <br /></td></tr>
<tr class="separator:a3bca4f5d134bcd22f218f50adead3bd0 inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3d982369f0979d8800639f52324db2 inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="memItemLeft" align="right" valign="top"><a id="a9e3d982369f0979d8800639f52324db2" name="a9e3d982369f0979d8800639f52324db2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_reference_count</b> () const noexcept</td></tr>
<tr class="memdesc:a9e3d982369f0979d8800639f52324db2 inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the current reference count for this object. <br /></td></tr>
<tr class="separator:a9e3d982369f0979d8800639f52324db2 inherit pub_methods_classcaf_1_1detail_1_1atomic__ref__counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ab75b5d84bc329d8e9c0a201dce9cad22"><td class="memTemplParams" colspan="2"><a id="ab75b5d84bc329d8e9c0a201dce9cad22" name="ab75b5d84bc329d8e9c0a201dce9cad22"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab75b5d84bc329d8e9c0a201dce9cad22"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spsc_buffer_ptr</b> = <a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcaf_1_1async_1_1spsc__buffer.html">spsc_buffer</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:ab75b5d84bc329d8e9c0a201dce9cad22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classcaf_1_1ref__counted"><td colspan="2" onclick="javascript:toggleInherit('related_classcaf_1_1ref__counted')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classcaf_1_1ref__counted.html">caf::ref_counted</a></td></tr>
<tr class="memitem:af0c5bd9c4cefb4df66897945c067d14d inherit related_classcaf_1_1ref__counted"><td class="memTemplParams" colspan="2">template&lt;class T , class... Ts&gt; </td></tr>
<tr class="memitem:af0c5bd9c4cefb4df66897945c067d14d inherit related_classcaf_1_1ref__counted"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1intrusive__cow__ptr.html">intrusive_cow_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcaf_1_1ref__counted.html#af0c5bd9c4cefb4df66897945c067d14d">make_copy_on_write</a> (Ts &amp;&amp;... xs)</td></tr>
<tr class="memdesc:af0c5bd9c4cefb4df66897945c067d14d inherit related_classcaf_1_1ref__counted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type <code>T</code> in an <code><a class="el" href="classcaf_1_1intrusive__cow__ptr.html" title="An intrusive, reference counting smart pointer implementation with copy-on-write optimization.">intrusive_cow_ptr</a></code>.  <br /></td></tr>
<tr class="separator:af0c5bd9c4cefb4df66897945c067d14d inherit related_classcaf_1_1ref__counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bc45fb7002dd4d5698a8c5014b153f inherit related_classcaf_1_1ref__counted"><td class="memTemplParams" colspan="2"><a id="a61bc45fb7002dd4d5698a8c5014b153f" name="a61bc45fb7002dd4d5698a8c5014b153f"></a>
template&lt;class T , class... Ts&gt; </td></tr>
<tr class="memitem:a61bc45fb7002dd4d5698a8c5014b153f inherit related_classcaf_1_1ref__counted"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaf_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_counted</b> (Ts &amp;&amp;... xs)</td></tr>
<tr class="memdesc:a61bc45fb7002dd4d5698a8c5014b153f inherit related_classcaf_1_1ref__counted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type <code>T</code> in an <code><a class="el" href="classcaf_1_1intrusive__ptr.html" title="An intrusive, reference counting smart pointer implementation.">intrusive_ptr</a></code>. <br /></td></tr>
<tr class="separator:a61bc45fb7002dd4d5698a8c5014b153f inherit related_classcaf_1_1ref__counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classcaf_1_1detail_1_1atomic__ref__counted"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcaf_1_1detail_1_1atomic__ref__counted')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcaf_1_1detail_1_1atomic__ref__counted.html">caf::detail::atomic_ref_counted</a></td></tr>
<tr class="memitem:abd40afc497c15a506a486f2cc160119d inherit pro_attribs_classcaf_1_1detail_1_1atomic__ref__counted"><td class="memItemLeft" align="right" valign="top"><a id="abd40afc497c15a506a486f2cc160119d" name="abd40afc497c15a506a486f2cc160119d"></a>
std::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>rc_</b></td></tr>
<tr class="separator:abd40afc497c15a506a486f2cc160119d inherit pro_attribs_classcaf_1_1detail_1_1atomic__ref__counted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class caf::async::spsc_buffer&lt; T &gt;</div><p>A Single Producer Single Consumer buffer. </p>
<p>The buffer uses a "soft bound", which means that the producer announces a desired maximum for in-flight items that the buffer uses for its bookkeeping, but the producer may add more than that number of items. Allowing producers to go "beyond the limit" is intended for producer that transform inputs into outputs where one input event can produce multiple output items.</p>
<p>Aside from providing storage, this buffer also resumes the consumer if data is available and signals demand to the producer whenever the consumer takes data out of the buffer. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="adae8a9052d958d086b223a5ac84f27b7" name="adae8a9052d958d086b223a5ac84f27b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae8a9052d958d086b223a5ac84f27b7">&#9670;&#160;</a></span>abort_reason_unsafe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcaf_1_1error.html">error</a> &amp; <a class="el" href="classcaf_1_1async_1_1spsc__buffer.html">caf::async::spsc_buffer</a>&lt; T &gt;::abort_reason_unsafe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the error from the producer. </p>
<dl class="section pre"><dt>Precondition</dt><dd>'<a class="el" href="classcaf_1_1async_1_1spsc__buffer.html#acfac81fb401b0c1d47cc4892129726a4" title="Returns the mutex for this object.">mtx()</a>' is locked. </dd></dl>

</div>
</div>
<a id="a74a7dd3a28703c618da33fe442084b69" name="a74a7dd3a28703c618da33fe442084b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a7dd3a28703c618da33fe442084b69">&#9670;&#160;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcaf_1_1async_1_1spsc__buffer.html">caf::async::spsc_buffer</a>&lt; T &gt;::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns how many items are currently available. </p>
<p>This may be greater than the <code>capacity</code>. </p>

</div>
</div>
<a id="a4c8f6938cf59fc45941456f1af17c461" name="a4c8f6938cf59fc45941456f1af17c461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8f6938cf59fc45941456f1af17c461">&#9670;&#160;</a></span>available_unsafe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcaf_1_1async_1_1spsc__buffer.html">caf::async::spsc_buffer</a>&lt; T &gt;::available_unsafe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns how many items are currently available. </p>
<dl class="section pre"><dt>Precondition</dt><dd>'<a class="el" href="classcaf_1_1async_1_1spsc__buffer.html#acfac81fb401b0c1d47cc4892129726a4" title="Returns the mutex for this object.">mtx()</a>' is locked. </dd></dl>

</div>
</div>
<a id="a0c89e10e0d275fd9b9222954ef530c9d" name="a0c89e10e0d275fd9b9222954ef530c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c89e10e0d275fd9b9222954ef530c9d">&#9670;&#160;</a></span>await_consumer_ready() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcaf_1_1async_1_1spsc__buffer.html">caf::async::spsc_buffer</a>&lt; T &gt;::await_consumer_ready </td>
          <td>(</td>
          <td class="paramtype">lock_type &amp;&#160;</td>
          <td class="paramname"><em>guard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::condition_variable &amp;&#160;</td>
          <td class="paramname"><em>cv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks until there is at least one item available or the producer stopped. </p>
<dl class="section pre"><dt>Precondition</dt><dd>the consumer calls <code>cv.notify_all()</code> in its <code>on_producer_wakeup</code> </dd></dl>

</div>
</div>
<a id="ad696e83967da3efdb35ab36a4b9f6ac7" name="ad696e83967da3efdb35ab36a4b9f6ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad696e83967da3efdb35ab36a4b9f6ac7">&#9670;&#160;</a></span>await_consumer_ready() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class TimePoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcaf_1_1async_1_1spsc__buffer.html">caf::async::spsc_buffer</a>&lt; T &gt;::await_consumer_ready </td>
          <td>(</td>
          <td class="paramtype">lock_type &amp;&#160;</td>
          <td class="paramname"><em>guard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::condition_variable &amp;&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimePoint&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks until there is at least one item available, the producer stopped, or a timeout occurs. </p>
<dl class="section pre"><dt>Precondition</dt><dd>the consumer calls <code>cv.notify_all()</code> in its <code>on_producer_wakeup</code> </dd></dl>

</div>
</div>
<a id="a39d0be89043154ff45b11e6fd64f7c7c" name="a39d0be89043154ff45b11e6fd64f7c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d0be89043154ff45b11e6fd64f7c7c">&#9670;&#160;</a></span>pull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class Policy , class Observer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, size_t &gt; <a class="el" href="classcaf_1_1async_1_1spsc__buffer.html">caf::async::spsc_buffer</a>&lt; T &gt;::pull </td>
          <td>(</td>
          <td class="paramtype">Policy&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>demand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Observer &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consumes up to <code>demand</code> items from the buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Policy</td><td>Either <code>instant_error_t</code>, <code>delay_error_t</code> or <code>ignore_errors_t</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple indicating whether the consumer may call pull again and how many items were consumed. When returning <code>false</code> for the first tuple element, the function has called <code>on_complete</code> or <code>on_error</code> on the observer. </dd></dl>

</div>
</div>
<a id="ad932876f191d522d0385e3fe4ce271cc" name="ad932876f191d522d0385e3fe4ce271cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad932876f191d522d0385e3fe4ce271cc">&#9670;&#160;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcaf_1_1async_1_1spsc__buffer.html">caf::async::spsc_buffer</a>&lt; T &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcaf_1_1span.html">span</a>&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>items</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to the buffer and calls <code>on_producer_wakeup</code> on the consumer if the buffer becomes non-empty. </p>
<dl class="section return"><dt>Returns</dt><dd>the remaining capacity after inserting the items. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libcaf_core/caf/async/fwd.hpp</li>
<li>libcaf_core/caf/async/spsc_buffer.hpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
